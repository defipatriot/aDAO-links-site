<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DAO Governance Audit Tool</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { background: #0a0a0f; }
        .scrollbar-thin::-webkit-scrollbar { width: 6px; height: 6px; }
        .scrollbar-thin::-webkit-scrollbar-track { background: #1a1a2e; }
        .scrollbar-thin::-webkit-scrollbar-thumb { background: #4a4a6a; border-radius: 3px; }
        .tab-btn { cursor: pointer; padding: 8px 16px; border-radius: 6px; transition: all 0.2s; }
        .tab-btn:hover { background: rgba(59, 130, 246, 0.2); }
        .tab-btn.active { background: rgba(59, 130, 246, 0.3); border: 1px solid #3b82f6; }
        textarea, input[type="text"] { background: #1a1a2e; border: 1px solid #2a2a4e; }
        textarea:focus, input:focus { outline: none; border-color: #3b82f6; }
        .proposal-card { transition: all 0.2s; }
        .proposal-card:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.3); }
    </style>
</head>
<body class="text-gray-200 min-h-screen">
    <!-- Header -->
    <div class="bg-gradient-to-r from-blue-900/50 to-purple-900/50 border-b border-blue-500/30 p-4">
        <div class="max-w-7xl mx-auto flex items-center justify-between">
            <div class="flex items-center gap-4">
                <h1 class="text-2xl font-bold text-blue-400">üèõÔ∏è DAO Governance Audit Tool</h1>
                <span id="dao-name" class="text-sm text-gray-400">AllianceDAO</span>
            </div>
            <div class="flex items-center gap-4">
                <span id="member-count" class="text-sm text-gray-400">Loading members...</span>
                <button onclick="exportAllData()" class="text-xs bg-green-600 hover:bg-green-500 px-3 py-1 rounded">
                    üì§ Export All
                </button>
                <button onclick="clearAllData()" class="text-xs bg-red-600 hover:bg-red-500 px-3 py-1 rounded">
                    üóëÔ∏è Clear Cache
                </button>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <div class="max-w-7xl mx-auto p-4">
        <!-- Tabs -->
        <div class="flex gap-2 mb-4 border-b border-gray-700 pb-2">
            <div class="tab-btn active" onclick="switchTab('parse')" id="tab-parse">üìù Parse Proposal</div>
            <div class="tab-btn" onclick="switchTab('proposals')" id="tab-proposals">üìä Proposals (<span id="prop-count">0</span>)</div>
            <div class="tab-btn" onclick="switchTab('members')" id="tab-members">üë• Members</div>
            <div class="tab-btn" onclick="switchTab('registry')" id="tab-registry">üìö Registry</div>
        </div>

        <!-- Parse Tab -->
        <div id="content-parse" class="tab-content">
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-4">
                <!-- Input Section -->
                <div class="space-y-3">
                    <!-- JSON File Upload -->
                    <div class="bg-gray-900/50 border border-gray-700 rounded-lg p-3">
                        <div class="flex items-center justify-between mb-2">
                            <h3 class="text-sm font-bold text-orange-400">üìÇ Upload DAODAO JSON Export</h3>
                            <span class="text-[10px] text-gray-500">Drag & drop or click</span>
                        </div>
                        <div id="json-drop-zone" class="border-2 border-dashed border-gray-600 rounded-lg p-4 text-center hover:border-orange-500 transition cursor-pointer">
                            <div class="text-gray-400 text-xs pointer-events-none">
                                <span class="text-2xl">üìÑ</span><br>
                                Drop DAODAO JSON file here<br>
                                <span class="text-[10px] text-gray-500">(e.g., A25.json from browser export)</span>
                            </div>
                        </div>
                        <input type="file" id="json-file-input" class="hidden" accept=".json">
                        <div id="json-file-status" class="text-xs text-gray-500 mt-2 hidden"></div>
                    </div>

                    <div class="text-center text-gray-500 text-xs">‚Äî OR ‚Äî</div>

                    <!-- Quick Fetch by ID -->
                    <div class="bg-gray-900/50 border border-gray-700 rounded-lg p-3">
                        <h3 class="text-sm font-bold text-green-400 mb-2">‚ö° Quick Fetch by Proposal ID</h3>
                        <div class="flex gap-2">
                            <input type="text" id="quick-fetch-id" class="flex-1 px-2 py-1.5 rounded text-sm" placeholder="e.g. 25 or A25">
                            <button onclick="quickFetchProposal()" class="text-xs bg-green-700 hover:bg-green-600 px-4 py-1.5 rounded font-bold">
                                üîÑ Fetch All
                            </button>
                        </div>
                        <div class="text-[10px] text-gray-500 mt-1">
                            Fetches proposal data + voters directly from chain/indexer
                        </div>
                    </div>

                    <div class="text-center text-gray-500 text-xs">‚Äî OR ‚Äî</div>

                    <div class="bg-gray-900/50 border border-gray-700 rounded-lg p-3">
                        <div class="flex items-center justify-between mb-2">
                            <h3 class="text-sm font-bold text-blue-400">üìã Paste DAODAO Proposal Page</h3>
                            <button onclick="clearPaste()" class="text-xs text-gray-400 hover:text-white">Clear</button>
                        </div>
                        <textarea id="proposal-paste" class="w-full h-32 text-xs p-2 rounded font-mono scrollbar-thin" 
                            placeholder="Copy entire DAODAO proposal page (with 'Show raw data' expanded) and paste here..."></textarea>
                        <div class="flex gap-2 mt-2">
                            <button onclick="parseProposal()" class="flex-1 text-xs bg-cyan-700 hover:bg-cyan-600 px-3 py-2 rounded">
                                üîç Parse Proposal
                            </button>
                            <button onclick="saveProposal()" class="flex-1 text-xs bg-green-700 hover:bg-green-600 px-3 py-2 rounded">
                                üíæ Save Proposal
                            </button>
                        </div>
                    </div>

                    <!-- Quick TX Data from Chainscope -->
                    <div class="bg-gray-900/50 border border-gray-700 rounded-lg p-3">
                        <h3 class="text-sm font-bold text-purple-400 mb-2">‚ö° Quick TX Data (Chainscope)</h3>
                        <textarea id="chainscope-paste" class="w-full h-20 text-xs p-2 rounded font-mono scrollbar-thin"
                            placeholder="Paste Chainscope TX page to extract timestamp, hash, block..."></textarea>
                        <button onclick="parseChainscope()" class="w-full text-xs bg-purple-700 hover:bg-purple-600 px-3 py-1.5 rounded mt-2">
                            üîó Extract TX Data
                        </button>
                    </div>

                    <!-- Raw Actions Data -->
                    <div class="bg-gray-900/50 border border-gray-700 rounded-lg p-3">
                        <h3 class="text-sm font-bold text-red-400 mb-2">üîß Raw Actions Data</h3>
                        <textarea id="raw-actions-paste" class="w-full h-20 text-xs p-2 rounded font-mono scrollbar-thin"
                            placeholder='Paste the raw actions JSON array: [{"wasm":{...}}, {"bank":{...}}]'></textarea>
                        <div class="flex gap-2 mt-2">
                            <button onclick="parseRawActions()" class="flex-1 text-xs bg-red-700 hover:bg-red-600 px-3 py-1.5 rounded">
                                üîç Parse Raw
                            </button>
                            <button onclick="fetchProposalFromChain()" class="flex-1 text-xs bg-indigo-700 hover:bg-indigo-600 px-3 py-1.5 rounded">
                                ‚õìÔ∏è Fetch Actions
                            </button>
                            <button onclick="fetchAllData()" class="flex-1 text-xs bg-green-700 hover:bg-green-600 px-3 py-1.5 rounded">
                                üîÑ Fetch All
                            </button>
                        </div>
                        <div class="text-[10px] text-gray-500 mt-1">
                            "Fetch All" = raw actions + voters from indexer
                        </div>
                    </div>

                    <!-- Manual Fields -->
                    <div class="bg-gray-900/50 border border-gray-700 rounded-lg p-3">
                        <h3 class="text-sm font-bold text-yellow-400 mb-2">‚úèÔ∏è Manual Entry / Override</h3>
                        <div class="grid grid-cols-2 gap-2 text-xs">
                            <div>
                                <label class="text-gray-500">Proposal ID</label>
                                <input type="text" id="manual-id" class="w-full px-2 py-1 rounded" placeholder="e.g. A21" onchange="updateManualField('id', this.value)">
                            </div>
                            <div>
                                <label class="text-gray-500">Status</label>
                                <select id="manual-status" class="w-full px-2 py-1 rounded bg-gray-800 border border-gray-600" onchange="updateManualField('status', this.value)">
                                    <option value="">Auto-detect</option>
                                    <option value="Executed">Executed</option>
                                    <option value="Passed">Passed</option>
                                    <option value="Rejected">Rejected</option>
                                    <option value="Vetoed">Vetoed</option>
                                    <option value="Open">Open</option>
                                </select>
                            </div>
                            <div class="col-span-2">
                                <label class="text-gray-500">TX Hash <span class="text-gray-600 text-[9px]">(or paste Chainscope URL)</span></label>
                                <input type="text" id="manual-txhash" class="w-full px-2 py-1 rounded font-mono text-xs" placeholder="Paste TX hash or Chainscope URL" onchange="parseTxHashInput(this.value)">
                            </div>
                            <div class="col-span-2">
                                <label class="text-gray-500">Timestamp</label>
                                <input type="text" id="manual-timestamp" class="w-full px-2 py-1 rounded" placeholder="e.g. 2025-08-01T04:21:42Z" onchange="updateManualField('timestamp', this.value)">
                            </div>
                            <div>
                                <label class="text-gray-500">Block Height</label>
                                <input type="text" id="manual-block" class="w-full px-2 py-1 rounded" placeholder="e.g. 16754086" onchange="updateManualField('blockHeight', this.value)">
                            </div>
                            <div>
                                <label class="text-gray-500">Epoch</label>
                                <input type="text" id="manual-epoch" class="w-full px-2 py-1 rounded" placeholder="Auto-calculated" onchange="updateManualField('epoch', this.value)">
                            </div>
                        </div>
                        <button onclick="applyManualOverrides()" class="w-full text-xs bg-yellow-700 hover:bg-yellow-600 px-3 py-1.5 rounded mt-2">
                            ‚úÖ Apply Overrides & Refresh Preview
                        </button>
                    </div>
                </div>

                <!-- Preview Section -->
                <div class="bg-gray-900/50 border border-gray-700 rounded-lg p-3">
                    <h3 class="text-sm font-bold text-green-400 mb-2">üëÅÔ∏è Parsed Preview</h3>
                    <div id="parse-preview" class="text-xs overflow-y-auto max-h-[600px] scrollbar-thin">
                        <div class="text-gray-500 text-center py-8">
                            Paste a DAODAO proposal page and click "Parse" to preview
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Proposals Tab -->
        <div id="content-proposals" class="tab-content hidden">
            <div class="flex justify-between items-center mb-4">
                <div class="flex gap-2">
                    <select id="filter-status" class="text-xs bg-gray-800 border border-gray-600 rounded px-2 py-1" onchange="filterProposals()">
                        <option value="">All Status</option>
                        <option value="Executed">Executed</option>
                        <option value="Passed">Passed</option>
                        <option value="Rejected">Rejected</option>
                        <option value="Vetoed">Vetoed</option>
                    </select>
                    <select id="filter-year" class="text-xs bg-gray-800 border border-gray-600 rounded px-2 py-1" onchange="filterProposals()">
                        <option value="">All Years</option>
                        <option value="2025">2025</option>
                        <option value="2024">2024</option>
                    </select>
                    <select id="filter-verified" class="text-xs bg-gray-800 border border-gray-600 rounded px-2 py-1" onchange="filterProposals()">
                        <option value="">All Verification</option>
                        <option value="verified">‚úÖ Verified</option>
                        <option value="partial">‚ö†Ô∏è Partial</option>
                        <option value="failed">‚ùå Failed</option>
                        <option value="none">No Raw Data</option>
                    </select>
                </div>
                <button onclick="importProposals()" class="text-xs bg-blue-600 hover:bg-blue-500 px-3 py-1 rounded">
                    üì• Import JSON
                </button>
            </div>
            <div id="proposals-list" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3">
                <div class="text-gray-500 text-center py-8 col-span-full">No proposals saved yet</div>
            </div>
        </div>

        <!-- Members Tab -->
        <div id="content-members" class="tab-content hidden">
            <div class="flex justify-between items-center mb-4">
                <div class="text-sm text-gray-400">
                    <span id="members-loaded">0</span> members loaded
                </div>
                <div class="flex gap-2">
                    <button onclick="loadMembersFromGitHub()" class="text-xs bg-blue-600 hover:bg-blue-500 px-3 py-1 rounded">
                        üîÑ Reload from GitHub
                    </button>
                    <button onclick="snapshotMembers()" class="text-xs bg-purple-600 hover:bg-purple-500 px-3 py-1 rounded">
                        üì∏ Save Snapshot
                    </button>
                </div>
            </div>
            <div id="members-list" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-2 max-h-[600px] overflow-y-auto scrollbar-thin">
            </div>
        </div>

        <!-- Registry Tab -->
        <div id="content-registry" class="tab-content hidden">
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-4">
                <div class="bg-gray-900/50 border border-gray-700 rounded-lg p-3">
                    <h3 class="text-sm font-bold text-blue-400 mb-2">üìú Known Contracts (<span id="contract-count">0</span>)</h3>
                    <div id="contracts-list" class="max-h-80 overflow-y-auto scrollbar-thin text-xs space-y-1">
                    </div>
                </div>
                <div class="bg-gray-900/50 border border-gray-700 rounded-lg p-3">
                    <h3 class="text-sm font-bold text-green-400 mb-2">‚ö° Known Actions (<span id="action-count">0</span>)</h3>
                    <div id="actions-list" class="max-h-80 overflow-y-auto scrollbar-thin text-xs space-y-1">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Import File Input (hidden) -->
    <input type="file" id="import-file" class="hidden" accept=".json" onchange="handleImport(event)">

    <script>
    // ========================================
    // DATA STORE
    // ========================================
    const store = {
        dao: {
            id: 'alliance_dao',
            name: 'AllianceDAO',
            address: 'terra1csp8gsjk2yyxzqewza6lkjvwkspn7zs2jvamk9uf05crtcakf6gszk2g8y',
            membersUrl: 'https://raw.githubusercontent.com/defipatriot/adao_json_storage/main/members.csv'
        },
        members: {},
        proposals: {},
        currentParsed: null
    };

    // ========================================
    // CONTRACT REGISTRY
    // ========================================
    const contractRegistry = {
        // ===== DAO Contracts =====
        'terra1csp8gsjk2yyxzqewza6lkjvwkspn7zs2jvamk9uf05crtcakf6gszk2g8y': { name: 'AllianceDAO', type: 'dao' },
        'terra1va3tny5252fca04wqzf7gqh5naa8599nzxqq2vptycgv077zhmjqetanj2': { name: 'AllianceDAO Proposal Module', type: 'dao' },
        'terra1sffd4efk2jpdt894r04qwmtjqrrjfc52tmj6vkzjxqhd8qqu2drs3m5vzm': { name: 'AllianceDAO Treasury', type: 'treasury' },
        'terra1yqv0af22675wlcmgflxk4ve07vt8qlm999gk0cuw5l64r5xxgadsyg8ywv': { name: 'AllianceDAO Vetoer', type: 'dao' },
        
        // ===== TLA / Eris Protocol =====
        'terra1hfksrhchkmsj4qdq33wkksrslnfles6y2l77fmmzeep0xmq24l2smsd3lj': { name: 'Eris/TLA Hub', type: 'staking' },
        'terra1kye343r8hl7wm6f3uzynyyzl2zmcm2sqmvvzwzj7et2j5jj7rjkqa2ue88': { name: 'Eris ampLUNA Hub', type: 'staking' },
        'terra10788fkzah89xrdm27zkj5yvhj9x3494lxawzm5qq3vvxcqz2yzaqyd3enk': { name: 'Eris arbLUNA Hub', type: 'staking' },
        'terra1v3h5lejqer5qnjnj6gds94u55x0qsxq7cpxs2kf7kqu6drwgmz4qd9qav9': { name: 'Eris Amp Gauges', type: 'governance' },
        'terra1uqhj8agyeaz8fu6mdggfuwr3lp32jlrx5hqag4jxexde92rzkamq3l62zg': { name: 'arbLUNA Staking', type: 'staking' },
        'terra1qdjsxsv96aagrdxz83gwtjk8qvf2mrg4y8y3dqjxg556lm79pg5qdgmaxl': { name: 'Eris LP Zapper', type: 'dex' },
        'terra1zly98gvcec54m3caxlqexce7rus6rzgplz7eketsdz7nh750h2rqvu8uzx': { name: 'Eris Compounder', type: 'staking' },
        // NEW: Verified TLA Contracts
        'terra1tuuwm8yrj54qeg0c8xu00aha9ryatyhtczq8qq2q8tntuw0auzas9037wh': { name: 'TLA Bribe Manager', type: 'rewards', version: '1.8.1' },
        'terra1awq6t7jfakg9wfjn40fk3wzwmd57mvrqtt3a39z9rmet7wdjj3ysgw3lpa': { name: 'TLA Asset Staking (Primary)', type: 'staking', version: '1.8.2' },
        'terra1qdz5qgafx88kp5mf6m2tah8742g4u5g2cek0m3jrgssexexk7g4qw6e23k': { name: 'TLA Asset Staking (Secondary)', type: 'staking', version: '1.8.2' },
        'terra1x8v9fujf3c78q2we23x0vgzmxgtt0hgvuvfsxy4w3ar9kcua4c6qqcnhyh': { name: 'TLA Connector Alliance (Primary)', type: 'staking', version: '1.0.0' },
        'terra1u72y7gppxrsncctvgfyqduv3md6pgq77pqhz9rxgwl3dqgye00cq7vmf8u': { name: 'TLA Connector Alliance (Secondary)', type: 'staking', version: '1.0.0' },
        
        // ===== Tokens =====
        'terra1lxx40s29qvkrcj8fsa3yzyehy7w50umdvvnls2r830rys6lu2zns63eelv': { name: 'ROAR Token', type: 'token' },
        'terra1se7rvuerys4kd2snt6vqswh9wugu49vhyzls8ymc02wl37g2p2ms5yz490': { name: 'arbLUNA Token', type: 'token' },
        'terra1ecgazyd0waaj3g7l9cmy5gulhxkps2gmxu9ghducvuypjq68mq2s5lvsct': { name: 'ampLUNA Token', type: 'token' },
        'terra1r9gls56glvuc4jedsvc3uwh6vj95mqm9efc7hnweqxa2nlme5cyqxygy5m': { name: 'ampROAR Token', type: 'token' },
        
        // ===== Lion DAO =====
        'terra1xuqh84yz35h70p3ppt76dz5kgwwtwmsv34pg0gw6ld4ntptgjcrqe2e70t': { name: 'Lion DAO ROAR Staking', type: 'staking' },
        'terravaloper1pet430t7ykswxuyhh56d4gk6rt7qgu9as6a5r0': { name: 'Lion DAO Validator', type: 'validator' },
        
        // ===== pixeLions =====
        'terra104dty6zwfvg6090fwfcy07l43s299wrfsx07mzphu4z5klyh4stqnj7pst': { name: 'pixeLions NFT Collection', type: 'nft' },
        'terra17z7fpaa8kah698xn5tarrcucvualdy4wsztkfc404g3garucpu6qmxp50g': { name: 'pixeLions NFT Collection', type: 'nft' },
        'terra127dehd2d6t7ynnezkxkre2w83ze0t7lmghpu6vn4y5mfmwfj5x9qqdh4sz': { name: 'pixeLions Staking', type: 'staking' },
        
        // ===== Token Swap =====
        'terra1hzh32nfvzffzapa3xk7y0uqdaxfldjhw5nzthevsef2xwn28jn9qclac98': { name: 'DAODAO Token Swap', type: 'swap' },
        
        // ===== DAODAO Infrastructure =====
        'terra14gv57x9lmuc04jzsmsz5f2heyfxfndey2v8hkkjt7z9p6d7xw35stx69j2': { name: 'DAODAO Rewards Distributor', type: 'dao', version: '2.7.0' },
        'terra1c57ur376szdv8rtes6sa9nst4k536dynunksu8tx5zu4z5u3am6qmvqx47': { name: 'DAODAO NFT Voting Module', type: 'dao', version: '2.5.0' },
        
        // ===== Astroport LP Tokens =====
        'terra1s275y73lfupag0g03nglxaedfnsw5z4m5zc9wk66guy503zuw5ss889tlx': { name: 'LUNA-USDC LP', type: 'lp' },
        'terra14h48hukanmfv6wrrs50m4w2f9hf09lakwl5d5pkpt4rpl3gtg7ks4ye6d4': { name: 'LUNA-USDT LP', type: 'lp' },
        'terra1xkt5etsaptddec6achnjlqnx884fwxwuk795fs885v6eyygu6eus7uauhc': { name: 'EURE-LUNA LP', type: 'lp' },
        'terra1my4tml2ae4zewq0u5fpq2qzq4rdpfh5pq7y3eekxxhwxdwdmce4shw9mt4': { name: 'ampLUNA-LUNA LP', type: 'lp' },
        'terra14lul8rjcad0jeuu680n4q7dwgxjkr6mqzx8umyewj8c6xn93squqllleht': { name: 'ASTRO-LUNA LP', type: 'lp' },
        'terra14arerdfc88cdv6m6frc03a0963z877756kqac4h4xvd9vftn0hqqhquca8': { name: 'LUNA-SOLID LP', type: 'lp' },
        'terra1h3z2zv6aw94fx5263dy6tgz6699kxmewlx3vrcu4jjrudg6xmtyqk6vt0u': { name: 'bLUNA-LUNA LP', type: 'lp' },
        'terra12usr3jlgvuzq70kpt6u03stxrgzwpjxnej6herpuw9t7echj8z3q44dyyk': { name: 'SOLID-USDC LP', type: 'lp' },
        'terra1wwy8xjk4mff7qp2g7qzmgfu9agd6wjdmz99crj94zv9tmh7dvhmq0jsf6a': { name: 'LUNA-SWTH LP', type: 'lp' },
        'terra1vczn40ch624g2kserhzqu2n69j3h7h7c5nfeznw96pnxjuly5h5s25u9dm': { name: 'LUNA-ROAR LP', type: 'lp' },
        'terra1cg9t08mqa88us074mpwpuu8lp5w4jwtye3vaazll45w27at52cpsq7c564': { name: 'CAPA-LUNA LP', type: 'lp' },
        'terra1a5apghncafx0nem740fsrmd6demaywvp332a4uat63u2jtwn8mgsz7khkw': { name: 'LUNA-WBTC.AXL LP', type: 'lp' },
        'terra17thxg96vtxv39kcltc0dvrltqgkumu8fv93rpz3xz98675cgxdjq3y4ddn': { name: 'EURE-USDC LP', type: 'lp' },
        'terra1wdzdltygkgqyuvggnqnxsny9vhfyex92kzaz6zkued2wvp7nvxpsv739js': { name: 'LUNA-WBTC LP', type: 'lp' },
        'terra19xrvvkq5607xudcxvw444yycjz6e3vk3l8p633z68k0vv5q09wnsa9q2qt': { name: 'ATOM-LUNA LP', type: 'lp' },
        'terra19d8tttv0lvhwpj828qqrcmm6yaqdfhrchfheuufcw4kywtmk9u3q98ask3': { name: 'LUNA-WSTETH LP', type: 'lp' },
        'terra1euf8klqukk4wlly90nve0n6drqvq9pst73wc34pruuvx09nptxyse68hgl': { name: 'INJ-LUNA LP', type: 'lp' },
        'terra12mvtdvn4fgtsqs4fwxr56vcwjw0xe23lhdfyjq5ghk7vmfeuxn0srau9q2': { name: 'ATOM-DATOM LP', type: 'lp' },
        'terra18336lhc2vt9s9tw4pqetvdwywg9555rduzv527r9q47smw89epcsxgxuny': { name: 'WETH.AXL-WSTETH LP', type: 'lp' },
        'terra10e2rz5etaped4nh0vk502hf7uwtz5lqvxqatxl4qyr0chcynxf2swhfwww': { name: 'WBTC.AXL-WBTC.OSMO LP', type: 'lp' },
        'terra1huw82c9grj9xz9umkc8hqcjqgndadlkrp8rn9u6eh5jh5j2s2t7qs33vry': { name: 'USDC-USDT LP', type: 'lp' },
        'terra19z7g4fnu529250sdkdmgm9kw4qgwwtwmsv34pg0gw6ld4ntptgjcrqe2e70t': { name: 'arbLUNA-LUNA LP', type: 'lp' },
        
        // ===== Astroport Pools =====
        'terra1h3z2zv6aw94fx5263dy6tgz6699kxmewlx3vrcu4jjrudg6xmtyqk6vt0u': { name: 'Astroport Router', type: 'dex' },
        'terra12usr3jlgvuzq70kpt6u03stxrgzwpjxnej6herpuw9t7echj8z3q44dyyk': { name: 'LUNA-USDC Pool', type: 'pool' },
        'terra1wwy8xjk4mff7qp2g7qzmgfu9agd6wjdmz99crj94zv9tmh7dvhmq0jsf6a': { name: 'ampLUNA-LUNA Pool', type: 'pool' },
        
        // ===== WhiteWhale =====
        'terra1vczn40ch624g2kserhzqu2n69j3h7h7c5nfeznw96pnxjuly5h5s25u9dm': { name: 'WhiteWhale LUNA-bLUNA Pool', type: 'pool' },
        'terra1cg9t08mqa88us074mpwpuu8lp5w4jwtye3vaazll45w27at52cpsq7c564': { name: 'WhiteWhale ROAR Pool', type: 'pool' },
        
        // ===== Votion / PD Bribes =====
        'terra1a5apghncafx0nem740fsrmd6demaywvp332a4uat63u2jtwn8mgsz7khkw': { name: 'Votion Lockup', type: 'staking' },
        'terra17thxg96vtxv39kcltc0dvrltqgkumu8fv93rpz3xz98675cgxdjq3y4ddn': { name: 'PD Bribes', type: 'rewards' },
        
        // ===== CAPA =====
        'terra1wdzdltygkgqyuvggnqnxsny9vhfyex92kzaz6zkued2wvp7nvxpsv739js': { name: 'CAPA Bond', type: 'staking' },
        'terra1t4p3u8khpd7f8qzurwyafxt648dya6mp6vur3vaapswt6m24gkuqrfdhar': { name: 'CAPA Token', type: 'token', version: '1.0.1' },
        
        // ===== Alliance Module =====
        'terra1phr9fngjv7a8an4dhmhd0u0f98wazxfnzccqtyheq4zqrrp4fpuqw3apw9': { name: 'ALLY NFT Contract', type: 'nft', version: '1.1.0' },
        
        // ===== Cross-chain =====
        'terra19xrvvkq5607xudcxvw444yycjz6e3vk3l8p633z68k0vv5q09wnsa9q2qt': { name: 'ICA Controller (Cosmos Hub)', type: 'cross-chain' },
        'terra19d8tttv0lvhwpj828qqrcmm6yaqdfhrchfheuufcw4kywtmk9u3q98ask3': { name: 'ICA Controller (Neutron)', type: 'cross-chain' },
        'terra1eumwktcszm8p5p3apuxq4mrk008rx8sakntq68a5x6l6my33jl2qfvsfge': { name: 'Polytone Note (‚Üí Neutron)', type: 'cross-chain', version: '1.0.0' },
        'terra1r7fej5936y57hzhavw6wt6lld5vq27av3ftl7jjvlgcc4lh0ehrs2n9cvy': { name: 'Polytone Note (‚Üí Cosmos Hub)', type: 'cross-chain', version: '1.0.0' },
        
        // ===== Known Wallets =====
        'terra1hr8zsfpch47qygc96c8e6rzkd2t7mafqx77ulw': { name: 'DeFi_Patriot', type: 'wallet' },
        'terra1vkmpmy3anc7f0h6jqxmdx7hw0a88rswggu02kh': { name: 'Swiftsol', type: 'wallet' }
    };

    // ========================================
    // ACTION REGISTRY
    // ========================================
    const actionRegistry = {
        // ===== TLA / Eris Actions =====
        'claim_rebase': { name: 'Claim Rebase', risk: 'low', category: 'rewards' },
        'claim_rewards': { name: 'Claim Rewards', risk: 'low', category: 'rewards' },
        'claim_bribes': { name: 'Claim Bribes', risk: 'low', category: 'rewards' },
        'extend_lock_amount': { name: 'Extend Lock Amount', risk: 'low', category: 'staking' },
        'extend_lock_time': { name: 'Extend Lock Time', risk: 'low', category: 'staking' },
        'create_lock': { name: 'Create Lock', risk: 'medium', category: 'staking' },
        'create_lp': { name: 'Create LP Position', risk: 'medium', category: 'defi' },
        'withdraw': { name: 'Withdraw', risk: 'medium', category: 'defi' },
        'withdraw_unbonded': { name: 'Withdraw Unbonded', risk: 'low', category: 'staking' },
        'tune_amps': { name: 'Tune Amps (TLA Vote)', risk: 'low', category: 'governance' },
        'tune_vamp': { name: 'Tune VAMP', risk: 'low', category: 'governance' },
        'vote_for_gauge_weights': { name: 'Vote Gauge Weights', risk: 'low', category: 'governance' },
        'cast_votes': { name: 'Cast Votes', risk: 'low', category: 'governance' },
        'vote': { name: 'TLA Gauge Vote', risk: 'low', category: 'governance' },
        
        // ===== Staking Actions =====
        'stake': { name: 'Stake Tokens', risk: 'low', category: 'staking' },
        'unstake': { name: 'Unstake Tokens', risk: 'medium', category: 'staking' },
        'bond': { name: 'Bond Tokens', risk: 'medium', category: 'staking' },
        'unbond': { name: 'Unbond Tokens', risk: 'medium', category: 'staking' },
        
        // ===== Token Actions =====
        'transfer': { name: 'Transfer Tokens', risk: 'medium', category: 'token' },
        'send': { name: 'Send Tokens', risk: 'medium', category: 'token' },
        'send_nft': { name: 'Send NFT', risk: 'medium', category: 'nft' },
        'transfer_nft': { name: 'Transfer NFT', risk: 'medium', category: 'nft' },
        
        // ===== Treasury Actions =====
        'set_item': { name: 'Set Item (Whitelist)', risk: 'low', category: 'treasury' },
        'remove_item': { name: 'Remove Item (Delist)', risk: 'low', category: 'treasury' },
        'fund': { name: 'Fund Contract', risk: 'medium', category: 'treasury' },
        
        // ===== DEX Actions =====
        'swap': { name: 'Token Swap', risk: 'medium', category: 'defi' },
        'provide_liquidity': { name: 'Provide Liquidity', risk: 'medium', category: 'defi' },
        'withdraw_liquidity': { name: 'Withdraw Liquidity', risk: 'medium', category: 'defi' },
        'zap': { name: 'Zap (Single-sided LP)', risk: 'medium', category: 'defi' },
        
        // ===== Governance Actions =====
        'update_config': { name: 'Update Config', risk: 'high', category: 'governance' },
        'update_members': { name: 'Update Members', risk: 'high', category: 'governance' },
        'execute': { name: 'Execute Proposal', risk: 'high', category: 'governance' },
        
        // ===== Votion Actions =====
        'lock': { name: 'Lock Tokens', risk: 'low', category: 'staking' },
        'unlock': { name: 'Unlock Tokens', risk: 'low', category: 'staking' },
        'vote': { name: 'Vote', risk: 'low', category: 'governance' },
        
        // ===== Cross-Chain / Stargate =====
        'MsgDelegate': { name: 'Delegate to Validator', risk: 'low', category: 'staking' },
        'MsgUndelegate': { name: 'Undelegate from Validator', risk: 'medium', category: 'staking' },
        'MsgBeginRedelegate': { name: 'Redelegate', risk: 'low', category: 'staking' },
        'MsgWithdrawDelegatorReward': { name: 'Withdraw Staking Rewards', risk: 'low', category: 'rewards' },
        'MsgInstantiateContract2': { name: 'Instantiate Contract', risk: 'high', category: 'cross-chain' },
        'MsgExecuteContract': { name: 'Execute Contract (IBC)', risk: 'medium', category: 'cross-chain' },
        'MsgRegisterInterchainAccount': { name: 'Register ICA', risk: 'high', category: 'cross-chain' },
        'MsgSendTx': { name: 'Send ICA TX', risk: 'high', category: 'cross-chain' }
    };

    // ========================================
    // INITIALIZATION
    // ========================================
    document.addEventListener('DOMContentLoaded', () => {
        loadFromLocalStorage();
        loadMembersFromGitHub();
        updateUI();
        
        // Setup file upload handlers
        setupFileUpload();
    });

    function setupFileUpload() {
        const dropZone = document.getElementById('json-drop-zone');
        const fileInput = document.getElementById('json-file-input');
        
        if (!dropZone || !fileInput) {
            console.error('File upload elements not found');
            return;
        }
        
        // Click to open file dialog
        dropZone.addEventListener('click', () => {
            fileInput.click();
        });
        
        // File input change
        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                console.log('File selected:', file.name);
                processJsonFile(file);
            }
            event.target.value = ''; // Reset for re-upload
        });
        
        // Drag over
        dropZone.addEventListener('dragover', (event) => {
            event.preventDefault();
            event.stopPropagation();
            dropZone.classList.add('border-orange-500', 'bg-orange-900/20');
        });
        
        // Drag leave
        dropZone.addEventListener('dragleave', (event) => {
            event.preventDefault();
            event.stopPropagation();
            dropZone.classList.remove('border-orange-500', 'bg-orange-900/20');
        });
        
        // Drop
        dropZone.addEventListener('drop', (event) => {
            event.preventDefault();
            event.stopPropagation();
            dropZone.classList.remove('border-orange-500', 'bg-orange-900/20');
            
            const file = event.dataTransfer?.files[0];
            console.log('File dropped:', file?.name);
            
            if (file && file.name.endsWith('.json')) {
                processJsonFile(file);
            } else if (file) {
                alert('Please drop a JSON file. Got: ' + file.name);
            } else {
                alert('No file detected in drop');
            }
        });
        
        console.log('‚úÖ File upload handlers initialized');
    }

    function loadFromLocalStorage() {
        try {
            const saved = localStorage.getItem('dao_governance_data');
            if (saved) {
                const data = JSON.parse(saved);
                if (data.proposals) store.proposals = data.proposals;
                if (data.members) store.members = data.members;
            }
        } catch (e) {
            console.error('Failed to load from localStorage:', e);
        }
    }

    function saveToLocalStorage() {
        try {
            localStorage.setItem('dao_governance_data', JSON.stringify({
                proposals: store.proposals,
                members: store.members,
                savedAt: new Date().toISOString()
            }));
        } catch (e) {
            console.error('Failed to save to localStorage:', e);
        }
    }

    function clearAllData() {
        if (!confirm('‚ö†Ô∏è Clear ALL cached data?\n\nThis will delete:\n‚Ä¢ All saved proposals\n‚Ä¢ All cached members\n‚Ä¢ Current parsed proposal\n\nThis cannot be undone!')) {
            return;
        }
        
        try {
            // Clear localStorage
            localStorage.removeItem('dao_governance_data');
            
            // Reset store
            store.proposals = {};
            store.members = {};
            store.currentParsed = null;
            
            // Clear UI
            document.getElementById('paste-input').value = '';
            document.getElementById('chainscope-input').value = '';
            document.getElementById('manual-id').value = '';
            document.getElementById('manual-hash').value = '';
            document.getElementById('manual-timestamp').value = '';
            document.getElementById('manual-block').value = '';
            document.getElementById('manual-status').value = '';
            
            // Reload members from GitHub
            loadMembersFromGitHub();
            
            // Update UI
            updateUI();
            renderPreview();
            renderProposals();
            
            alert('‚úÖ Cache cleared!\n\nMembers reloaded from GitHub.\nReady for fresh proposal parsing.');
            
            console.log('üóëÔ∏è All cached data cleared');
        } catch (e) {
            console.error('Failed to clear data:', e);
            alert('Error clearing cache: ' + e.message);
        }
    }

    // ========================================
    // MEMBERS LOADING
    // ========================================
    async function loadMembersFromGitHub() {
        try {
            document.getElementById('member-count').textContent = 'Loading members...';
            
            const response = await fetch(store.dao.membersUrl + '?t=' + Date.now());
            if (!response.ok) throw new Error('Failed to fetch members CSV');
            
            const csvText = await response.text();
            const lines = csvText.split('\n').filter(l => l.trim());
            
            // Skip header
            store.members = {};
            for (let i = 1; i < lines.length; i++) {
                const cols = parseCSVLine(lines[i]);
                if (cols.length >= 5 && cols[0].startsWith('terra1')) {
                    store.members[cols[0]] = {
                        address: cols[0],
                        name: cols[1] || null,
                        image: cols[2] || null,
                        staked: parseInt(cols[3]) || 0,
                        vp: parseFloat(cols[4]) || 0
                    };
                }
            }
            
            const count = Object.keys(store.members).length;
            document.getElementById('member-count').textContent = `${count} members`;
            document.getElementById('members-loaded').textContent = count;
            
            saveToLocalStorage();
            renderMembers();
            console.log(`‚úÖ Loaded ${count} members from GitHub`);
            
        } catch (e) {
            console.error('Failed to load members:', e);
            document.getElementById('member-count').textContent = 'Failed to load members';
        }
    }

    function parseCSVLine(line) {
        const result = [];
        let current = '';
        let inQuotes = false;
        
        for (let i = 0; i < line.length; i++) {
            const char = line[i];
            if (char === '"') {
                inQuotes = !inQuotes;
            } else if (char === ',' && !inQuotes) {
                result.push(current.trim());
                current = '';
            } else {
                current += char;
            }
        }
        result.push(current.trim());
        return result;
    }

    // ========================================
    // CHAINSCOPE PARSER
    // ========================================
    function parseChainscope() {
        const text = document.getElementById('chainscope-paste').value;
        if (!text.trim()) {
            alert('Please paste Chainscope TX page content');
            return;
        }

        // Extract TX Hash
        const hashMatch = text.match(/HASH\s*\n?\s*([A-F0-9]{64})/i) || 
                          text.match(/([A-F0-9]{64})/);
        if (hashMatch) {
            document.getElementById('manual-txhash').value = hashMatch[1];
        }

        // Extract Timestamp - format: 2025.08.01 04:21:42Z
        const timestampMatch = text.match(/TIMESTAMP\s*\n?\s*(\d{4}\.\d{2}\.\d{2}\s+\d{2}:\d{2}:\d{2}Z?)/i);
        if (timestampMatch) {
            // Convert to DAODAO format: MM/DD/YYYY, HH:MM AM/PM UTC
            const ts = timestampMatch[1];
            const [datePart, timePart] = ts.split(/\s+/);
            const [year, month, day] = datePart.split('.');
            document.getElementById('manual-timestamp').value = ts;
            
            // Also update the parsed proposal if we have one
            if (store.currentParsed) {
                store.currentParsed.timestamp = ts;
                store.currentParsed.txHash = hashMatch ? hashMatch[1] : store.currentParsed.txHash;
            }
        }

        // Extract Block Height
        const blockMatch = text.match(/BLOCK\s*\n?\s*(\d+)/i);
        if (blockMatch) {
            document.getElementById('manual-block').value = blockMatch[1];
            if (store.currentParsed) {
                store.currentParsed.blockHeight = parseInt(blockMatch[1]);
            }
        }

        // Clear the paste area
        document.getElementById('chainscope-paste').value = '';
        
        // Re-render preview if we have a parsed proposal
        if (store.currentParsed) {
            renderPreview();
        }

        alert('‚úÖ TX data extracted! Check the manual fields.');
    }

    // ========================================
    // PROPOSAL PARSING
    // ========================================
    function parseProposal() {
        const text = document.getElementById('proposal-paste').value;
        if (!text.trim()) {
            alert('Please paste a DAODAO proposal page');
            return;
        }

        const prop = {
            id: null,
            title: null,
            description: null,
            status: null,
            creator: null,
            creatorName: null,
            timestamp: null,
            txHash: null,
            txExplorerUrl: null,
            blockHeight: null,
            year: null,
            turnout: null,
            quorum: null,
            threshold: null,
            vetoer: null,
            votes: { yes: 0, no: 0, abstain: 0 },
            voters: [],
            daodaoActions: [],
            rawData: null,
            decodedRawActions: null,
            crossCheck: null,
            unknownAddresses: []
        };

        // Parse ID
        const idMatch = text.match(/Proposal\s+(A?\d+)/i);
        if (idMatch) prop.id = idMatch[1];

        // Use manual ID if provided
        const manualId = document.getElementById('manual-id').value.trim();
        if (manualId) prop.id = manualId;

        // Parse Status
        const statusMatch = text.match(/Status\s*\n?\s*(Executed|Passed|Rejected|Vetoed|Open)/i);
        if (statusMatch) prop.status = statusMatch[1];

        // Use manual status if provided
        const manualStatus = document.getElementById('manual-status').value;
        if (manualStatus) prop.status = manualStatus;

        // Parse Vetoer
        if (prop.status === 'Vetoed') {
            const vetoerMatch = text.match(/Vetoed by\s+([^\n]+)/i);
            if (vetoerMatch) prop.vetoer = vetoerMatch[1].trim();
        }

        // Parse Year/Date
        const dateMatch = text.match(/(January|February|March|April|May|June|July|August|September|October|November|December)\s+(\d{4})/i);
        if (dateMatch) {
            prop.year = parseInt(dateMatch[2]);
            prop.completedDate = `${dateMatch[1]} ${dateMatch[2]}`;
        }

        // Parse TX Hash
        const txMatch = text.match(/TX\s*\n?\s*([A-F0-9]{64})/i);
        if (txMatch) {
            prop.txHash = txMatch[1];
            prop.txExplorerUrl = `https://chainsco.pe/terra2/tx/${txMatch[1]}`;
        }

        // Use manual TX hash if provided
        const manualTxHash = document.getElementById('manual-txhash').value.trim();
        if (manualTxHash) {
            prop.txHash = manualTxHash;
            prop.txExplorerUrl = `https://chainsco.pe/terra2/tx/${manualTxHash}`;
        }

        // Use manual timestamp if provided
        const manualTimestamp = document.getElementById('manual-timestamp').value.trim();
        if (manualTimestamp) prop.timestamp = manualTimestamp;

        // Use manual block if provided
        const manualBlock = document.getElementById('manual-block').value.trim();
        if (manualBlock) prop.blockHeight = parseInt(manualBlock);

        // Parse Title
        const titleMatch = text.match(/Proposal\s+A?\d+\s*\n?\s*AllianceDAO\s*\n?\s*\/\s*\n?\s*Proposal\s+A?\d+\s*\n?\s*(?:Log in\s*\n?\s*)?(?:Status\s*\n?[\s\S]*?(?:Executed|Passed|Rejected|Vetoed|Open)[\s\S]*?(?:TX[\s\S]*?[A-F0-9]{64}\s*\n?\s*)?)?([^\n]+)/i);
        if (titleMatch) prop.title = titleMatch[1].trim();

        // Alternative title extraction
        if (!prop.title) {
            const altTitleMatch = text.match(/(?:Log in|Open)\s*\n?\s*Status[\s\S]*?(?:Executed|Passed|Rejected|Vetoed)[\s\S]*?\n([^\n]+?)(?:\n|DeFi_Patriot|Crypto007)/i);
            if (altTitleMatch) prop.title = altTitleMatch[1].trim();
        }

        // Parse Turnout
        const turnoutMatch = text.match(/([\d.]+)%\s*turnout/i);
        if (turnoutMatch) prop.turnout = parseFloat(turnoutMatch[1]);

        // Parse Quorum
        const quorumMatch = text.match(/Quorum\s*\n?\s*([\d.]+)%/i);
        if (quorumMatch) prop.quorum = parseFloat(quorumMatch[1]);

        // Parse Threshold
        const thresholdMatch = text.match(/(?:Majority|Passing threshold)\s*\(?>?\s*([\d.]+)%?\)/i);
        if (thresholdMatch) prop.threshold = parseFloat(thresholdMatch[1]);

        // Parse Vote Percentages
        const yesMatch = text.match(/([\d.]+)%\s*Yes/i);
        const noMatch = text.match(/([\d.]+)%\s*No/i);
        const abstainMatch = text.match(/([\d.]+)%\s*Abstain/i);
        if (yesMatch) prop.votes.yes = parseFloat(yesMatch[1]);
        if (noMatch) prop.votes.no = parseFloat(noMatch[1]);
        if (abstainMatch) prop.votes.abstain = parseFloat(abstainMatch[1]);

        // Parse Creator
        const creatorMatch = text.match(/Creator\s*\n?\s*([^\n]+)/i);
        if (creatorMatch) {
            const creator = creatorMatch[1].trim();
            const resolved = resolveAddress(creator);
            prop.creator = resolved.address;
            prop.creatorName = resolved.name;
            if (resolved.unknown) {
                prop.unknownAddresses.push({ role: 'creator', truncated: creator });
            }
        }

        // Parse Voters
        const votersSection = text.match(/Votes cast[\s\S]*?Download voting data[\s\S]*?((?:(?:\d+\s*(?:weeks?|days?|hours?|minutes?)\s*ago|When)[\s\S]*?)+)/i);
        if (votersSection) {
            const voterPattern = /(\d+\s*(?:weeks?|days?|hours?|minutes?)\s*ago|When)\s*\n?\s*([^\n]+)\s*\n?\s*(Yes|No|Abstain)\s*\n?\s*([\d.]+)%/gi;
            let voterMatch;
            while ((voterMatch = voterPattern.exec(votersSection[1])) !== null) {
                const voterName = voterMatch[2].trim();
                const resolved = resolveAddress(voterName);
                prop.voters.push({
                    address: resolved.address,
                    name: resolved.name,
                    vote: voterMatch[3],
                    vp: parseFloat(voterMatch[4]),
                    unknown: resolved.unknown
                });
                if (resolved.unknown) {
                    prop.unknownAddresses.push({ 
                        role: 'voter', 
                        truncated: voterName, 
                        vote: voterMatch[3], 
                        vp: parseFloat(voterMatch[4]) 
                    });
                }
            }
        }

        // Parse DAODAO Actions
        prop.daodaoActions = parseDAODAOActions(text);
        console.log(`üìã Parsed ${prop.daodaoActions.length} DAODAO actions`);

        // Parse Raw Data - try multiple patterns
        let rawDataMatch = text.match(/(?:Show|Hide)\s*raw\s*data\s*\n?\s*```?\s*(\[[\s\S]*?\])\s*```?/i);
        
        // Try without backticks - look for JSON array after "raw data"
        if (!rawDataMatch) {
            rawDataMatch = text.match(/(?:Show|Hide)\s*raw\s*data\s*[\s\S]*?(\[\s*\{[\s\S]*?\}\s*\])/i);
        }
        
        // Try finding any large JSON array with wasm/bank/stargate
        if (!rawDataMatch) {
            rawDataMatch = text.match(/(\[\s*\{\s*"(?:wasm|bank|stargate)"[\s\S]*?\}\s*\])/);
        }
        
        // Try with triple backticks
        if (!rawDataMatch) {
            rawDataMatch = text.match(/```\s*(\[[\s\S]*?\])\s*```/);
        }
        
        if (rawDataMatch) {
            try {
                let jsonStr = rawDataMatch[1]
                    .replace(/\u00A0/g, ' ')
                    .replace(/[\u200B-\u200D\uFEFF]/g, '')
                    .trim();
                prop.rawData = JSON.parse(jsonStr);
                console.log(`üì¶ Raw data captured: ${prop.rawData.length} actions`);
            } catch (e) {
                console.error('Failed to parse raw data:', e);
                console.log('Raw match found but failed to parse. First 200 chars:', rawDataMatch[1]?.slice(0, 200));
                
                // Try to recover truncated JSON
                let jsonStr = rawDataMatch[1]
                    .replace(/\u00A0/g, ' ')
                    .replace(/[\u200B-\u200D\uFEFF]/g, '')
                    .trim();
                
                // Find where the valid JSON objects are
                const recovered = tryRecoverJSON(jsonStr);
                if (recovered && recovered.length > 0) {
                    prop.rawData = recovered;
                    console.log(`üì¶ Recovered ${recovered.length} actions from truncated JSON`);
                }
            }
        } else {
            console.log('‚ÑπÔ∏è No raw data found in paste');
        }
        
        // Finish parsing - decode, cross-check, and render
        parseProposalFinish(prop);
    }
    
    // Try to recover valid JSON objects from potentially truncated array
    function tryRecoverJSON(jsonStr) {
        const actions = [];
        
        // Try to find complete JSON objects within the array
        // Look for patterns like {"wasm":{...}} or {"bank":{...}} or {"stargate":{...}}
        let depth = 0;
        let currentObj = '';
        let inString = false;
        let escapeNext = false;
        
        for (let i = 0; i < jsonStr.length; i++) {
            const char = jsonStr[i];
            
            if (escapeNext) {
                currentObj += char;
                escapeNext = false;
                continue;
            }
            
            if (char === '\\' && inString) {
                currentObj += char;
                escapeNext = true;
                continue;
            }
            
            if (char === '"' && !escapeNext) {
                inString = !inString;
            }
            
            if (!inString) {
                if (char === '{') {
                    if (depth === 0) {
                        currentObj = '';
                    }
                    depth++;
                } else if (char === '}') {
                    depth--;
                    if (depth === 0) {
                        currentObj += char;
                        try {
                            const parsed = JSON.parse(currentObj);
                            if (parsed.wasm || parsed.bank || parsed.stargate) {
                                actions.push(parsed);
                            }
                        } catch (e) {
                            // Skip invalid object
                        }
                        currentObj = '';
                        continue;
                    }
                }
            }
            
            if (depth > 0) {
                currentObj += char;
            }
        }
        
        return actions.length > 0 ? actions : null;
    }

    function parseProposalFinish(prop) {
        // Decode raw actions
        if (prop.rawData) {
            prop.decodedRawActions = decodeRawActions(prop.rawData);
        }

        // Cross-check
        if (prop.daodaoActions.length > 0 && prop.decodedRawActions) {
            prop.crossCheck = performCrossCheck(prop);
        }

        store.currentParsed = prop;
        renderPreview();
    }

    // ========================================
    // DAODAO ACTIONS PARSER
    // ========================================
    function parseDAODAOActions(text) {
        const actions = [];

        // Parse Spend actions
        const spendPattern = /üíµ\s*Spend\s*\n?\s*([\d,\.]+)\s*\$?(\w+)\s*\n?\s*([^\n‚öîÔ∏èüíµüì•‚ÑπÔ∏èüîò‚õìÔ∏è]+)/gi;
        let match;
        while ((match = spendPattern.exec(text)) !== null) {
            actions.push({
                type: 'Spend',
                icon: 'üíµ',
                amount: parseFloat(match[1].replace(/,/g, '')),
                token: match[2],
                recipient: match[3].trim(),
                display: `Spend ${match[1]} ${match[2]} ‚Üí ${match[3].trim()}`
            });
        }

        // Parse Execute Smart Contract actions
        const execBlocks = text.split(/‚öîÔ∏è\s*Execute Smart Contract/i);
        for (let i = 1; i < execBlocks.length; i++) {
            const block = execBlocks[i].split(/(?=‚öîÔ∏è|üíµ|üì•|‚ÑπÔ∏è|üîò|‚õìÔ∏è|Hide raw data|Show raw data|Ratio of votes)/i)[0];
            const action = {
                type: 'Execute Smart Contract',
                icon: '‚öîÔ∏è',
                messageKey: null,
                fundsAmount: null,
                fundsToken: null,
                funds: null
            };

            // Extract message key
            const msgSection = block.match(/Message[\s\S]*?(?=Funds|json is valid)/i);
            if (msgSection) {
                const keyMatch = msgSection[0].match(/"(\w+)"\s*:\s*[\{\[]/);
                if (keyMatch) action.messageKey = keyMatch[1];
            }

            // Extract funds
            const fundsMatch = block.match(/Funds\s*\n?\s*([\d,\.]+)\s*\$?(\w+)/i);
            if (fundsMatch) {
                action.fundsAmount = parseFloat(fundsMatch[1].replace(/,/g, ''));
                action.fundsToken = fundsMatch[2];
                action.funds = `${fundsMatch[1]} ${fundsMatch[2]}`;
            } else if (block.match(/Funds\s*\n?\s*None/i)) {
                action.funds = 'None';
            }

            action.display = `Execute: ${action.messageKey || 'unknown'}` +
                (action.funds && action.funds !== 'None' ? ` (${action.funds})` : '');

            if (action.messageKey) {
                actions.push(action);
            }
        }

        // Parse Manage Staking actions
        const stakingBlocks = text.split(/üì•\s*Manage Staking/i);
        for (let i = 1; i < stakingBlocks.length; i++) {
            const block = stakingBlocks[i].split(/(?=‚öîÔ∏è|üíµ|üì•|‚ÑπÔ∏è|üîò|‚õìÔ∏è)/i)[0];
            const action = { type: 'Manage Staking', icon: 'üì•', subType: null };

            if (block.includes('Claim Rewards')) action.subType = 'Claim Rewards';
            else if (block.includes('Delegate')) action.subType = 'Delegate';
            else if (block.includes('Undelegate')) action.subType = 'Undelegate';

            action.display = `Staking: ${action.subType || 'unknown'}`;
            actions.push(action);
        }

        // Parse Manage Treasury actions
        const treasuryBlocks = text.split(/üîò\s*Manage Treasury/i);
        for (let i = 1; i < treasuryBlocks.length; i++) {
            const block = treasuryBlocks[i].split(/(?=‚öîÔ∏è|üíµ|üì•|‚ÑπÔ∏è|üîò|‚õìÔ∏è)/i)[0];
            const action = { type: 'Manage Treasury', icon: 'üîò', subType: null };

            if (block.includes('Display Token')) action.subType = 'Display Token';
            else if (block.includes('Add token')) action.subType = 'Add Token';

            action.display = `Treasury: ${action.subType || 'unknown'}`;
            actions.push(action);
        }

        // Parse Transfer NFT(s) actions - üì¶
        const nftTransferBlocks = text.split(/üì¶\s*Transfer NFT/i);
        for (let i = 1; i < nftTransferBlocks.length; i++) {
            const block = nftTransferBlocks[i].split(/(?=‚öîÔ∏è|üíµ|üì•|‚ÑπÔ∏è|üîò|üñº|ü§ù|‚õìÔ∏è|Hide raw data|Show raw data|Ratio of votes)/i)[0];
            const action = { 
                type: 'Transfer NFT', 
                icon: 'üì¶', 
                nftCount: 0,
                recipient: null,
                hasCallback: false,
                callbackAction: null
            };

            // Count NFTs
            const nftCountMatch = block.match(/(\d+)\s*NFTs?/i);
            if (nftCountMatch) action.nftCount = parseInt(nftCountMatch[1]);

            // Check for execute smart contract callback
            if (block.includes('Execute smart contract')) {
                action.hasCallback = true;
                const msgMatch = block.match(/"(\w+)"\s*:\s*\{/);
                if (msgMatch) action.callbackAction = msgMatch[1];
            }

            // Get recipient
            const recipientMatch = block.match(/Recipient\s*\n?\s*(terra1[a-z0-9\.]+)/i);
            if (recipientMatch) action.recipient = recipientMatch[1];

            action.display = `Transfer ${action.nftCount} NFTs` + 
                (action.callbackAction ? ` ‚Üí ${action.callbackAction}` : '') +
                (action.recipient ? ` to ${action.recipient.slice(0, 10)}...` : '');

            if (action.nftCount > 0) {
                actions.push(action);
            }
        }

        // Parse Manage Treasury NFTs - üñº
        const nftTreasuryBlocks = text.split(/üñº\s*Manage Treasury NFTs?/i);
        for (let i = 1; i < nftTreasuryBlocks.length; i++) {
            const block = nftTreasuryBlocks[i].split(/(?=‚öîÔ∏è|üíµ|üì•|‚ÑπÔ∏è|üîò|üñº|ü§ù|üì¶|‚õìÔ∏è|Hide raw data|Show raw data|Ratio of votes)/i)[0];
            const action = { type: 'Manage Treasury NFTs', icon: 'üñº', subType: null, collection: null };

            if (block.includes('Display NFT')) action.subType = 'Display NFT Collection';
            
            // Get collection name
            const nameMatch = block.match(/"name"\s*:\s*"([^"]+)"/);
            if (nameMatch) action.collection = nameMatch[1];

            action.display = `Treasury NFT: ${action.subType || 'Display'}` +
                (action.collection ? ` (${action.collection})` : '');
            
            actions.push(action);
        }

        // Parse Token Swap - ü§ù
        const swapBlocks = text.split(/ü§ù\s*Token Swap/i);
        for (let i = 1; i < swapBlocks.length; i++) {
            const block = swapBlocks[i].split(/(?=‚öîÔ∏è|üíµ|üì•|‚ÑπÔ∏è|üîò|üñº|ü§ù|üì¶|‚õìÔ∏è|Hide raw data|Show raw data|Ratio of votes)/i)[0];
            const action = { type: 'Token Swap', icon: 'ü§ù', fromAmount: null, fromToken: null, toAmount: null, toToken: null };

            // Parse amounts - look for patterns like "4.50K $LUNA" or "1.50B $ROAR"
            const amountPattern = /([\d.]+)([KMB]?)\s*\$?(\w+)/gi;
            const amounts = [];
            let amountMatch;
            while ((amountMatch = amountPattern.exec(block)) !== null) {
                let value = parseFloat(amountMatch[1]);
                const multiplier = amountMatch[2].toUpperCase();
                if (multiplier === 'K') value *= 1000;
                else if (multiplier === 'M') value *= 1000000;
                else if (multiplier === 'B') value *= 1000000000;
                amounts.push({ value, token: amountMatch[3] });
            }

            if (amounts.length >= 2) {
                action.fromAmount = amounts[0].value;
                action.fromToken = amounts[0].token;
                action.toAmount = amounts[1].value;
                action.toToken = amounts[1].token;
            }

            action.display = `Token Swap: ${action.fromAmount?.toLocaleString() || '?'} ${action.fromToken || '?'} ‚Üî ${action.toAmount?.toLocaleString() || '?'} ${action.toToken || '?'}`;
            
            actions.push(action);
        }

        return actions;
    }

    // ========================================
    // RAW DATA DECODER
    // ========================================
    function decodeRawActions(rawData) {
        return rawData.map((action, idx) => {
            const decoded = {
                index: idx + 1,
                type: null,
                contract: null,
                contractName: null,
                action: null,
                actionName: null,
                funds: null,
                params: null,
                decodedMsg: null
            };

            if (action.wasm?.execute) {
                decoded.type = 'wasm';
                decoded.contract = action.wasm.execute.contract_addr;
                decoded.contractName = contractRegistry[decoded.contract]?.name || '‚ùì Unknown';

                // Handle base64 encoded msg (from JSON export) or direct object (from page paste)
                let msg = action.wasm.execute.msg;
                if (typeof msg === 'string') {
                    // Base64 encoded
                    try {
                        const decodedStr = atob(msg);
                        msg = JSON.parse(decodedStr);
                        decoded.decodedMsg = msg;
                    } catch (e) {
                        console.warn('Failed to decode base64 msg:', e);
                        msg = {};
                    }
                }
                
                decoded.action = Object.keys(msg)[0];
                decoded.actionName = actionRegistry[decoded.action]?.name || decoded.action;
                decoded.params = msg[decoded.action];

                if (action.wasm.execute.funds?.length > 0) {
                    decoded.funds = action.wasm.execute.funds.map(f => ({
                        amount: parseInt(f.amount) / 1e6,
                        denom: f.denom
                    }));
                }
            } else if (action.bank?.send) {
                decoded.type = 'bank';
                decoded.action = 'send';
                decoded.actionName = 'Bank Send';
                decoded.contract = action.bank.send.to_address;
                decoded.contractName = contractRegistry[decoded.contract]?.name || '‚ùì Unknown';
                
                if (action.bank.send.amount?.length > 0) {
                    decoded.funds = action.bank.send.amount.map(f => ({
                        amount: parseInt(f.amount) / 1e6,
                        denom: f.denom
                    }));
                }
            } else if (action.stargate) {
                decoded.type = 'stargate';
                decoded.action = action.stargate.typeUrl?.split('.').pop();
                decoded.actionName = actionRegistry[decoded.action]?.name || decoded.action;
                if (action.stargate.value?.validatorAddress) {
                    decoded.contract = action.stargate.value.validatorAddress;
                    decoded.contractName = contractRegistry[decoded.contract]?.name || '‚ùì Unknown';
                }
                decoded.params = action.stargate.value;
            }

            return decoded;
        });
    }

    // ========================================
    // CROSS-CHECK SYSTEM
    // ========================================
    function performCrossCheck(prop) {
        const cc = {
            daodaoCount: prop.daodaoActions?.length || 0,
            rawCount: prop.decodedRawActions?.length || 0,
            matches: [],
            mismatches: [],
            warnings: [],
            bulkOps: [],
            verified: false,
            status: 'unknown'
        };

        // Match each DAODAO action to raw
        prop.daodaoActions?.forEach((daodao, i) => {
            const result = {
                daodaoIndex: i + 1,
                daodaoDisplay: daodao.display,
                rawIndex: null,
                rawAction: null,
                status: 'unmatched',
                details: []
            };

            if (daodao.type === 'Execute Smart Contract' && daodao.messageKey) {
                // Try direct match
                let rawMatch = prop.decodedRawActions.find((r, ri) =>
                    r.action === daodao.messageKey && !cc.matches.find(m => m.rawIndex === ri + 1)
                );

                if (rawMatch) {
                    result.rawIndex = prop.decodedRawActions.indexOf(rawMatch) + 1;
                    result.rawAction = rawMatch.action;
                    result.status = 'matched';
                    result.details.push(`‚úÖ Action "${daodao.messageKey}" found`);
                } else {
                    // Try CW20 callback pattern
                    rawMatch = prop.decodedRawActions.find((r, ri) => {
                        if (cc.matches.find(m => m.rawIndex === ri + 1)) return false;
                        if (r.action !== 'send' || !r.params?.msg) return false;
                        try {
                            const decoded = atob(r.params.msg);
                            return decoded.includes(daodao.messageKey);
                        } catch (e) { return false; }
                    });

                    if (rawMatch) {
                        result.rawIndex = prop.decodedRawActions.indexOf(rawMatch) + 1;
                        result.rawAction = `send(${daodao.messageKey})`;
                        result.status = 'matched';
                        result.details.push(`‚úÖ CW20 send ‚Üí ${daodao.messageKey}`);
                    } else {
                        result.status = 'unmatched';
                        result.details.push(`‚ùå Action "${daodao.messageKey}" NOT found`);
                    }
                }
            } else if (daodao.type === 'Spend') {
                // Match to:
                // 1. bank.send (native tokens like LUNA)
                // 2. wasm.transfer (CW20 tokens)
                // 3. wasm.send without callback (CW20 send)
                
                // First try bank.send (native)
                let rawMatch = prop.decodedRawActions.find((r, ri) => {
                    if (cc.matches.find(m => m.rawIndex === ri + 1)) return false;
                    return r.type === 'bank' && r.action === 'send';
                });

                if (rawMatch) {
                    result.rawIndex = prop.decodedRawActions.indexOf(rawMatch) + 1;
                    result.rawAction = 'bank.send';
                    result.status = 'matched';
                    result.details.push(`‚úÖ Spend (native) found as bank.send`);
                } else {
                    // Try CW20 transfer or send (without callback)
                    rawMatch = prop.decodedRawActions.find((r, ri) => {
                        if (cc.matches.find(m => m.rawIndex === ri + 1)) return false;
                        if (r.action === 'transfer') return true;
                        if (r.action === 'send' && !r.params?.msg) return true;
                        return false;
                    });

                    if (rawMatch) {
                        result.rawIndex = prop.decodedRawActions.indexOf(rawMatch) + 1;
                        result.rawAction = `wasm.${rawMatch.action}`;
                        result.status = 'matched';
                        result.details.push(`‚úÖ Spend (CW20) found as ${rawMatch.action}`);
                    }
                }
            } else if (daodao.type === 'Manage Staking') {
                // Manage Staking can be:
                // - MsgDelegate, MsgUndelegate, MsgBeginRedelegate (stargate)
                // - MsgWithdrawDelegatorReward (stargate)
                const rawMatch = prop.decodedRawActions.find((r, ri) => {
                    if (cc.matches.find(m => m.rawIndex === ri + 1)) return false;
                    if (r.type !== 'stargate') return false;
                    
                    // Match based on subType if available
                    if (daodao.subType === 'Claim Rewards') {
                        return r.action?.includes('Withdraw') && r.action?.includes('Reward');
                    } else if (daodao.subType === 'Delegate') {
                        return r.action === 'MsgDelegate';
                    } else if (daodao.subType === 'Undelegate') {
                        return r.action === 'MsgUndelegate';
                    } else if (daodao.subType === 'Redelegate') {
                        return r.action?.includes('Redelegate');
                    }
                    
                    // Generic match for any delegation-related action
                    return r.action?.includes('Delegat') || r.action?.includes('Reward');
                });

                if (rawMatch) {
                    result.rawIndex = prop.decodedRawActions.indexOf(rawMatch) + 1;
                    result.rawAction = rawMatch.action;
                    result.status = 'matched';
                    result.details.push(`‚úÖ Staking action found`);
                }
            } else if (daodao.type === 'Manage Treasury') {
                const rawMatch = prop.decodedRawActions.find((r, ri) => {
                    if (cc.matches.find(m => m.rawIndex === ri + 1)) return false;
                    return r.action === 'set_item';
                });

                if (rawMatch) {
                    result.rawIndex = prop.decodedRawActions.indexOf(rawMatch) + 1;
                    result.rawAction = 'set_item';
                    result.status = 'matched';
                    result.details.push(`‚úÖ Treasury action found`);
                }
            } else if (daodao.type === 'Transfer NFT') {
                // Transfer NFT maps to send_nft actions in raw data
                // Count how many send_nft actions exist
                const sendNftCount = prop.decodedRawActions.filter(r => r.action === 'send_nft').length;
                
                if (sendNftCount > 0 && sendNftCount >= daodao.nftCount) {
                    result.status = 'matched';
                    result.rawAction = `${daodao.nftCount}x send_nft`;
                    result.details.push(`‚úÖ Found ${sendNftCount} send_nft actions for ${daodao.nftCount} NFTs`);
                    
                    // Check callback if present
                    if (daodao.callbackAction) {
                        const hasCallback = prop.decodedRawActions.some(r => 
                            r.action === 'send_nft' && r.params?.msg
                        );
                        if (hasCallback) {
                            result.details.push(`‚úÖ Callback "${daodao.callbackAction}" present in msg`);
                        }
                    }
                } else {
                    result.status = 'unmatched';
                    result.details.push(`‚ùå Expected ${daodao.nftCount} send_nft, found ${sendNftCount}`);
                }
            } else if (daodao.type === 'Manage Treasury NFTs') {
                // Manage Treasury NFTs maps to set_item with cw721 key
                const rawMatch = prop.decodedRawActions.find((r, ri) => {
                    if (cc.matches.find(m => m.rawIndex === ri + 1)) return false;
                    return r.action === 'set_item' && r.params?.key?.includes('cw721');
                });

                if (rawMatch) {
                    result.rawIndex = prop.decodedRawActions.indexOf(rawMatch) + 1;
                    result.rawAction = 'set_item (cw721)';
                    result.status = 'matched';
                    result.details.push(`‚úÖ NFT treasury whitelist found`);
                }
            } else if (daodao.type === 'Token Swap') {
                // Token Swap (OTC deals) maps to fund action with uluna
                // This is an escrow-based OTC system - LUNA goes in, counterparty releases tokens
                const rawMatch = prop.decodedRawActions.find((r, ri) => {
                    if (cc.matches.find(m => m.rawIndex === ri + 1)) return false;
                    return r.action === 'fund' && r.funds?.some(f => f.denom === 'uluna');
                });

                if (rawMatch) {
                    result.rawIndex = prop.decodedRawActions.indexOf(rawMatch) + 1;
                    result.rawAction = 'fund';
                    result.status = 'matched';
                    const lunaAmount = rawMatch.funds?.find(f => f.denom === 'uluna')?.amount;
                    result.details.push(`‚úÖ Token swap fund: ${lunaAmount?.toLocaleString()} LUNA`);
                    result.details.push(`‚ÑπÔ∏è OTC escrow deal - counterparty releases tokens after funding`);
                } else {
                    // For Token Swap, if no fund action found, it's likely truncated
                    // Mark as warning since the UI clearly shows the swap details
                    result.status = 'warning';
                    result.details.push(`‚ö†Ô∏è Fund action not found in recovered raw data`);
                    result.details.push(`‚ÑπÔ∏è Raw data may be truncated (recovered ${prop.decodedRawActions.length} of ~${prop.decodedRawActions.length + 1}+ actions)`);
                    result.details.push(`‚ÑπÔ∏è OTC escrow: ${daodao.fromAmount?.toLocaleString()} ${daodao.fromToken} ‚Üí ${daodao.toAmount?.toLocaleString()} ${daodao.toToken}`);
                }
            } else if (daodao.type === 'Stargate') {
                // Stargate messages are raw Cosmos SDK messages (IBC, staking rewards, etc.)
                // DAODAO shows them as "Stargate:" with the type URL
                const rawMatch = prop.decodedRawActions.find((r, ri) => {
                    if (cc.matches.find(m => m.rawIndex === ri + 1)) return false;
                    return r.type === 'stargate';
                });

                if (rawMatch) {
                    result.rawIndex = prop.decodedRawActions.indexOf(rawMatch) + 1;
                    result.rawAction = rawMatch.action || 'stargate';
                    result.status = 'matched';
                    
                    // Decode the action type for display
                    if (rawMatch.action?.includes('WithdrawDelegatorReward')) {
                        const validator = rawMatch.contract || rawMatch.params?.validatorAddress;
                        const validatorName = contractRegistry[validator]?.name || validator?.slice(0, 20) + '...';
                        result.details.push(`‚úÖ Claim staking rewards from ${validatorName}`);
                    } else if (rawMatch.action?.includes('Delegate')) {
                        result.details.push(`‚úÖ Delegation action: ${rawMatch.action}`);
                    } else if (rawMatch.action?.includes('IBC')) {
                        result.details.push(`‚úÖ IBC cross-chain action: ${rawMatch.action}`);
                    } else {
                        result.details.push(`‚úÖ Stargate action: ${rawMatch.action}`);
                    }
                }
            }

            if (result.status === 'matched') {
                cc.matches.push(result);
            } else if (result.status === 'warning') {
                // Warnings count as matches but with caveats
                cc.matches.push(result);
                cc.warnings.push(`‚ö†Ô∏è ${daodao.display}: possibly truncated data`);
            } else {
                cc.mismatches.push(result);
            }
        });

        // Detect bulk operations
        const actionCounts = {};
        prop.decodedRawActions?.forEach(r => {
            actionCounts[r.action] = (actionCounts[r.action] || 0) + 1;
        });

        const bulkOps = Object.entries(actionCounts)
            .filter(([a, c]) => c >= 3)
            .map(([action, count]) => ({ action, count }));

        if (bulkOps.length > 0 && cc.daodaoCount < cc.rawCount) {
            cc.bulkOps = bulkOps;
            bulkOps.forEach(({ action, count }) => {
                cc.warnings.push(`üì¶ Bulk operation: ${count}x ${action} (collapsed in DAODAO UI)`);
            });
        }

        // Determine status
        const allMatched = cc.mismatches.length === 0;
        const hasBulk = cc.bulkOps.length > 0;

        if (allMatched && cc.warnings.length === 0) {
            cc.verified = true;
            cc.status = 'verified';
        } else if (allMatched && hasBulk) {
            cc.verified = true;
            cc.status = 'verified_bulk';
        } else if (allMatched) {
            cc.verified = true;
            cc.status = 'verified_with_warnings';
        } else {
            cc.verified = false;
            cc.status = cc.daodaoCount === cc.rawCount ? 'partial' : 'failed';
        }

        console.log('üîç Cross-check:', cc.status);
        return cc;
    }

    // ========================================
    // ADDRESS RESOLVER
    // ========================================
    function resolveAddress(input) {
        const result = { address: input, name: null, resolved: false, unknown: false };
        if (!input) return result;

        if (input.startsWith('terra1')) {
            const isTruncated = input.includes('..');

            for (const [addr, member] of Object.entries(store.members)) {
                if (isTruncated) {
                    const prefix = input.split('..')[0];
                    const parts = input.split(/\.\.+/);
                    const suffix = parts.length > 1 ? parts[1] : '';

                    if (addr.startsWith(prefix) && (!suffix || addr.endsWith(suffix))) {
                        result.address = addr;
                        result.name = member.name;
                        result.resolved = true;
                        return result;
                    }
                } else if (addr === input) {
                    result.name = member.name;
                    result.resolved = true;
                    return result;
                }
            }

            if (isTruncated) result.unknown = true;
        } else {
            // It's a username
            result.name = input;
            const member = Object.values(store.members).find(m => m.name === input);
            if (member) {
                result.address = member.address;
                result.resolved = true;
            }
        }

        return result;
    }

    // ========================================
    // RENDER FUNCTIONS
    // ========================================
    function renderPreview() {
        const preview = document.getElementById('parse-preview');
        const prop = store.currentParsed;

        if (!prop) {
            preview.innerHTML = '<div class="text-gray-500 text-center py-8">No proposal parsed</div>';
            return;
        }

        const statusColors = {
            'Executed': 'text-green-400',
            'Passed': 'text-blue-400',
            'Rejected': 'text-red-400',
            'Vetoed': 'text-purple-400',
            'Open': 'text-yellow-400'
        };

        let crossCheckHtml = '';
        if (prop.crossCheck) {
            const cc = prop.crossCheck;
            const statusClass = cc.verified ? 'bg-green-900/30 border-green-500' : 
                               cc.status === 'partial' ? 'bg-yellow-900/30 border-yellow-500' :
                               'bg-red-900/30 border-red-500';
            const statusIcon = cc.verified ? '‚úÖ' : cc.status === 'partial' ? '‚ö†Ô∏è' : '‚ùå';
            const statusText = cc.status === 'verified_bulk' 
                ? `VERIFIED (Bulk: ${cc.bulkOps.map(b => b.count + 'x ' + b.action).join(', ')})`
                : cc.status === 'verified' ? 'VERIFIED - All Actions Match'
                : cc.status === 'verified_with_warnings' ? 'VERIFIED (with warnings)'
                : cc.status === 'partial' ? `PARTIAL - ${cc.mismatches.length} unverified`
                : `MISMATCH - DAODAO: ${cc.daodaoCount} vs Raw: ${cc.rawCount}`;

            crossCheckHtml = `
                <div class="${statusClass} border p-3 rounded mb-2">
                    <div class="font-bold text-sm mb-2">${statusIcon} CROSS-CHECK: ${statusText}</div>
                    <div class="text-gray-400 text-xs mb-2">DAODAO: ${cc.daodaoCount} actions | Raw: ${cc.rawCount} actions</div>
                    
                    <!-- Matched Actions -->
                    ${cc.matches.length > 0 ? `
                    <div class="space-y-1 mb-2">
                        ${cc.matches.map(m => `
                            <div class="bg-green-900/20 border border-green-700/50 rounded p-2">
                                <div class="text-green-400 text-xs font-medium">‚úÖ ${m.daodaoDisplay} ‚Üí ${m.rawAction || 'matched'}</div>
                                ${m.details.map(d => `<div class="text-gray-400 text-[10px] ml-3">${d}</div>`).join('')}
                            </div>
                        `).join('')}
                    </div>
                    ` : ''}
                    
                    <!-- Mismatched Actions -->
                    ${cc.mismatches.length > 0 ? `
                    <div class="space-y-1 mb-2">
                        ${cc.mismatches.map(m => `
                            <div class="bg-red-900/20 border border-red-700/50 rounded p-2">
                                <div class="text-red-400 text-xs font-medium">‚ùå ${m.daodaoDisplay} - NOT VERIFIED</div>
                                ${m.details.map(d => `<div class="text-gray-400 text-[10px] ml-3">${d}</div>`).join('')}
                            </div>
                        `).join('')}
                    </div>
                    ` : ''}
                    
                    <!-- Warnings -->
                    ${cc.warnings.length > 0 ? `
                    <div class="space-y-1">
                        ${cc.warnings.map(w => `<div class="text-yellow-400 text-xs">${w}</div>`).join('')}
                    </div>
                    ` : ''}
                </div>
            `;
        }

        // DAODAO Actions Display
        let daodaoActionsHtml = '';
        if (prop.daodaoActions?.length > 0) {
            daodaoActionsHtml = `
                <div class="bg-yellow-900/20 border border-yellow-700/50 rounded p-2 mb-2">
                    <div class="text-yellow-400 text-xs font-bold mb-1">üìã DAODAO PAGE ACTIONS (${prop.daodaoActions.length})</div>
                    <div class="space-y-1 max-h-32 overflow-y-auto">
                        ${prop.daodaoActions.map((a, i) => `
                            <div class="text-xs flex items-center gap-2">
                                <span class="text-gray-500">#${i + 1}</span>
                                <span class="text-yellow-300">${a.icon || '‚Ä¢'}</span>
                                <span class="text-white">${a.display}</span>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }

        // Raw Data Actions Display
        let rawActionsHtml = '';
        if (prop.decodedRawActions?.length > 0) {
            rawActionsHtml = `
                <div class="bg-blue-900/20 border border-blue-700/50 rounded p-2 mb-2">
                    <div class="text-blue-400 text-xs font-bold mb-1">üîß DECODED RAW ACTIONS (${prop.decodedRawActions.length})</div>
                    <div class="space-y-1 max-h-40 overflow-y-auto">
                        ${prop.decodedRawActions.map((a, i) => `
                            <div class="text-xs">
                                <div class="flex items-center gap-2">
                                    <span class="text-gray-500">#${i + 1}</span>
                                    <span class="text-purple-400">${a.type}.${a.action}</span>
                                    <span class="${a.contractName?.includes('‚ùì') ? 'text-red-400' : 'text-green-400'}">‚Üí ${a.contractName}</span>
                                </div>
                                ${a.funds ? `<div class="text-yellow-400 ml-6 text-[10px]">üí∞ ${a.funds.map(f => f.amount.toLocaleString() + ' ' + (f.denom.includes('/') ? f.denom.split('/').pop() : f.denom)).join(', ')}</div>` : ''}
                                ${a.params?.msg ? `<div class="text-gray-500 ml-6 text-[10px]">üì¶ Has callback msg (base64)</div>` : ''}
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }

        try {

        preview.innerHTML = `
            <div class="space-y-2">
                <div class="grid grid-cols-2 gap-2">
                    <div class="bg-gray-800 p-2 rounded">
                        <div class="text-gray-500 text-[9px]">ID</div>
                        <div class="font-bold">${prop.id || '‚Äî'}</div>
                    </div>
                    <div class="bg-gray-800 p-2 rounded">
                        <div class="text-gray-500 text-[9px]">Status</div>
                        <div class="font-bold ${statusColors[prop.status] || ''}">${prop.status || '‚Äî'}</div>
                    </div>
                </div>

                <div class="bg-gray-800 p-2 rounded">
                    <div class="text-gray-500 text-[9px]">Title</div>
                    <div>${prop.title || '‚Äî'}</div>
                </div>

                <div class="bg-gray-800 p-2 rounded">
                    <div class="text-gray-500 text-[9px]">Creator</div>
                    <div class="text-cyan-400">${prop.creatorName || ''} <span class="text-gray-500 font-mono text-[8px]">${prop.creator || ''}</span></div>
                </div>

                ${prop.txHash ? `
                <div class="bg-gray-800 p-2 rounded">
                    <div class="text-gray-500 text-[9px]">TX Hash (Execution)</div>
                    <a href="${prop.txExplorerUrl}" target="_blank" class="text-purple-400 font-mono text-[9px] hover:underline break-all">${prop.txHash}</a>
                </div>
                ` : ''}

                ${prop.timestamp ? `
                <div class="bg-gray-800 p-2 rounded">
                    <div class="text-gray-500 text-[9px]">Execution Timestamp</div>
                    <div class="text-cyan-400 text-xs">${prop.timestamp}</div>
                </div>
                ` : ''}

                ${prop.blockHeight ? `
                <div class="bg-gray-800 p-2 rounded">
                    <div class="text-gray-500 text-[9px]">Execution Block</div>
                    <div class="text-purple-400 text-xs font-mono">${prop.blockHeight}</div>
                </div>
                ` : ''}

                ${!prop.txHash && prop.status === 'Executed' ? `
                <div class="bg-yellow-900/30 border border-yellow-600/50 p-2 rounded">
                    <div class="text-yellow-400 text-[9px] font-bold">‚ö†Ô∏è Missing Execution Data</div>
                    <div class="text-yellow-300 text-[10px]">TX Hash and Timestamp not stored in proposal.</div>
                    <div class="flex gap-2 mt-1">
                        <button onclick="searchExecutionTx()" class="text-[9px] bg-yellow-700 hover:bg-yellow-600 px-2 py-0.5 rounded">
                            üîç Search TX
                        </button>
                        <a href="https://chainsco.pe/terra2/address/${prop.creator || 'terra1va3tny5252fca04wqzf7gqh5naa8599nzxqq2vptycgv077zhmjqetanj2'}" 
                           target="_blank" class="text-[9px] bg-gray-700 hover:bg-gray-600 px-2 py-0.5 rounded">
                            üîó Chainscope
                        </a>
                    </div>
                </div>
                ` : ''}

                ${prop.createdDate || prop.expirationDate ? `
                <div class="grid grid-cols-2 gap-2">
                    ${prop.createdDate ? `
                    <div class="bg-gray-800 p-2 rounded">
                        <div class="text-gray-500 text-[9px]">Created</div>
                        <div class="text-green-400 text-xs">${new Date(prop.createdDate).toLocaleDateString()}</div>
                    </div>
                    ` : ''}
                    ${prop.expirationDate ? `
                    <div class="bg-gray-800 p-2 rounded">
                        <div class="text-gray-500 text-[9px]">Expires</div>
                        <div class="text-orange-400 text-xs">${new Date(prop.expirationDate).toLocaleDateString()}</div>
                    </div>
                    ` : ''}
                </div>
                ` : ''}

                <div class="grid grid-cols-3 gap-2">
                    <div class="bg-gray-800 p-2 rounded text-center">
                        <div class="text-green-400 font-bold">${prop.votes.yes}</div>
                        <div class="text-gray-500 text-[9px]">Yes ${prop.totalPower ? `(${((prop.votes.yes / prop.totalPower) * 100).toFixed(1)}%)` : ''}</div>
                    </div>
                    <div class="bg-gray-800 p-2 rounded text-center">
                        <div class="text-red-400 font-bold">${prop.votes.no}</div>
                        <div class="text-gray-500 text-[9px]">No ${prop.totalPower ? `(${((prop.votes.no / prop.totalPower) * 100).toFixed(1)}%)` : ''}</div>
                    </div>
                    <div class="bg-gray-800 p-2 rounded text-center">
                        <div class="text-gray-400 font-bold">${prop.votes.abstain}</div>
                        <div class="text-gray-500 text-[9px]">Abstain ${prop.totalPower ? `(${((prop.votes.abstain / prop.totalPower) * 100).toFixed(1)}%)` : ''}</div>
                    </div>
                </div>

                ${prop.totalPower || prop.turnout || prop.startHeight ? `
                <div class="grid grid-cols-3 gap-2">
                    ${prop.totalPower ? `
                    <div class="bg-gray-800 p-2 rounded text-center">
                        <div class="text-cyan-400 font-bold">${prop.totalPower}</div>
                        <div class="text-gray-500 text-[9px]">Total NFT Power</div>
                    </div>
                    ` : ''}
                    ${prop.turnout ? `
                    <div class="bg-gray-800 p-2 rounded text-center">
                        <div class="text-yellow-400 font-bold">${prop.turnout}%</div>
                        <div class="text-gray-500 text-[9px]">Turnout</div>
                    </div>
                    ` : ''}
                    ${prop.startHeight ? `
                    <div class="bg-gray-800 p-2 rounded text-center">
                        <div class="text-purple-400 font-bold text-xs font-mono">${prop.startHeight}</div>
                        <div class="text-gray-500 text-[9px]">Start Block</div>
                    </div>
                    ` : ''}
                </div>
                ` : ''}

                <div class="bg-gray-800/50 border border-gray-700 rounded p-2">
                    <div class="flex items-center justify-between mb-2">
                        <div class="text-gray-400 text-[9px] font-bold">üó≥Ô∏è VOTERS (${prop.voters?.length || 0})</div>
                        <div class="flex gap-1">
                            <button onclick="toggleVoterPaste()" class="text-[9px] bg-gray-700 hover:bg-gray-600 px-2 py-0.5 rounded">
                                üìã Paste JSON
                            </button>
                            <button onclick="fetchVoters()" class="text-[9px] bg-blue-700 hover:bg-blue-600 px-2 py-0.5 rounded">
                                ‚õìÔ∏è Fetch
                            </button>
                        </div>
                    </div>
                    <div id="voter-paste-area" class="hidden mb-2">
                        <textarea id="voter-json-input" class="w-full h-20 text-[9px] p-1 rounded font-mono bg-gray-900 border border-gray-600" placeholder='Paste voter JSON array here...'></textarea>
                        <button onclick="loadVoterJson()" class="text-[9px] bg-green-700 hover:bg-green-600 px-2 py-0.5 rounded mt-1">Load Voters</button>
                    </div>
                    ${prop.voters?.length > 0 ? `
                    <div class="max-h-40 overflow-y-auto space-y-1">
                        ${prop.voters.map(v => `
                            <div class="flex justify-between items-center py-0.5 border-b border-gray-700 text-[10px]">
                                <div class="flex-1 min-w-0">
                                    <span class="${v.name ? 'text-cyan-400' : 'text-gray-400'}">${v.name || 'Unknown'}</span>
                                    <span class="text-gray-600 font-mono text-[8px] ml-1">${v.address?.slice(0, 8)}...${v.address?.slice(-4)}</span>
                                </div>
                                <div class="flex items-center gap-2 flex-shrink-0">
                                    <span class="text-gray-500 text-[9px]">${v.power || '?'} VP</span>
                                    <span class="${v.vote === 'yes' ? 'text-green-400' : v.vote === 'no' ? 'text-red-400' : 'text-gray-400'} font-bold text-[9px]">
                                        ${v.vote === 'yes' ? '‚úÖ' : v.vote === 'no' ? '‚ùå' : '‚¨ú'}
                                    </span>
                                    ${v.votedAt ? `<span class="text-gray-600 text-[8px]">${new Date(v.votedAt).toLocaleDateString()}</span>` : ''}
                                </div>
                            </div>
                        `).join('')}
                    </div>
                    <div class="mt-1 pt-1 border-t border-gray-700 text-[9px] text-gray-500">
                        <span class="text-green-400">${prop.voters.filter(v => v.vote === 'yes').length} Yes</span> ¬∑ 
                        <span class="text-red-400">${prop.voters.filter(v => v.vote === 'no').length} No</span> ¬∑ 
                        <span class="text-gray-400">${prop.voters.filter(v => v.vote === 'abstain').length} Abstain</span>
                    </div>
                    ` : `
                    <div class="text-gray-500 text-[10px] text-center py-2">
                        No voter data. Click "Fetch" or "Paste JSON" to load.
                    </div>
                    `}
                </div>

                ${crossCheckHtml}

                ${daodaoActionsHtml}

                ${rawActionsHtml}

                ${prop.decodedRawActions?.length > 0 ? renderActionAudit(prop) : ''}

                ${prop.voteAllocations?.length > 0 ? `
                <div class="bg-indigo-900/20 border border-indigo-700/50 rounded p-2 mb-2">
                    <div class="text-indigo-400 text-xs font-bold mb-1">üó≥Ô∏è VOTE ALLOCATIONS (${prop.voteAllocations.length} pools)</div>
                    <div class="space-y-1 max-h-48 overflow-y-auto text-[10px]">
                        <div class="grid grid-cols-5 gap-1 text-gray-500 font-medium border-b border-gray-700 pb-1">
                            <span>Gauge</span>
                            <span>Pool</span>
                            <span class="text-right">Share</span>
                            <span class="text-right">TVL</span>
                            <span class="text-right">Score</span>
                        </div>
                        ${prop.voteAllocations.map(a => `
                            <div class="grid grid-cols-5 gap-1 py-0.5 border-b border-gray-800">
                                <span class="text-purple-400">${a.gauge}</span>
                                <span class="text-cyan-400">${a.name}</span>
                                <span class="text-right text-green-400">${a.share}%</span>
                                <span class="text-right text-yellow-400">$${(a.tvl/1000).toFixed(0)}K</span>
                                <span class="text-right text-gray-400">${a.score.toFixed(3)}</span>
                            </div>
                        `).join('')}
                    </div>
                </div>
                ` : ''}

                ${prop.unknownAddresses?.length > 0 ? `
                <div class="bg-red-900/30 border border-red-500 p-2 rounded">
                    <div class="text-red-400 font-bold text-[9px] mb-1">‚ö†Ô∏è UNKNOWN ADDRESSES (${prop.unknownAddresses.length})</div>
                    ${prop.unknownAddresses.map(u => `
                        <div class="text-red-300 text-[9px]">‚îú‚îÄ‚îÄ ${u.role}: ${u.truncated}</div>
                    `).join('')}
                </div>
                ` : ''}

                <div class="bg-gray-800/50 p-2 rounded mt-2">
                    <div class="text-gray-500 text-[9px] font-bold mb-1">üìä DATA SOURCE</div>
                    <div class="grid grid-cols-2 gap-1 text-[10px]">
                        <span class="text-gray-500">Source:</span>
                        <span class="${prop.sourceType === 'json_export' ? 'text-orange-400' : 'text-blue-400'}">
                            ${prop.sourceType === 'json_export' ? 'üìÇ JSON Export' : 'üìã Page Paste'}
                            ${prop.sourceFile ? ` (${prop.sourceFile})` : ''}
                        </span>
                        <span class="text-gray-500">Raw Actions:</span>
                        <span class="${prop.rawData ? 'text-green-400' : 'text-red-400'}">
                            ${prop.rawData ? `‚úÖ ${prop.rawData.length} actions` : '‚ùå Not loaded'}
                        </span>
                        <span class="text-gray-500">Voters:</span>
                        <span class="${prop.voters?.length > 0 ? 'text-green-400' : 'text-yellow-400'}">
                            ${prop.voters?.length > 0 ? `‚úÖ ${prop.voters.length} voters` : '‚ö†Ô∏è Not fetched'}
                        </span>
                        <span class="text-gray-500">Cross-Check:</span>
                        <span class="${prop.crossCheck ? (prop.crossCheck.verified ? 'text-green-400' : 'text-yellow-400') : 'text-gray-500'}">
                            ${prop.crossCheck ? (prop.crossCheck.verified ? '‚úÖ Verified' : '‚ö†Ô∏è Partial') : '‚Äî Not performed'}
                        </span>
                    </div>
                    ${!prop.rawData ? `
                    <div class="text-[10px] text-yellow-400 mt-2 p-1 bg-yellow-900/20 rounded">
                        üí° To enable cross-check: Use "Fetch from Chain" button or paste raw actions JSON
                    </div>
                    ` : ''}
                </div>
            </div>
        `;
        } catch (e) {
            console.error('Error rendering preview:', e);
            preview.innerHTML = `<div class="text-red-500 p-4">Error rendering preview: ${e.message}</div>`;
        }
    }

    function renderMembers() {
        const container = document.getElementById('members-list');
        const members = Object.values(store.members).sort((a, b) => b.vp - a.vp);

        container.innerHTML = members.map(m => `
            <div class="bg-gray-800/50 p-2 rounded flex justify-between items-center">
                <div>
                    <div class="${m.name ? 'text-cyan-400' : 'text-gray-400'}">${m.name || 'Anonymous'}</div>
                    <div class="text-gray-500 font-mono text-[9px]">${m.address.slice(0, 12)}...${m.address.slice(-6)}</div>
                </div>
                <div class="text-right">
                    <div class="text-yellow-400">${m.vp.toFixed(2)}%</div>
                    <div class="text-gray-500 text-[9px]">${m.staked} NFTs</div>
                </div>
            </div>
        `).join('');
    }

    // Render Action Audit section separately to avoid template literal issues
    function renderActionAudit(prop) {
        if (!prop.decodedRawActions?.length) return '';
        
        let actionsHtml = '';
        
        prop.decodedRawActions.forEach((raw, i) => {
            const daodao = prop.daodaoActions?.[i];
            let detailsHtml = '';
            
            // Get the original raw message for display
            const originalMsg = prop.rawData?.[i];
            const rawJsonStr = originalMsg ? JSON.stringify(originalMsg, null, 2) : 'N/A';
            const rawMsgId = 'raw-msg-' + i;
            
            if (raw.type === 'wasm' && raw.decodedMsg) {
                const msgKey = Object.keys(raw.decodedMsg)[0];
                const msgValue = raw.decodedMsg[msgKey];
                
                if (msgKey === 'vote' && msgValue.gauge) {
                    // TLA Vote - show gauge and pools
                    let poolsHtml = '';
                    (msgValue.votes || []).forEach(([lp, weight]) => {
                        const lpAddr = lp.replace('cw20:', '');
                        const lpName = contractRegistry[lpAddr]?.name || lpAddr.slice(0, 12) + '...';
                        poolsHtml += '<div class="flex justify-between"><span class="text-blue-400">' + lpName + '</span><span class="text-yellow-400">' + (weight/100).toFixed(2) + '%</span></div>';
                    });
                    
                    detailsHtml = '<div class="text-[10px] space-y-1">' +
                        '<div><span class="text-gray-500">Gauge:</span> <span class="text-cyan-400">' + msgValue.gauge + '</span></div>' +
                        '<div><span class="text-gray-500">Pools (' + (msgValue.votes?.length || 0) + '):</span></div>' +
                        '<div class="ml-2 max-h-24 overflow-y-auto">' + poolsHtml + '</div>' +
                        '</div>';
                } else {
                    // Generic wasm action
                    const jsonPreview = JSON.stringify(msgValue, null, 2).slice(0, 300);
                    const hasMore = JSON.stringify(msgValue).length > 300 ? '...' : '';
                    detailsHtml = '<div class="text-[10px]">' +
                        '<div><span class="text-gray-500">Action:</span> <span class="text-cyan-400">' + msgKey + '</span></div>' +
                        '<pre class="text-gray-400 text-[9px] mt-1 max-h-20 overflow-auto bg-black/30 p-1 rounded">' + escapeHtml(jsonPreview) + hasMore + '</pre>' +
                        '</div>';
                }
            } else if (raw.type === 'bank') {
                detailsHtml = '<div class="text-[10px]">' +
                    '<div><span class="text-gray-500">To:</span> <span class="text-cyan-400">' + raw.contractName + '</span></div>' +
                    '<div class="text-gray-500 font-mono text-[8px]">' + raw.contract + '</div>';
                if (raw.funds) {
                    detailsHtml += '<div><span class="text-gray-500">Amount:</span> <span class="text-yellow-400">' + raw.funds.map(f => f.amount.toLocaleString() + ' ' + f.denom).join(', ') + '</span></div>';
                }
                detailsHtml += '</div>';
            } else if (raw.type === 'stargate') {
                const jsonPreview = JSON.stringify(raw.params, null, 2).slice(0, 200);
                detailsHtml = '<div class="text-[10px]">' +
                    '<div><span class="text-gray-500">Type:</span> <span class="text-cyan-400">' + raw.action + '</span></div>' +
                    '<pre class="text-gray-400 text-[9px] mt-1 max-h-20 overflow-auto bg-black/30 p-1 rounded">' + escapeHtml(jsonPreview) + '</pre>' +
                    '</div>';
            }
            
            const isUnknown = raw.contractName?.includes('‚ùì');
            const badgeClass = isUnknown ? 'bg-red-900/50 text-red-400' : 'bg-green-900/50 text-green-400';
            const badgeText = isUnknown ? '‚ö†Ô∏è Unknown Contract' : '‚úÖ Known Contract';
            
            // Build raw message preview (truncated)
            let rawPreview = '';
            if (originalMsg) {
                const rawStr = JSON.stringify(originalMsg);
                if (rawStr.length > 150) {
                    rawPreview = escapeHtml(rawStr.slice(0, 150)) + '...';
                } else {
                    rawPreview = escapeHtml(rawStr);
                }
            }
            
            let fundsHtml = '';
            if (raw.funds) {
                fundsHtml = '<div class="text-[10px]"><span class="text-gray-500">Funds:</span> <span class="text-yellow-400">' + raw.funds.map(f => f.amount.toLocaleString() + ' ' + f.denom).join(', ') + '</span></div>';
            }
            
            let daodaoFundsHtml = '';
            if (daodao?.funds) {
                daodaoFundsHtml = '<div class="text-yellow-300 text-[9px]">üí∞ ' + daodao.funds + '</div>';
            }
            
            actionsHtml += '<div class="bg-gray-800/50 border border-gray-700 rounded p-2">' +
                '<div class="flex items-center justify-between mb-1">' +
                    '<span class="text-purple-400 font-bold text-xs">Action #' + (i + 1) + '</span>' +
                    '<span class="text-[10px] px-2 py-0.5 rounded ' + badgeClass + '">' + badgeText + '</span>' +
                '</div>' +
                '<div class="grid grid-cols-2 gap-2">' +
                    // Left: UI Display
                    '<div class="bg-yellow-900/20 border border-yellow-700/30 rounded p-1.5">' +
                        '<div class="text-yellow-400 text-[9px] font-bold mb-1">üìã UI Display (DAODAO)</div>' +
                        '<div class="text-white text-[10px]">' + (daodao?.display || raw.actionName || 'N/A') + '</div>' +
                        daodaoFundsHtml +
                    '</div>' +
                    // Right: Raw Message
                    '<div class="bg-blue-900/20 border border-blue-700/30 rounded p-1.5">' +
                        '<div class="text-blue-400 text-[9px] font-bold mb-1">üîß Raw Message (On-Chain)</div>' +
                        '<div class="text-[10px]"><span class="text-gray-500">Type:</span> <span class="text-purple-400">' + raw.type + (raw.action ? '.' + raw.action : '') + '</span></div>' +
                        '<div class="text-[10px]"><span class="text-gray-500">Contract:</span> <span class="text-green-400">' + raw.contractName + '</span></div>' +
                        fundsHtml +
                        '<pre class="text-gray-400 text-[8px] mt-1 bg-black/30 p-1 rounded overflow-hidden max-h-12">' + rawPreview + '</pre>' +
                    '</div>' +
                '</div>' +
                '<div class="mt-2 bg-gray-900/50 border border-gray-700 rounded p-1.5">' +
                    '<div class="text-gray-400 text-[9px] font-bold mb-1">üì¶ Decoded Message</div>' +
                    detailsHtml +
                '</div>' +
                '<div class="mt-1 flex items-center justify-between">' +
                    '<button onclick="toggleRawJson(\'' + rawMsgId + '\')" class="text-[9px] text-cyan-400 hover:text-cyan-300">üìÑ Show Full Raw JSON</button>' +
                    '<span class="text-[8px] text-gray-600 font-mono truncate max-w-[200px]" title="' + raw.contract + '">' + raw.contract + '</span>' +
                '</div>' +
                '<pre id="' + rawMsgId + '" class="hidden mt-1 text-[8px] text-gray-400 bg-black/50 p-2 rounded max-h-40 overflow-auto font-mono whitespace-pre-wrap">' + escapeHtml(rawJsonStr) + '</pre>' +
            '</div>';
        });
        
        return '<div class="bg-purple-900/20 border border-purple-700/50 rounded p-2 mb-2">' +
            '<div class="text-purple-400 text-xs font-bold mb-2">üî¨ ACTION AUDIT - Verify UI matches On-Chain Data</div>' +
            '<div class="space-y-2 max-h-[500px] overflow-y-auto">' + actionsHtml + '</div>' +
        '</div>';
    }
    
    function toggleRawJson(id) {
        const el = document.getElementById(id);
        if (el) {
            el.classList.toggle('hidden');
        }
    }
    
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    function renderProposals() {
        const container = document.getElementById('proposals-list');
        const props = Object.values(store.proposals).sort((a, b) => {
            const aNum = parseInt(a.id?.replace('A', '') || 0);
            const bNum = parseInt(b.id?.replace('A', '') || 0);
            return bNum - aNum;
        });

        document.getElementById('prop-count').textContent = props.length;

        if (props.length === 0) {
            container.innerHTML = '<div class="text-gray-500 text-center py-8 col-span-full">No proposals saved yet</div>';
            return;
        }

        const statusColors = {
            'Executed': 'border-green-500 bg-green-900/20',
            'Passed': 'border-blue-500 bg-blue-900/20',
            'Rejected': 'border-red-500 bg-red-900/20',
            'Vetoed': 'border-purple-500 bg-purple-900/20'
        };

        container.innerHTML = props.map(p => `
            <div class="proposal-card border ${statusColors[p.status] || 'border-gray-600'} rounded-lg p-3 cursor-pointer" onclick="loadProposal('${p.id}')">
                <div class="flex justify-between items-start mb-2">
                    <span class="font-bold text-blue-400">${p.id}</span>
                    <span class="text-xs ${p.crossCheck?.verified ? 'text-green-400' : p.crossCheck ? 'text-red-400' : 'text-gray-500'}">
                        ${p.crossCheck?.verified ? '‚úÖ' : p.crossCheck ? '‚ùå' : '‚Äî'}
                    </span>
                </div>
                <div class="text-sm text-gray-300 line-clamp-2 mb-2">${p.title || 'Untitled'}</div>
                <div class="flex justify-between text-xs text-gray-500">
                    <span>${p.status || '‚Äî'}</span>
                    <span>${p.completedDate || p.year || '‚Äî'}</span>
                </div>
            </div>
        `).join('');
    }

    function renderRegistry() {
        const contractsList = document.getElementById('contracts-list');
        const actionsList = document.getElementById('actions-list');

        contractsList.innerHTML = Object.entries(contractRegistry).map(([addr, info]) => `
            <div class="flex justify-between py-1 border-b border-gray-700">
                <span class="text-cyan-400">${info.name}</span>
                <span class="text-gray-500 font-mono">${addr.slice(0, 10)}...</span>
            </div>
        `).join('');

        actionsList.innerHTML = Object.entries(actionRegistry).map(([action, info]) => `
            <div class="flex justify-between py-1 border-b border-gray-700">
                <span class="text-green-400">${action}</span>
                <span class="text-gray-500">${info.name}</span>
            </div>
        `).join('');

        document.getElementById('contract-count').textContent = Object.keys(contractRegistry).length;
        document.getElementById('action-count').textContent = Object.keys(actionRegistry).length;
    }

    // ========================================
    // UI HELPERS
    // ========================================
    function switchTab(tabName) {
        document.querySelectorAll('.tab-content').forEach(el => el.classList.add('hidden'));
        document.querySelectorAll('.tab-btn').forEach(el => el.classList.remove('active'));

        document.getElementById(`content-${tabName}`).classList.remove('hidden');
        document.getElementById(`tab-${tabName}`).classList.add('active');

        if (tabName === 'proposals') renderProposals();
        if (tabName === 'members') renderMembers();
        if (tabName === 'registry') renderRegistry();
    }

    function updateUI() {
        renderProposals();
        renderRegistry();
    }

    function clearPaste() {
        document.getElementById('proposal-paste').value = '';
        document.getElementById('chainscope-paste').value = '';
        document.getElementById('manual-id').value = '';
        document.getElementById('manual-status').value = '';
        document.getElementById('manual-txhash').value = '';
        document.getElementById('manual-timestamp').value = '';
        document.getElementById('manual-block').value = '';
        document.getElementById('manual-epoch').value = '';
        store.currentParsed = null;
        document.getElementById('parse-preview').innerHTML = '<div class="text-gray-500 text-center py-8">Paste a DAODAO proposal page and click "Parse" to preview</div>';
    }

    // ========================================
    // SAVE / LOAD / EXPORT
    // ========================================
    function saveProposal() {
        if (!store.currentParsed?.id) {
            alert('Please parse a proposal first');
            return;
        }

        const prop = store.currentParsed;
        store.proposals[prop.id] = prop;
        saveToLocalStorage();

        alert(`‚úÖ Saved proposal ${prop.id}`);
        clearPaste();
        renderProposals();
    }

    function loadProposal(id) {
        const prop = store.proposals[id];
        if (!prop) return;

        store.currentParsed = prop;
        switchTab('parse');
        renderPreview();

        // Populate manual fields
        document.getElementById('manual-id').value = prop.id || '';
        document.getElementById('manual-status').value = prop.status || '';
        document.getElementById('manual-txhash').value = prop.txHash || '';
        document.getElementById('manual-timestamp').value = prop.timestamp || '';
        document.getElementById('manual-block').value = prop.blockHeight || '';
    }

    function exportAllData() {
        const data = {
            exported_at: new Date().toISOString(),
            dao: store.dao,
            proposals: store.proposals,
            members: store.members
        };

        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${store.dao.id}-governance-export.json`;
        a.click();
        URL.revokeObjectURL(url);
    }

    function importProposals() {
        document.getElementById('import-file').click();
    }

    function handleImport(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const data = JSON.parse(e.target.result);
                if (data.proposals) {
                    Object.assign(store.proposals, data.proposals);
                    saveToLocalStorage();
                    renderProposals();
                    alert(`‚úÖ Imported ${Object.keys(data.proposals).length} proposals`);
                }
            } catch (err) {
                alert('Failed to import: ' + err.message);
            }
        };
        reader.readAsText(file);
        event.target.value = '';
    }

    function snapshotMembers() {
        const epoch = prompt('Enter current epoch number for snapshot:');
        if (!epoch) return;

        const data = {
            epoch: parseInt(epoch),
            snapshot_at: new Date().toISOString(),
            members: store.members
        };

        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `members-epoch-${epoch}.json`;
        a.click();
        URL.revokeObjectURL(url);
    }

    function filterProposals() {
        // TODO: Implement filtering
        renderProposals();
    }

    // ========================================
    // JSON FILE HANDLING
    // ========================================
    // Note: Event handlers are set up in setupFileUpload() on DOMContentLoaded

    function processJsonFile(file) {
        console.log('üìÇ Processing file:', file.name, 'Size:', file.size);
        
        const statusEl = document.getElementById('json-file-status');
        if (!statusEl) {
            console.error('Status element not found');
            alert('Error: Status element not found');
            return;
        }
        
        statusEl.classList.remove('hidden');
        statusEl.textContent = `Loading ${file.name}...`;
        statusEl.className = 'text-xs text-yellow-400 mt-2';

        const reader = new FileReader();
        
        reader.onerror = (err) => {
            console.error('FileReader error:', err);
            statusEl.textContent = `‚ùå Error reading file: ${err}`;
            statusEl.className = 'text-xs text-red-400 mt-2';
        };
        
        reader.onload = (e) => {
            console.log('üìÑ File loaded, parsing JSON...');
            try {
                const json = JSON.parse(e.target.result);
                console.log('üì¶ JSON parsed, keys:', Object.keys(json));
                
                const result = parseDAODAOJsonExport(json, file.name);
                
                if (result.success) {
                    statusEl.textContent = `‚úÖ Loaded: ${result.proposal.id} - ${result.proposal.title}`;
                    statusEl.className = 'text-xs text-green-400 mt-2';
                    
                    store.currentParsed = result.proposal;
                    console.log('‚úÖ Proposal stored:', result.proposal.id);
                    
                    // Populate manual fields from extracted data
                    populateManualFields();
                    
                    renderPreview();
                } else {
                    console.error('Parse failed:', result.error);
                    statusEl.textContent = `‚ùå ${result.error}`;
                    statusEl.className = 'text-xs text-red-400 mt-2';
                }
            } catch (err) {
                console.error('JSON parse error:', err);
                statusEl.textContent = `‚ùå Invalid JSON: ${err.message}`;
                statusEl.className = 'text-xs text-red-400 mt-2';
            }
        };
        
        reader.readAsText(file);
    }

    function parseDAODAOJsonExport(json, filename) {
        const prop = {
            id: null,
            title: null,
            description: null,
            status: null,
            creator: null,
            creatorName: null,
            timestamp: null,
            txHash: null,
            txExplorerUrl: null,
            blockHeight: null,
            startHeight: null,
            year: null,
            turnout: null,
            quorum: null,
            threshold: null,
            totalPower: null,
            vetoer: null,
            votes: { yes: 0, no: 0, abstain: 0 },
            voters: [],
            daodaoActions: [],
            rawData: null,
            decodedRawActions: null,
            crossCheck: null,
            unknownAddresses: [],
            sourceFile: filename,
            sourceType: 'json_export'
        };

        try {
            // Extract ID from filename (e.g., A25__1_.json -> A25)
            const idMatch = filename.match(/([A-Z]?\d+)/i);
            if (idMatch) prop.id = idMatch[1].toUpperCase();

            // DAODAO NextJS pageProps format
            if (json.pageProps?.proposalInfo) {
                const info = json.pageProps.proposalInfo;
                
                prop.id = info.id || prop.id;
                prop.title = info.title;
                prop.description = info.description;
                prop.creator = info.createdByAddress;
                
                // Resolve creator name
                if (prop.creator) {
                    const resolved = resolveAddress(prop.creator);
                    prop.creatorName = resolved.name;
                }

                // Parse expiration
                if (info.expiration?.at_time) {
                    const expNano = BigInt(info.expiration.at_time);
                    const expMs = Number(expNano / 1000000n);
                    prop.expirationDate = new Date(expMs).toISOString();
                }

                // Parse creation epoch
                if (info.createdAtEpoch) {
                    const createdMs = info.createdAtEpoch;
                    prop.createdDate = new Date(createdMs).toISOString();
                    prop.year = new Date(createdMs).getFullYear();
                }

                // Parse description for vote allocations (specific to Alliance DAO vote proposals)
                if (prop.description) {
                    prop.voteAllocations = parseVoteAllocationsFromDescription(prop.description);
                }
            }

            // Extract chain data from dehydratedQueryClientState (React Query cache)
            if (json.pageProps?.dehydratedQueryClientState?.queries) {
                const queries = json.pageProps.dehydratedQueryClientState.queries;
                
                // Find the proposal query with full data
                for (const q of queries) {
                    const stateData = q.state?.data;
                    if (stateData && typeof stateData === 'object' && 
                        'proposal' in stateData && 'id' in stateData) {
                        
                        const chainProp = stateData.proposal;
                        
                        // Status
                        if (chainProp.status) {
                            const statusMap = {
                                'open': 'Open',
                                'passed': 'Passed',
                                'rejected': 'Rejected',
                                'executed': 'Executed',
                                'vetoed': 'Vetoed',
                                'closed': 'Closed'
                            };
                            prop.status = statusMap[chainProp.status] || chainProp.status;
                        }
                        
                        // Proposer (override if present)
                        if (chainProp.proposer) {
                            prop.creator = chainProp.proposer;
                            const resolved = resolveAddress(prop.creator);
                            prop.creatorName = resolved.name;
                        }
                        
                        // Start height
                        if (chainProp.start_height) {
                            prop.startHeight = chainProp.start_height;
                        }
                        
                        // Votes
                        if (chainProp.votes) {
                            prop.votes = {
                                yes: parseInt(chainProp.votes.yes) || 0,
                                no: parseInt(chainProp.votes.no) || 0,
                                abstain: parseInt(chainProp.votes.abstain) || 0
                            };
                        }
                        
                        // Total voting power
                        if (chainProp.total_power) {
                            prop.totalPower = parseInt(chainProp.total_power);
                            
                            // Calculate turnout
                            const totalVotes = prop.votes.yes + prop.votes.no + prop.votes.abstain;
                            if (prop.totalPower > 0) {
                                prop.turnout = ((totalVotes / prop.totalPower) * 100).toFixed(2);
                            }
                        }
                        
                        // Raw messages (actions)
                        if (chainProp.msgs && Array.isArray(chainProp.msgs)) {
                            prop.rawData = chainProp.msgs;
                            prop.decodedRawActions = decodeRawActions(chainProp.msgs);
                            console.log(`üì¶ Extracted ${chainProp.msgs.length} raw actions from JSON`);
                        }
                        
                        // Expiration (override from chain data)
                        if (chainProp.expiration?.at_time) {
                            const expNano = BigInt(chainProp.expiration.at_time);
                            const expMs = Number(expNano / 1000000n);
                            prop.expirationDate = new Date(expMs).toISOString();
                        }
                        
                        break; // Found the proposal data
                    }
                }
                
                // Look for proposal config (quorum, threshold)
                for (const q of queries) {
                    const stateData = q.state?.data;
                    if (stateData && typeof stateData === 'object' && 'threshold' in stateData) {
                        // Extract quorum
                        if (stateData.threshold?.threshold_quorum?.quorum?.percent) {
                            prop.quorum = parseFloat(stateData.threshold.threshold_quorum.quorum.percent) * 100;
                        }
                        // Extract threshold
                        if (stateData.threshold?.threshold_quorum?.threshold?.majority) {
                            prop.threshold = 50; // Majority = 50%+
                        } else if (stateData.threshold?.threshold_quorum?.threshold?.percent) {
                            prop.threshold = parseFloat(stateData.threshold.threshold_quorum.threshold.percent) * 100;
                        }
                        break;
                    }
                }
            }

            // If we have raw data and it's vote actions, create DAODAO-style action representations
            if (prop.rawData && prop.rawData.length > 0) {
                prop.daodaoActions = createDAODAOActionsFromRaw(prop.rawData);
                
                // Perform cross-check
                if (prop.daodaoActions.length > 0) {
                    prop.crossCheck = performCrossCheck(prop);
                }
            }

            if (prop.id) {
                console.log('‚úÖ Parsed DAODAO JSON export:', prop.id, prop.title);
                return { success: true, proposal: prop };
            }

            // Alternative format: direct proposal object
            if (json.id && json.title) {
                prop.id = json.id;
                prop.title = json.title;
                prop.description = json.description;
                prop.status = json.status;
                
                return { success: true, proposal: prop };
            }

            // Check if it's a raw actions array
            if (Array.isArray(json) && json.length > 0 && (json[0].wasm || json[0].bank || json[0].stargate)) {
                // This is raw actions data, not a proposal
                if (store.currentParsed) {
                    store.currentParsed.rawData = json;
                    store.currentParsed.decodedRawActions = decodeRawActions(json);
                    
                    // Re-run cross-check
                    if (store.currentParsed.daodaoActions.length > 0) {
                        store.currentParsed.crossCheck = performCrossCheck(store.currentParsed);
                    }
                    
                    renderPreview();
                    return { success: true, proposal: store.currentParsed, isRawData: true };
                } else {
                    document.getElementById('raw-actions-paste').value = JSON.stringify(json, null, 2);
                    return { success: false, error: 'Raw actions detected - paste in Raw Actions field or load proposal first' };
                }
            }

            return { success: false, error: 'Unrecognized JSON format' };

        } catch (err) {
            console.error('Error parsing DAODAO JSON:', err);
            return { success: false, error: err.message };
        }
    }

    function parseVoteAllocationsFromDescription(description) {
        // Parse CSV-style vote allocations from Alliance DAO vote proposals
        const allocations = [];
        const lines = description.split('\n');
        
        // Skip header line
        for (let i = 1; i < lines.length; i++) {
            const line = lines[i].trim();
            if (!line) continue;
            
            const parts = line.split(',');
            if (parts.length >= 8) {
                allocations.push({
                    gauge: parts[0],
                    share: parseFloat(parts[1]) || 0,
                    name: parts[2],
                    dex: parts[3],
                    tvl: parseFloat(parts[4]) || 0,
                    volume1d: parseFloat(parts[5]) || 0,
                    lpToken: parts[6],
                    score: parseFloat(parts[7]) || 0
                });
            }
        }
        
        return allocations.length > 0 ? allocations : null;
    }

    // Create DAODAO-style action representations from raw messages
    function createDAODAOActionsFromRaw(rawMsgs) {
        const actions = [];
        
        for (const msg of rawMsgs) {
            if (msg.wasm?.execute) {
                const exec = msg.wasm.execute;
                let msgKey = null;
                let decodedMsg = null;
                
                // Decode base64 message
                if (exec.msg) {
                    try {
                        const decoded = atob(exec.msg);
                        decodedMsg = JSON.parse(decoded);
                        msgKey = Object.keys(decodedMsg)[0];
                    } catch (e) {
                        console.warn('Failed to decode wasm msg:', e);
                    }
                }
                
                const action = {
                    type: 'Execute Smart Contract',
                    icon: '‚öîÔ∏è',
                    messageKey: msgKey,
                    contract: exec.contract_addr,
                    contractName: contractRegistry[exec.contract_addr]?.name || '‚ùì Unknown',
                    fundsAmount: null,
                    fundsToken: null,
                    funds: null,
                    decodedMsg: decodedMsg
                };
                
                // Extract funds
                if (exec.funds?.length > 0) {
                    const fund = exec.funds[0];
                    action.fundsAmount = parseInt(fund.amount) / 1e6;
                    action.fundsToken = fund.denom.includes('/') ? fund.denom.split('/').pop() : fund.denom;
                    action.funds = `${action.fundsAmount.toLocaleString()} ${action.fundsToken}`;
                }
                
                // Create display string
                if (msgKey === 'vote' && decodedMsg?.vote?.gauge) {
                    action.display = `TLA Vote: ${decodedMsg.vote.gauge} gauge (${decodedMsg.vote.votes?.length || 0} pools)`;
                } else {
                    action.display = `Execute: ${msgKey || 'unknown'}` +
                        (action.funds ? ` (${action.funds})` : '') +
                        ` ‚Üí ${action.contractName}`;
                }
                
                actions.push(action);
                
            } else if (msg.bank?.send) {
                const send = msg.bank.send;
                const amount = send.amount?.[0];
                
                actions.push({
                    type: 'Spend',
                    icon: 'üíµ',
                    amount: amount ? parseInt(amount.amount) / 1e6 : 0,
                    token: amount?.denom || 'unknown',
                    recipient: send.to_address,
                    recipientName: contractRegistry[send.to_address]?.name || resolveAddress(send.to_address).name || '‚ùì Unknown',
                    display: `Spend ${amount ? (parseInt(amount.amount) / 1e6).toLocaleString() : '?'} ${amount?.denom || '?'} ‚Üí ${send.to_address?.slice(0, 12)}...`
                });
                
            } else if (msg.stargate) {
                const typeUrl = msg.stargate.typeUrl || '';
                const action = typeUrl.split('.').pop();
                
                actions.push({
                    type: 'Stargate',
                    icon: '‚õìÔ∏è',
                    action: action,
                    typeUrl: typeUrl,
                    display: `Stargate: ${action}`,
                    value: msg.stargate.value
                });
            }
        }
        
        return actions;
    }

    // ========================================
    // RAW ACTIONS PARSING
    // ========================================
    function parseRawActions() {
        const text = document.getElementById('raw-actions-paste').value.trim();
        if (!text) {
            alert('Please paste raw actions JSON');
            return;
        }

        try {
            const json = JSON.parse(text);
            
            if (!Array.isArray(json)) {
                alert('Raw actions must be a JSON array');
                return;
            }

            if (!store.currentParsed) {
                store.currentParsed = {
                    id: 'Unknown',
                    title: 'Raw Actions Only',
                    status: 'Unknown',
                    votes: { yes: 0, no: 0, abstain: 0 },
                    voters: [],
                    daodaoActions: [],
                    unknownAddresses: []
                };
            }

            store.currentParsed.rawData = json;
            store.currentParsed.decodedRawActions = decodeRawActions(json);
            
            console.log(`‚úÖ Parsed ${json.length} raw actions`);
            
            // Re-run cross-check if we have DAODAO actions
            if (store.currentParsed.daodaoActions.length > 0) {
                store.currentParsed.crossCheck = performCrossCheck(store.currentParsed);
            }
            
            renderPreview();
            
            // Clear the paste area
            document.getElementById('raw-actions-paste').value = '';
            
        } catch (err) {
            alert('Invalid JSON: ' + err.message);
        }
    }

    async function fetchProposalFromChain() {
        if (!store.currentParsed?.id) {
            alert('Please load a proposal first (parse or upload JSON)');
            return;
        }

        const propId = store.currentParsed.id;
        const propNum = parseInt(propId.replace(/\D/g, ''));
        
        if (isNaN(propNum)) {
            alert('Cannot determine proposal number from ID: ' + propId);
            return;
        }

        const statusEl = document.getElementById('json-file-status');
        statusEl.classList.remove('hidden');
        statusEl.textContent = `‚è≥ Fetching proposal ${propNum} from chain...`;
        statusEl.className = 'text-xs text-yellow-400 mt-2';

        console.log('========================================');
        console.log('‚õìÔ∏è FETCH FROM CHAIN START: Proposal', propNum);
        console.log('========================================');

        try {
            // Query the proposal from DAODAO contract
            const proposalModuleAddr = 'terra1va3tny5252fca04wqzf7gqh5naa8599nzxqq2vptycgv077zhmjqetanj2';
            const query = btoa(JSON.stringify({ proposal: { proposal_id: propNum } }));
            const url = `https://terra-lcd.publicnode.com/cosmwasm/wasm/v1/contract/${proposalModuleAddr}/smart/${query}`;
            
            console.log('üì° LCD Request URL:', url);
            
            let response;
            try {
                response = await fetch(url);
                console.log('üì° LCD Response Status:', response.status, response.statusText);
            } catch (fetchErr) {
                console.error('‚ùå LCD Fetch Error (likely CORS):', fetchErr);
                throw new Error(`LCD fetch failed: ${fetchErr.message}. Check console for CORS errors.`);
            }
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const data = await response.json();
            console.log('‚úÖ Chain proposal data:', data);
            
            if (data.data?.proposal?.msgs) {
                console.log('üìã Messages found:', data.data.proposal.msgs.length);
                
                store.currentParsed.rawData = data.data.proposal.msgs;
                store.currentParsed.decodedRawActions = decodeRawActions(data.data.proposal.msgs);
                
                // Update status from chain
                if (data.data.proposal.status) {
                    const statusMap = {
                        'open': 'Open',
                        'passed': 'Passed',
                        'rejected': 'Rejected',
                        'executed': 'Executed',
                        'vetoed': 'Vetoed'
                    };
                    store.currentParsed.status = statusMap[data.data.proposal.status] || data.data.proposal.status;
                }
                
                // Re-run cross-check
                if (store.currentParsed.daodaoActions.length > 0) {
                    store.currentParsed.crossCheck = performCrossCheck(store.currentParsed);
                }
                
                console.log('========================================');
                console.log('‚úÖ FETCH FROM CHAIN COMPLETE');
                console.log('   Status:', store.currentParsed.status);
                console.log('   Actions:', store.currentParsed.rawData.length);
                console.log('========================================');
                
                statusEl.textContent = `‚úÖ Fetched ${store.currentParsed.rawData.length} actions from chain`;
                statusEl.className = 'text-xs text-green-400 mt-2';
                
                renderPreview();
            } else {
                console.warn('‚ö†Ô∏è No messages in proposal:', data);
                statusEl.textContent = `‚ö†Ô∏è No actions found in proposal`;
                statusEl.className = 'text-xs text-yellow-400 mt-2';
            }
            
        } catch (err) {
            console.error('‚ùå Chain fetch error:', err);
            console.log('========================================');
            console.log('üîç TROUBLESHOOTING:');
            console.log('   1. Check for CORS errors above');
            console.log('   2. If CORS blocked, use JSON file upload instead');
            console.log('========================================');
            
            statusEl.textContent = `‚ùå Fetch failed: ${err.message}`;
            statusEl.className = 'text-xs text-red-400 mt-2';
        }
    }

    // Fetch all data: proposal + voters
    async function fetchAllData() {
        if (!store.currentParsed?.id) {
            alert('Please load a proposal first');
            return;
        }
        
        const statusEl = document.getElementById('json-file-status');
        statusEl.classList.remove('hidden');
        statusEl.textContent = `‚è≥ Fetching all data...`;
        statusEl.className = 'text-xs text-yellow-400 mt-2';
        
        try {
            // First fetch proposal/actions
            await fetchProposalFromChain();
            
            // Then fetch voters
            await fetchVoters();
            
            statusEl.textContent = `‚úÖ Loaded actions + ${store.currentParsed.voters?.length || 0} voters`;
            statusEl.className = 'text-xs text-green-400 mt-2';
            
        } catch (err) {
            console.error('Fetch all error:', err);
            statusEl.textContent = `‚ùå Error: ${err.message}`;
            statusEl.className = 'text-xs text-red-400 mt-2';
        }
    }

    // Search for execution TX using DAODAO indexer
    async function searchExecutionTx() {
        if (!store.currentParsed?.id) {
            alert('Please load a proposal first');
            return;
        }
        
        const propNum = parseInt(store.currentParsed.id.replace(/\D/g, ''));
        if (isNaN(propNum)) {
            alert('Invalid proposal ID');
            return;
        }
        
        const statusEl = document.getElementById('json-file-status');
        statusEl.classList.remove('hidden');
        statusEl.textContent = `‚è≥ Searching for execution TX...`;
        statusEl.className = 'text-xs text-yellow-400 mt-2';
        
        console.log('========================================');
        console.log('üîç SEARCH EXECUTION TX: Proposal', propNum);
        console.log('========================================');
        
        try {
            const proposalModuleAddr = 'terra1va3tny5252fca04wqzf7gqh5naa8599nzxqq2vptycgv077zhmjqetanj2';
            
            // Try DAODAO indexer first - it has proposal events
            const indexerUrl = `https://indexer.daodao.zone/phoenix-1/contract/${proposalModuleAddr}/daoProposalSingle/proposal?id=${propNum}`;
            console.log('üì° Trying indexer:', indexerUrl);
            
            try {
                const indexerResp = await fetch(indexerUrl);
                if (indexerResp.ok) {
                    const indexerData = await indexerResp.json();
                    console.log('üì° Indexer response:', indexerData);
                    
                    if (indexerData.executedAt) {
                        store.currentParsed.timestamp = indexerData.executedAt;
                        store.currentParsed.executedAt = indexerData.executedAt;
                        console.log('‚úÖ Found executedAt:', indexerData.executedAt);
                    }
                    if (indexerData.completedAt) {
                        store.currentParsed.completedAt = indexerData.completedAt;
                    }
                }
            } catch (e) {
                console.log('‚ö†Ô∏è Indexer proposal endpoint failed:', e.message);
            }
            
            // Try LCD tx search for execute messages
            const txSearchUrl = `https://terra-lcd.publicnode.com/cosmos/tx/v1beta1/txs?events=wasm._contract_address%3D%27${proposalModuleAddr}%27&events=wasm.action%3D%27execute%27&pagination.limit=50&order_by=ORDER_BY_DESC`;
            console.log('üì° Trying LCD tx search:', txSearchUrl);
            
            try {
                const txResp = await fetch(txSearchUrl);
                if (txResp.ok) {
                    const txData = await txResp.json();
                    console.log('üì° TX search results:', txData.txs?.length || 0, 'txs');
                    
                    // Look for tx that executed this proposal
                    for (const tx of (txData.txs || [])) {
                        const txBody = tx.body?.messages || [];
                        for (const msg of txBody) {
                            if (msg['@type']?.includes('MsgExecuteContract')) {
                                try {
                                    const msgData = JSON.parse(atob(msg.msg || ''));
                                    if (msgData.execute?.proposal_id === propNum) {
                                        console.log('‚úÖ Found execution TX!');
                                        store.currentParsed.txHash = tx.txhash;
                                        store.currentParsed.timestamp = tx.timestamp;
                                        store.currentParsed.blockHeight = tx.height;
                                        
                                        statusEl.textContent = `‚úÖ Found TX: ${tx.txhash?.slice(0, 16)}...`;
                                        statusEl.className = 'text-xs text-green-400 mt-2';
                                        
                                        renderPreview();
                                        return;
                                    }
                                } catch (e) {}
                            }
                        }
                    }
                }
            } catch (e) {
                console.log('‚ö†Ô∏è LCD tx search failed:', e.message);
            }
            
            // If we got executedAt from indexer but no TX hash
            if (store.currentParsed.executedAt) {
                statusEl.textContent = `‚ö†Ô∏è Found timestamp but not TX hash. Check Chainscope.`;
                statusEl.className = 'text-xs text-yellow-400 mt-2';
                renderPreview();
            } else {
                statusEl.textContent = `‚ö†Ô∏è TX not found. Try searching on Chainscope manually.`;
                statusEl.className = 'text-xs text-yellow-400 mt-2';
            }
            
            console.log('========================================');
            console.log('üîç TX search complete');
            console.log('   executedAt:', store.currentParsed.executedAt || 'not found');
            console.log('   txHash:', store.currentParsed.txHash || 'not found');
            console.log('========================================');
            
        } catch (err) {
            console.error('‚ùå TX search error:', err);
            statusEl.textContent = `‚ùå Search failed: ${err.message}`;
            statusEl.className = 'text-xs text-red-400 mt-2';
        }
    }

    // Quick fetch by proposal ID - no need to upload JSON first
    async function quickFetchProposal() {
        const input = document.getElementById('quick-fetch-id');
        const idStr = input?.value.trim();
        
        if (!idStr) {
            alert('Please enter a proposal ID');
            return;
        }
        
        const propNum = parseInt(idStr.replace(/\D/g, ''));
        if (isNaN(propNum) || propNum < 1) {
            alert('Invalid proposal ID: ' + idStr);
            return;
        }
        
        const propId = 'A' + propNum;
        
        const statusEl = document.getElementById('json-file-status');
        statusEl.classList.remove('hidden');
        statusEl.textContent = `‚è≥ Fetching proposal ${propId}...`;
        statusEl.className = 'text-xs text-yellow-400 mt-2';
        
        console.log('========================================');
        console.log('üîÑ QUICK FETCH START: Proposal', propId);
        console.log('========================================');
        
        try {
            const proposalModuleAddr = 'terra1va3tny5252fca04wqzf7gqh5naa8599nzxqq2vptycgv077zhmjqetanj2';
            
            // 1. Fetch proposal data from LCD
            const lcdUrl = `https://terra-lcd.publicnode.com/cosmwasm/wasm/v1/contract/${proposalModuleAddr}/smart/${btoa(JSON.stringify({ proposal: { proposal_id: propNum } }))}`;
            console.log('üì° LCD Request URL:', lcdUrl);
            
            let propResponse;
            try {
                propResponse = await fetch(lcdUrl);
                console.log('üì° LCD Response Status:', propResponse.status, propResponse.statusText);
                console.log('üì° LCD Response Headers:', Object.fromEntries(propResponse.headers.entries()));
            } catch (fetchErr) {
                console.error('‚ùå LCD Fetch Error (likely CORS):', fetchErr);
                throw new Error(`LCD fetch failed: ${fetchErr.message}. Check console for CORS errors.`);
            }
            
            if (!propResponse.ok) {
                const errorText = await propResponse.text();
                console.error('‚ùå LCD Error Response:', errorText);
                throw new Error(`Proposal fetch failed: HTTP ${propResponse.status}`);
            }
            
            const propData = await propResponse.json();
            console.log('‚úÖ LCD Proposal Data:', propData);
            
            const proposal = propData.data?.proposal;
            
            if (!proposal) {
                console.error('‚ùå No proposal in response:', propData);
                throw new Error('Proposal not found');
            }
            
            console.log('üìã Proposal Title:', proposal.title);
            console.log('üìã Proposal Status:', proposal.status);
            console.log('üìã Proposal Messages:', proposal.msgs?.length || 0);
            
            // Build our proposal object
            store.currentParsed = {
                id: propId,
                title: proposal.title,
                description: proposal.description,
                status: proposal.status?.charAt(0).toUpperCase() + proposal.status?.slice(1),
                creator: proposal.proposer,
                creatorName: resolveAddress(proposal.proposer).name,
                startHeight: proposal.start_height,
                totalPower: parseInt(proposal.total_power) || 0,
                votes: {
                    yes: parseInt(proposal.votes?.yes) || 0,
                    no: parseInt(proposal.votes?.no) || 0,
                    abstain: parseInt(proposal.votes?.abstain) || 0
                },
                voters: [],
                rawData: proposal.msgs,
                decodedRawActions: decodeRawActions(proposal.msgs || []),
                daodaoActions: createDAODAOActionsFromRaw(proposal.msgs || []),
                unknownAddresses: [],
                sourceType: 'chain_fetch',
                sourceFile: `Proposal #${propNum}`
            };
            
            // Calculate turnout
            const totalVotes = store.currentParsed.votes.yes + store.currentParsed.votes.no + store.currentParsed.votes.abstain;
            if (store.currentParsed.totalPower > 0) {
                store.currentParsed.turnout = ((totalVotes / store.currentParsed.totalPower) * 100).toFixed(2);
            }
            
            // Parse expiration
            if (proposal.expiration?.at_time) {
                const expNano = BigInt(proposal.expiration.at_time);
                const expMs = Number(expNano / 1000000n);
                store.currentParsed.expirationDate = new Date(expMs).toISOString();
            }
            
            // Extract quorum/threshold
            if (proposal.threshold?.threshold_quorum) {
                store.currentParsed.quorum = parseFloat(proposal.threshold.threshold_quorum.quorum?.percent || 0) * 100;
                if (proposal.threshold.threshold_quorum.threshold?.majority) {
                    store.currentParsed.threshold = 50;
                }
            }
            
            // Parse vote allocations from description
            if (proposal.description) {
                store.currentParsed.voteAllocations = parseVoteAllocationsFromDescription(proposal.description);
            }
            
            console.log('‚úÖ Proposal parsed, fetching voters...');
            statusEl.textContent = `‚è≥ Loaded proposal, fetching voters...`;
            
            // 2. Fetch voters from indexer
            const votersUrl = `https://indexer.daodao.zone/phoenix-1/contract/${proposalModuleAddr}/daoProposalSingle/listVotes?proposalId=${propNum}&limit=100`;
            console.log('üì° Indexer Request URL:', votersUrl);
            
            try {
                const votersResponse = await fetch(votersUrl);
                console.log('üì° Indexer Response Status:', votersResponse.status, votersResponse.statusText);
                
                if (votersResponse.ok) {
                    const voters = await votersResponse.json();
                    console.log('‚úÖ Voters loaded:', voters?.length || 0, 'voters');
                    console.log('üìã Voter sample:', voters?.[0]);
                    
                    if (Array.isArray(voters)) {
                        store.currentParsed.voters = voters.map(v => ({
                            address: v.voter,
                            name: resolveAddress(v.voter).name,
                            vote: v.vote?.toLowerCase() || 'unknown',
                            power: parseInt(v.power) || 0,
                            rationale: v.rationale,
                            votedAt: v.votedAt
                        })).sort((a, b) => b.power - a.power);
                    }
                } else {
                    console.warn('‚ö†Ô∏è Voters fetch failed:', votersResponse.status);
                }
            } catch (voterErr) {
                console.error('‚ùå Indexer Fetch Error (likely CORS):', voterErr);
                console.log('üí° Tip: You can manually paste voter JSON using the "Paste JSON" button');
            }
            
            // Populate manual fields
            populateManualFields();
            
            console.log('========================================');
            console.log('‚úÖ QUICK FETCH COMPLETE');
            console.log('   Title:', store.currentParsed.title);
            console.log('   Status:', store.currentParsed.status);
            console.log('   Actions:', store.currentParsed.rawData?.length || 0);
            console.log('   Voters:', store.currentParsed.voters?.length || 0);
            console.log('========================================');
            
            statusEl.textContent = `‚úÖ Loaded ${propId}: ${store.currentParsed.title?.slice(0, 30)}... (${store.currentParsed.voters.length} voters)`;
            statusEl.className = 'text-xs text-green-400 mt-2';
            
            renderPreview();
            
        } catch (err) {
            console.error('‚ùå QUICK FETCH ERROR:', err);
            console.log('========================================');
            console.log('üîç TROUBLESHOOTING:');
            console.log('   1. Check for CORS errors above');
            console.log('   2. If CORS blocked, use JSON file upload instead');
            console.log('   3. Or paste voter JSON manually');
            console.log('========================================');
            
            statusEl.textContent = `‚ùå ${err.message}`;
            statusEl.className = 'text-xs text-red-400 mt-2';
        }
    }

    // ========================================
    // MANUAL FIELD HANDLERS
    // ========================================
    function updateManualField(field, value) {
        if (!store.currentParsed) {
            store.currentParsed = {
                id: null,
                title: null,
                status: null,
                votes: { yes: 0, no: 0, abstain: 0 },
                voters: [],
                daodaoActions: [],
                unknownAddresses: []
            };
        }
        
        switch (field) {
            case 'id':
                store.currentParsed.id = value;
                break;
            case 'status':
                store.currentParsed.status = value;
                break;
            case 'txHash':
                store.currentParsed.txHash = value;
                if (value) {
                    store.currentParsed.txExplorerUrl = `https://chainsco.pe/terra2/tx/${value}`;
                }
                break;
            case 'timestamp':
                store.currentParsed.timestamp = value;
                break;
            case 'blockHeight':
                store.currentParsed.blockHeight = parseInt(value) || null;
                break;
            case 'epoch':
                store.currentParsed.epoch = parseInt(value) || null;
                break;
        }
    }

    // Parse TX hash from raw hash or Chainscope/Mintscan URL
    function parseTxHashInput(value) {
        if (!value) return;
        
        let txHash = value.trim();
        
        // Check if it's a Chainscope URL
        const urlMatch = txHash.match(/chainsco\.pe\/terra2?\/tx\/([A-Fa-f0-9]{64})/i);
        if (urlMatch) {
            txHash = urlMatch[1].toUpperCase();
            console.log('‚úÖ Extracted TX hash from Chainscope URL:', txHash);
        }
        
        // Check if it's a Mintscan URL
        const mintscanMatch = txHash.match(/mintscan\.io\/terra2?\/tx(?:s)?\/([A-Fa-f0-9]{64})/i);
        if (mintscanMatch) {
            txHash = mintscanMatch[1].toUpperCase();
            console.log('‚úÖ Extracted TX hash from Mintscan URL:', txHash);
        }
        
        // Validate it looks like a TX hash (64 hex chars)
        if (/^[A-Fa-f0-9]{64}$/.test(txHash)) {
            txHash = txHash.toUpperCase();
            document.getElementById('manual-txhash').value = txHash;
            updateManualField('txHash', txHash);
            console.log('‚úÖ TX Hash set:', txHash);
            
            // Auto-fetch TX details if we have a valid hash
            fetchTxDetails(txHash);
        } else if (txHash.length > 0) {
            // Maybe just a partial hash or something else - just save it
            updateManualField('txHash', txHash);
            console.warn('‚ö†Ô∏è Non-standard TX hash format:', txHash);
        }
    }

    // Fetch TX details (timestamp, block) from LCD
    async function fetchTxDetails(txHash) {
        console.log('üì° Fetching TX details for:', txHash);
        
        const statusEl = document.getElementById('json-file-status');
        if (statusEl) {
            statusEl.classList.remove('hidden');
            statusEl.textContent = `‚è≥ Fetching TX details...`;
            statusEl.className = 'text-xs text-yellow-400 mt-2';
        }
        
        try {
            const response = await fetch(`https://terra-lcd.publicnode.com/cosmos/tx/v1beta1/txs/${txHash}`);
            if (!response.ok) {
                console.warn('‚ö†Ô∏è TX fetch failed:', response.status);
                if (statusEl) {
                    statusEl.textContent = `‚ö†Ô∏è Could not fetch TX details`;
                    statusEl.className = 'text-xs text-yellow-400 mt-2';
                }
                return;
            }
            
            const data = await response.json();
            console.log('‚úÖ TX data:', data);
            
            if (data.tx_response) {
                const txResp = data.tx_response;
                
                // Update timestamp
                if (txResp.timestamp) {
                    document.getElementById('manual-timestamp').value = txResp.timestamp;
                    updateManualField('timestamp', txResp.timestamp);
                    if (store.currentParsed) store.currentParsed.timestamp = txResp.timestamp;
                    console.log('‚úÖ Timestamp:', txResp.timestamp);
                }
                
                // Update block height  
                if (txResp.height) {
                    document.getElementById('manual-block').value = txResp.height;
                    updateManualField('blockHeight', txResp.height);
                    if (store.currentParsed) store.currentParsed.blockHeight = txResp.height;
                    console.log('‚úÖ Block:', txResp.height);
                }
                
                // Show success
                if (statusEl) {
                    statusEl.textContent = `‚úÖ TX loaded: ${txResp.timestamp} (Block ${txResp.height})`;
                    statusEl.className = 'text-xs text-green-400 mt-2';
                }
                
                renderPreview();
            }
        } catch (err) {
            console.error('‚ùå TX fetch error:', err);
            if (statusEl) {
                statusEl.textContent = `‚ùå TX fetch failed: ${err.message}`;
                statusEl.className = 'text-xs text-red-400 mt-2';
            }
        }
    }

    function applyManualOverrides() {
        // Read all manual fields and apply to currentParsed
        const id = document.getElementById('manual-id').value.trim();
        const status = document.getElementById('manual-status').value;
        const txHash = document.getElementById('manual-txhash').value.trim();
        const timestamp = document.getElementById('manual-timestamp').value.trim();
        const blockHeight = document.getElementById('manual-block').value.trim();
        const epoch = document.getElementById('manual-epoch').value.trim();
        
        if (!store.currentParsed) {
            store.currentParsed = {
                votes: { yes: 0, no: 0, abstain: 0 },
                voters: [],
                daodaoActions: [],
                unknownAddresses: []
            };
        }
        
        if (id) store.currentParsed.id = id;
        if (status) store.currentParsed.status = status;
        if (txHash) {
            store.currentParsed.txHash = txHash;
            store.currentParsed.txExplorerUrl = `https://chainsco.pe/terra2/tx/${txHash}`;
        }
        if (timestamp) store.currentParsed.timestamp = timestamp;
        if (blockHeight) store.currentParsed.blockHeight = parseInt(blockHeight);
        if (epoch) store.currentParsed.epoch = parseInt(epoch);
        
        renderPreview();
        console.log('‚úÖ Manual overrides applied:', store.currentParsed);
    }

    function populateManualFields() {
        // Populate manual fields from currentParsed
        if (!store.currentParsed) return;
        
        document.getElementById('manual-id').value = store.currentParsed.id || '';
        document.getElementById('manual-status').value = store.currentParsed.status || '';
        document.getElementById('manual-txhash').value = store.currentParsed.txHash || '';
        document.getElementById('manual-timestamp').value = store.currentParsed.timestamp || '';
        document.getElementById('manual-block').value = store.currentParsed.blockHeight || store.currentParsed.startHeight || '';
        document.getElementById('manual-epoch').value = store.currentParsed.epoch || '';
    }

    // ========================================
    // FETCH VOTERS FROM CHAIN
    // ========================================
    function toggleVoterPaste() {
        const area = document.getElementById('voter-paste-area');
        if (area) area.classList.toggle('hidden');
    }
    
    function loadVoterJson() {
        const input = document.getElementById('voter-json-input');
        if (!input || !input.value.trim()) {
            alert('Please paste voter JSON');
            return;
        }
        
        try {
            const voters = JSON.parse(input.value.trim());
            if (!Array.isArray(voters)) {
                throw new Error('Expected JSON array');
            }
            
            if (!store.currentParsed) {
                store.currentParsed = { voters: [] };
            }
            
            // Transform to our format
            store.currentParsed.voters = voters.map(v => {
                const resolved = resolveAddress(v.voter);
                return {
                    address: v.voter,
                    name: resolved.name,
                    vote: v.vote?.toLowerCase() || 'unknown',
                    power: parseInt(v.power) || 0,
                    rationale: v.rationale,
                    votedAt: v.votedAt
                };
            });
            
            // Sort by power descending
            store.currentParsed.voters.sort((a, b) => b.power - a.power);
            
            // Hide paste area and render
            document.getElementById('voter-paste-area').classList.add('hidden');
            document.getElementById('voter-json-input').value = '';
            
            console.log('‚úÖ Loaded', store.currentParsed.voters.length, 'voters from JSON');
            renderPreview();
            
        } catch (err) {
            console.error('Voter JSON parse error:', err);
            alert('Invalid JSON: ' + err.message);
        }
    }
    
    async function fetchVoters() {
        if (!store.currentParsed?.id) {
            alert('Please load a proposal first');
            return;
        }

        const propId = store.currentParsed.id;
        const propNum = parseInt(propId.replace(/\D/g, ''));
        
        if (isNaN(propNum)) {
            alert('Cannot determine proposal number from ID: ' + propId);
            return;
        }

        const statusEl = document.getElementById('json-file-status');
        statusEl.classList.remove('hidden');
        statusEl.textContent = `‚è≥ Fetching voters for proposal ${propNum} from indexer...`;
        statusEl.className = 'text-xs text-yellow-400 mt-2';

        console.log('========================================');
        console.log('üó≥Ô∏è FETCH VOTERS START: Proposal', propNum);
        console.log('========================================');

        try {
            const proposalModuleAddr = 'terra1va3tny5252fca04wqzf7gqh5naa8599nzxqq2vptycgv077zhmjqetanj2';
            
            // Use DAODAO indexer API - has votedAt timestamps
            let allVotes = [];
            let offset = 0;
            const limit = 100;
            let hasMore = true;
            
            while (hasMore) {
                const url = `https://indexer.daodao.zone/phoenix-1/contract/${proposalModuleAddr}/daoProposalSingle/listVotes?proposalId=${propNum}&limit=${limit}&offset=${offset}`;
                console.log('üì° Indexer Request URL:', url);
                
                let response;
                try {
                    response = await fetch(url);
                    console.log('üì° Indexer Response Status:', response.status, response.statusText);
                } catch (fetchErr) {
                    console.error('‚ùå Indexer Fetch Error (likely CORS):', fetchErr);
                    throw new Error(`Indexer fetch failed: ${fetchErr.message}. Check console for CORS errors.`);
                }
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const votes = await response.json();
                console.log('üì° Batch received:', votes?.length || 0, 'votes at offset', offset);
                
                if (!Array.isArray(votes) || votes.length === 0) {
                    hasMore = false;
                } else {
                    allVotes = allVotes.concat(votes);
                    offset += votes.length;
                    
                    // If we got less than limit, we're done
                    if (votes.length < limit) {
                        hasMore = false;
                    }
                    
                    // Safety limit
                    if (allVotes.length > 500) {
                        hasMore = false;
                    }
                }
            }
            
            console.log('‚úÖ Total voters loaded:', allVotes.length);
            
            // Transform votes to our format
            store.currentParsed.voters = allVotes.map(v => {
                const resolved = resolveAddress(v.voter);
                return {
                    address: v.voter,
                    name: resolved.name,
                    vote: v.vote?.toLowerCase() || 'unknown',
                    power: parseInt(v.power) || 0,
                    rationale: v.rationale,
                    votedAt: v.votedAt
                };
            });
            
            // Sort by power descending
            store.currentParsed.voters.sort((a, b) => b.power - a.power);
            
            console.log('========================================');
            console.log('‚úÖ FETCH VOTERS COMPLETE:', store.currentParsed.voters.length, 'voters');
            console.log('========================================');
            
            statusEl.textContent = `‚úÖ Loaded ${store.currentParsed.voters.length} voters from indexer`;
            statusEl.className = 'text-xs text-green-400 mt-2';
            
            renderPreview();
            
        } catch (err) {
            console.error('‚ùå Fetch voters error:', err);
            console.log('========================================');
            console.log('üîç TROUBLESHOOTING:');
            console.log('   1. Check for CORS errors above');
            console.log('   2. If CORS blocked, use "Paste JSON" button instead');
            console.log('   3. Get voter data from DAODAO dev tools:');
            console.log('      indexer.daodao.zone/.../listVotes?proposalId=' + propNum);
            console.log('========================================');
            
            statusEl.textContent = `‚ùå Failed to fetch voters: ${err.message}`;
            statusEl.className = 'text-xs text-red-400 mt-2';
        }
    }
    </script>
</body>
</html>
