<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DAO Governance Tool v15</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * { font-family: 'Inter', sans-serif; }
        .mono { font-family: 'JetBrains Mono', monospace; }
        body { background: #0a0a0f; }
        
        .glass {
            background: rgba(15, 15, 25, 0.8);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.06);
        }
        
        .nav-item {
            transition: all 0.15s;
            border-left: 3px solid transparent;
        }
        .nav-item:hover { background: rgba(255, 255, 255, 0.03); }
        .nav-item.active {
            background: rgba(59, 130, 246, 0.1);
            border-left-color: #3b82f6;
        }
        
        .scrollbar-thin::-webkit-scrollbar { width: 5px; }
        .scrollbar-thin::-webkit-scrollbar-track { background: transparent; }
        .scrollbar-thin::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 3px; }
        
        .status-executed { color: #4ade80; }
        .status-passed { color: #60a5fa; }
        .status-rejected { color: #f87171; }
        .status-open { color: #fbbf24; }
        
        details summary { list-style: none; }
        details summary::-webkit-details-marker { display: none; }
        details[open] summary { margin-bottom: 8px; }
        
        .line-clamp-2 {
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
    </style>
</head>
<body class="text-gray-300 h-screen flex">
    <!-- Sidebar -->
    <aside class="w-56 glass border-r border-white/5 flex flex-col">
        <div class="p-5 border-b border-white/5">
            <div class="flex items-center gap-3 mb-3">
                <div class="w-9 h-9 rounded-lg bg-gradient-to-br from-blue-500 to-purple-600 flex items-center justify-center font-bold text-white" id="dao-icon">A</div>
                <div>
                    <div class="font-semibold text-white text-sm" id="dao-name">Alliance DAO</div>
                    <div class="text-xs text-gray-500">Governance</div>
                </div>
            </div>
            <select id="dao-selector" onchange="switchDao(this.value)" class="w-full bg-white/10 border border-white/20 rounded-lg px-2 py-1.5 text-xs text-white cursor-pointer" style="color-scheme: dark;">
                <option value="alliancedao" selected style="background: #1a1a2e; color: white;">Alliance DAO</option>
                <option value="liondao" style="background: #1a1a2e; color: white;">Lion DAO</option>
                <option value="pixelions" style="background: #1a1a2e; color: white;">pixeLions DAO</option>
            </select>
        </div>
        
        <nav class="flex-1 py-3">
            <div class="nav-item active px-5 py-2.5 cursor-pointer flex items-center gap-3" onclick="showView('proposals')">
                <span class="text-gray-400">üìã</span>
                <span class="text-sm">Proposals</span>
                <span class="ml-auto text-xs bg-white/10 px-1.5 py-0.5 rounded" id="nav-prop-count">0</span>
            </div>
            <div class="nav-item px-5 py-2.5 cursor-pointer flex items-center gap-3" onclick="showView('fetch')">
                <span class="text-gray-400">‚ö°</span>
                <span class="text-sm">Fetch Proposal</span>
            </div>
            <div id="nav-autofetch" class="nav-item hidden px-5 py-2.5 cursor-pointer flex items-center gap-3" onclick="showView('autofetch')">
                <span class="text-gray-400">üöÄ</span>
                <span class="text-sm">Auto Fetch All</span>
            </div>
            <div id="nav-registry" class="nav-item px-5 py-2.5 cursor-pointer flex items-center gap-3" onclick="showView('registry')">
                <span class="text-gray-400">üìö</span>
                <span class="text-sm">Registry</span>
            </div>
            <div class="nav-item px-5 py-2.5 cursor-pointer flex items-center gap-3" onclick="showView('export')">
                <span class="text-gray-400">üíæ</span>
                <span class="text-sm">Export Data</span>
            </div>
        </nav>
        
        <div class="p-4 border-t border-white/5 text-xs text-gray-600">
            <div>Proposals: <span class="text-gray-400" id="sidebar-prop-count">0</span></div>
            <div class="mt-1">DAO: <span class="text-gray-400" id="sidebar-dao">aDAO</span></div>
            <div class="mt-2" id="registry-status"><span class="text-yellow-400">‚è≥ Loading registry...</span></div>
        </div>
    </aside>
    
    <!-- Main -->
    <main class="flex-1 flex flex-col overflow-hidden">
        <!-- Header -->
        <header class="glass border-b border-white/5 px-6 py-4">
            <h1 class="text-lg font-semibold text-white" id="view-title">Proposals</h1>
            <p class="text-sm text-gray-500" id="view-subtitle">All proposals you've fetched</p>
        </header>
        
        <!-- Content -->
        <div class="flex-1 overflow-auto p-6 scrollbar-thin">
            <!-- Fetch View -->
            <div id="view-fetch" class="view-content hidden">
                <div class="max-w-2xl">
                    <!-- Fetch Box -->
                    <div class="glass rounded-xl p-6 mb-6">
                        <h2 class="text-white font-medium mb-4">‚ö° Quick Fetch by Proposal ID</h2>
                        <div class="flex gap-3">
                            <div class="flex items-center bg-white/5 border border-white/10 rounded-lg px-4 flex-1">
                                <span class="text-gray-500 text-lg">A</span>
                                <input type="number" id="fetch-id" placeholder="25" 
                                       class="bg-transparent border-none outline-none px-2 py-3 flex-1 text-white text-lg"
                                       onkeyup="if(event.key==='Enter')fetchProposal()">
                            </div>
                            <button onclick="fetchProposal()" class="px-8 py-3 bg-blue-600 hover:bg-blue-500 rounded-lg font-medium transition">
                                Fetch
                            </button>
                        </div>
                        <div id="fetch-status" class="mt-4 text-sm hidden"></div>
                    </div>
                    
                    <!-- Result Preview -->
                    <div id="fetch-result" class="hidden">
                        <div class="glass rounded-xl p-6">
                            <div class="flex items-start justify-between mb-4">
                                <div>
                                    <div class="flex items-center gap-3 mb-1">
                                        <span class="text-2xl font-bold text-white" id="result-id">A25</span>
                                        <span class="px-2 py-0.5 rounded text-xs font-medium" id="result-status">Executed</span>
                                    </div>
                                    <h3 class="text-white font-medium" id="result-title">Title</h3>
                                </div>
                                <button onclick="saveProposal()" class="px-4 py-2 bg-green-600 hover:bg-green-500 rounded-lg text-sm font-medium transition">
                                    üíæ Save
                                </button>
                            </div>
                            
                            <!-- Description -->
                            <div class="mb-6">
                                <div class="text-xs text-gray-500 uppercase mb-2">Description</div>
                                <div class="text-gray-300 text-sm leading-relaxed whitespace-pre-wrap max-h-48 overflow-auto" id="result-description"></div>
                            </div>
                            
                            <!-- Votes -->
                            <div class="grid grid-cols-4 gap-3 mb-4">
                                <div class="bg-white/5 rounded-lg p-3 text-center">
                                    <div class="text-green-400 text-xl font-bold" id="result-yes">0</div>
                                    <div class="text-xs text-gray-500">Yes</div>
                                </div>
                                <div class="bg-white/5 rounded-lg p-3 text-center">
                                    <div class="text-red-400 text-xl font-bold" id="result-no">0</div>
                                    <div class="text-xs text-gray-500">No</div>
                                </div>
                                <div class="bg-white/5 rounded-lg p-3 text-center">
                                    <div class="text-gray-400 text-xl font-bold" id="result-abstain">0</div>
                                    <div class="text-xs text-gray-500">Abstain</div>
                                </div>
                                <div class="bg-white/5 rounded-lg p-3 text-center">
                                    <div class="text-cyan-400 text-xl font-bold" id="result-voters">0</div>
                                    <div class="text-xs text-gray-500">Voters</div>
                                </div>
                            </div>
                            
                            <!-- Outcome -->
                            <div id="result-outcome" class="mb-6 p-4 rounded-lg">
                                <div class="flex items-center justify-between mb-2">
                                    <div class="flex items-center gap-2">
                                        <span id="result-outcome-icon" class="text-xl">‚úÖ</span>
                                        <span id="result-outcome-text" class="font-bold">PASSED</span>
                                    </div>
                                    <div class="text-sm">
                                        <span class="text-gray-400">Turnout:</span>
                                        <span id="result-turnout" class="font-medium">0%</span>
                                        <span class="text-gray-600 text-xs" id="result-quorum-status">(‚úì quorum)</span>
                                    </div>
                                </div>
                                <div class="flex gap-4 text-sm">
                                    <div>
                                        <span class="text-gray-400">Yes:</span>
                                        <span class="text-green-400 font-medium" id="result-yes-pct">0%</span>
                                    </div>
                                    <div>
                                        <span class="text-gray-400">No:</span>
                                        <span class="text-red-400 font-medium" id="result-no-pct">0%</span>
                                    </div>
                                    <div>
                                        <span class="text-gray-400">Abstain:</span>
                                        <span class="text-gray-400 font-medium" id="result-abstain-pct">0%</span>
                                    </div>
                                </div>
                                <div id="result-outcome-reason" class="text-gray-500 text-xs mt-2"></div>
                            </div>
                            
                            <!-- Actions -->
                            <div>
                                <div class="text-xs text-gray-500 uppercase mb-2">Actions (<span id="result-action-count">0</span>)</div>
                                <div id="result-actions" class="space-y-2 max-h-64 overflow-auto"></div>
                            </div>
                            
                            <!-- Link Execution TX (for executed proposals) -->
                            <div id="result-execution-link" class="hidden mt-6 p-4 rounded-lg bg-purple-500/10 border border-purple-500/30">
                                <div class="flex items-center justify-between mb-3">
                                    <h4 class="text-purple-400 font-medium">üîó Link Execution Transaction</h4>
                                    <span class="text-gray-500 text-xs">Optional: See actual treasury flows</span>
                                </div>
                                <div class="flex gap-2 mb-3">
                                    <button onclick="openDaodaoForCurrentProp()" 
                                            class="px-4 py-2 bg-white/5 hover:bg-white/10 border border-purple-500/50 rounded text-sm text-purple-400 transition">
                                        üìã Open DAODAO to get TX hash ‚Üó
                                    </button>
                                </div>
                                <div class="flex gap-2">
                                    <input type="text" id="result-tx-hash" placeholder="Paste TX hash here..."
                                           onclick="event.stopPropagation()"
                                           class="flex-1 bg-white/5 border border-white/10 rounded px-3 py-2 text-sm mono text-white focus:outline-none focus:border-purple-500">
                                    <button onclick="pasteFromClipboard()" class="px-3 py-2 bg-white/10 hover:bg-white/20 rounded text-sm text-gray-300" title="Paste from clipboard">
                                        üìã
                                    </button>
                                    <button onclick="linkExecutionTx()" class="px-4 py-2 bg-purple-600 hover:bg-purple-500 rounded text-sm">
                                        Link TX
                                    </button>
                                </div>
                                <div id="result-tx-status" class="mt-2 text-xs hidden"></div>
                            </div>
                            
                            <!-- Linked Execution Results -->
                            <div id="result-execution-data" class="hidden mt-6">
                                <div class="flex items-center justify-between mb-3">
                                    <h4 class="text-green-400 font-medium">üìä Actual Execution Results</h4>
                                    <a id="result-execution-explorer" href="#" target="_blank" class="text-purple-400 hover:underline text-xs">View TX ‚Üó</a>
                                </div>
                                <div class="grid grid-cols-2 gap-4">
                                    <div>
                                        <div class="text-xs text-gray-500 mb-2">Treasury Received</div>
                                        <div id="result-execution-received" class="space-y-1"></div>
                                    </div>
                                    <div>
                                        <div class="text-xs text-gray-500 mb-2">Treasury Sent</div>
                                        <div id="result-execution-sent" class="space-y-1"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Auto Fetch All View (for Lion DAO & PixelLions) -->
            <div id="view-autofetch" class="view-content hidden">
                <div class="max-w-4xl">
                    <div class="glass rounded-xl p-6 mb-6">
                        <div class="flex items-center justify-between mb-4">
                            <div>
                                <h2 class="text-white font-medium">üöÄ Auto-Fetch All Proposals</h2>
                                <p class="text-sm text-gray-500 mt-1">Automatically fetches all proposals from A1 until no more found</p>
                            </div>
                            <div class="flex gap-2">
                                <button onclick="autoFetchAllProposals()" id="autofetch-btn" class="px-6 py-3 bg-blue-600 hover:bg-blue-500 rounded-lg font-medium transition">
                                    üöÄ Start Auto-Fetch
                                </button>
                                <button onclick="exportProposalsJson()" class="px-4 py-3 bg-purple-600 hover:bg-purple-500 rounded-lg font-medium transition" title="Export JSON">
                                    üíæ JSON
                                </button>
                                <button onclick="exportVotersCSV()" class="px-4 py-3 bg-cyan-600 hover:bg-cyan-500 rounded-lg font-medium transition" title="Export CSV">
                                    üìä CSV
                                </button>
                            </div>
                        </div>
                        <div id="autofetch-status" class="text-sm text-gray-500"></div>
                        <div id="autofetch-progress" class="hidden mt-4">
                            <div class="h-2 bg-white/10 rounded-full overflow-hidden">
                                <div id="autofetch-bar" class="h-full bg-blue-500 transition-all" style="width: 0%"></div>
                            </div>
                            <div id="autofetch-text" class="text-xs text-gray-500 mt-2"></div>
                        </div>
                    </div>
                    
                    <!-- Stats -->
                    <div class="grid grid-cols-3 gap-4 mb-6">
                        <div class="glass rounded-lg p-4 text-center">
                            <div class="text-2xl font-bold text-blue-400" id="af-stat-props">0</div>
                            <div class="text-xs text-gray-500">Proposals</div>
                        </div>
                        <div class="glass rounded-lg p-4 text-center">
                            <div class="text-2xl font-bold text-green-400" id="af-stat-voters">0</div>
                            <div class="text-xs text-gray-500">Unique Voters</div>
                        </div>
                        <div class="glass rounded-lg p-4 text-center">
                            <div class="text-2xl font-bold text-purple-400" id="af-stat-votes">0</div>
                            <div class="text-xs text-gray-500">Total Votes</div>
                        </div>
                    </div>
                    
                    <!-- Results -->
                    <div class="glass rounded-xl overflow-hidden">
                        <div class="p-4 border-b border-white/5 flex items-center justify-between">
                            <h3 class="font-medium text-white">Proposals & Voters</h3>
                            <input type="text" id="af-search" onkeyup="renderAutoFetchResults()" placeholder="Search address or name..." 
                                   class="bg-white/5 border border-white/10 rounded-lg px-3 py-1.5 text-sm w-64">
                        </div>
                        <div id="autofetch-results" class="max-h-[500px] overflow-auto">
                            <div class="text-center text-gray-600 py-8">Click "Start Auto-Fetch" to load all proposals</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Proposals View -->
            <div id="view-proposals" class="view-content">
                <!-- New proposals notification -->
                <div id="new-props-status" class="hidden mb-4 p-3 rounded-lg bg-yellow-500/10 border border-yellow-500/30"></div>
                
                <div class="flex gap-3 mb-4">
                    <input type="text" id="search-proposals" onkeyup="renderProposals()" placeholder="Search..." 
                           class="bg-white/5 border border-white/10 rounded-lg px-4 py-2 text-sm flex-1">
                    <select id="filter-outcome" onchange="renderProposals()" class="bg-white/5 border border-white/10 rounded-lg px-4 py-2 text-sm">
                        <option value="">All Outcomes</option>
                        <option value="passed">‚úÖ Passed</option>
                        <option value="rejected">‚ùå Rejected</option>
                        <option value="voting">üó≥Ô∏è Voting</option>
                    </select>
                    <select id="filter-status" onchange="renderProposals()" class="bg-white/5 border border-white/10 rounded-lg px-4 py-2 text-sm">
                        <option value="">All Status</option>
                        <option value="executed">Executed</option>
                        <option value="passed">Passed</option>
                        <option value="rejected">Rejected</option>
                        <option value="closed">Closed</option>
                        <option value="open">Open</option>
                    </select>
                    <button onclick="exportAll()" class="px-4 py-2 bg-green-600 hover:bg-green-500 rounded-lg text-sm">üì§ Export</button>
                    <button onclick="loadProposalsFromGitHub()" class="px-4 py-2 bg-blue-600 hover:bg-blue-500 rounded-lg text-sm" title="Reload from GitHub">üîÑ</button>
                    <button onclick="checkForNewProposals()" class="px-4 py-2 bg-purple-600 hover:bg-purple-500 rounded-lg text-sm" title="Check for new proposals on-chain">üîç Check New</button>
                    <button onclick="clearAll()" class="px-4 py-2 bg-red-600/50 hover:bg-red-600 rounded-lg text-sm">üóëÔ∏è</button>
                </div>
                <div id="proposals-list" class="space-y-3">
                    <div class="text-gray-600 text-center py-8">No proposals saved yet. Fetch one first!</div>
                </div>
            </div>
            
            <!-- Registry View -->
            <div id="view-registry" class="view-content hidden">
                <div class="mb-4 flex items-center gap-4">
                    <input type="text" id="search-registry" onkeyup="renderRegistry()" placeholder="Search by name or address..." 
                           class="bg-white/5 border border-white/10 rounded-lg px-4 py-2 text-sm flex-1 max-w-md">
                    <button onclick="loadRegistry().then(() => renderRegistry())" class="px-4 py-2 bg-purple-600 hover:bg-purple-500 rounded-lg text-sm">üîÑ Reload</button>
                    <a id="registry-github-link" href="https://github.com/defipatriot/adao_json_storage/blob/main/alliancedao_registry.json" target="_blank" 
                       class="text-xs text-gray-500 hover:text-purple-400">üìÅ View on GitHub ‚Üó</a>
                </div>
                <div class="glass rounded-xl overflow-hidden">
                    <table class="w-full text-sm">
                        <thead>
                            <tr class="border-b border-white/10 text-left text-xs text-gray-500 uppercase">
                                <th class="px-4 py-3">Name</th>
                                <th class="px-4 py-3">Type</th>
                                <th class="px-4 py-3">Address</th>
                            </tr>
                        </thead>
                        <tbody id="registry-table"></tbody>
                    </table>
                </div>
            </div>
            
            <!-- Export View -->
            <div id="view-export" class="view-content hidden">
                <div class="max-w-4xl">
                    <div class="glass rounded-xl p-6 mb-6">
                        <h2 class="text-white font-medium mb-4">üíæ Export Data for GitHub</h2>
                        <p class="text-gray-400 text-sm mb-6">Export verified proposal data to commit to your repository. This data powers the public website.</p>
                        
                        <div class="grid grid-cols-2 gap-4 mb-6">
                            <div class="glass rounded-lg p-4">
                                <div class="text-2xl font-bold text-purple-400" id="export-prop-count">0</div>
                                <div class="text-xs text-gray-500">Proposals Ready</div>
                            </div>
                            <div class="glass rounded-lg p-4">
                                <div class="text-2xl font-bold text-green-400" id="export-clean-count">0</div>
                                <div class="text-xs text-gray-500">Clean (No Issues)</div>
                            </div>
                        </div>
                        
                        <div class="space-y-3">
                            <button onclick="exportProposalsJson()" class="w-full px-4 py-3 bg-purple-600 hover:bg-purple-500 rounded-lg text-sm flex items-center justify-center gap-2">
                                <span>üìã</span> Export Proposals JSON
                            </button>
                            <button onclick="exportVotersCSV()" class="w-full px-4 py-3 bg-cyan-600 hover:bg-cyan-500 rounded-lg text-sm flex items-center justify-center gap-2">
                                <span>üìä</span> Export Voters CSV
                            </button>
                            <button onclick="exportTreasuryImpact()" id="btn-treasury-export" class="w-full px-4 py-3 bg-blue-600 hover:bg-blue-500 rounded-lg text-sm flex items-center justify-center gap-2">
                                <span>üí∞</span> Export Treasury Impact JSON
                            </button>
                            <button onclick="exportRegistryJson()" id="btn-registry-export" class="w-full px-4 py-3 bg-green-600 hover:bg-green-500 rounded-lg text-sm flex items-center justify-center gap-2">
                                <span>üìö</span> Export Registry JSON
                            </button>
                            <button onclick="exportFullAuditReport()" id="btn-audit-export" class="w-full px-4 py-3 bg-orange-600 hover:bg-orange-500 rounded-lg text-sm flex items-center justify-center gap-2">
                                <span>üìä</span> Export Full Audit Report
                            </button>
                        </div>
                    </div>
                    
                    <div class="glass rounded-xl p-6">
                        <h3 class="text-white font-medium mb-4">üìù Export Preview</h3>
                        <pre id="export-preview" class="bg-black/30 rounded-lg p-4 text-xs text-gray-400 overflow-auto max-h-96 mono">Select an export option to preview...</pre>
                    </div>
                </div>
            </div>
        </div>
    </main>
    
    <!-- Detail Slide Panel -->
    <aside id="detail-panel" class="w-[480px] glass border-l border-white/5 fixed right-0 top-0 h-full transform translate-x-full transition-transform duration-200 overflow-auto z-50">
        <div class="p-6">
            <div class="flex items-center justify-between mb-4">
                <h2 class="font-semibold text-white" id="detail-title">Details</h2>
                <button onclick="closeDetail()" class="text-gray-500 hover:text-white text-2xl leading-none">&times;</button>
            </div>
            <div id="detail-content"></div>
        </div>
    </aside>

<script>
// ========================================
// DATA STORE
// ========================================
const store = {
    proposalsByDao: {
        alliancedao: {},
        liondao: {},
        pixelions: {}
    },
    proposals: {},  // Points to current DAO's proposals
    currentFetched: null,
    members: {},  // Combined members from all CSVs
    membersLoaded: false
};

// ========================================
// CONTRACT REGISTRY
// ========================================
// ========================================
// DAO CONFIGURATIONS
// ========================================
// ========================================
// DAO CONFIGURATION
// Set active: true to enable, false for "Coming Soon"
// ========================================
const daoConfigs = {
    'alliancedao': {
        active: true,  // ‚úÖ ENABLED
        name: 'Alliance DAO',
        shortName: 'aDAO',
        propPrefix: 'A',
        proposalModule: 'terra1va3tny5252fca04wqzf7gqh5naa8599nzxqq2vptycgv077zhmjqetanj2',
        treasury: 'terra1sffd4efk2jpdt894r04qwmtjqrrjfc52tmj6vkzjxqhd8qqu2drs3m5vzm',
        core: 'terra1csp8gsjk2yyxzqewza6lkjvwkspn7zs2jvamk9uf05crtcakf6gszk2g8y',
        votingModule: 'terra1c57ur376szdv8rtes6sa9nst4k536dynunksu8tx5zu4z5u3am6qmvqx47',
        nftCollection: 'terra1phr9fngjv7a8an4dhmhd0u0f98wazxfnzccqtyheq4zqrrp4fpuqw3apw9',
        registryUrl: 'https://raw.githubusercontent.com/defipatriot/adao_json_storage/main/alliancedao_registry.json',
        membersUrl: 'https://raw.githubusercontent.com/defipatriot/adao_json_storage/main/members.csv',
        propsUrl: 'https://raw.githubusercontent.com/defipatriot/adao_json_storage/main/adao_props.json',
        quorum: 10,
        threshold: 50,
        votingPeriod: 7,
        color: '#8B5CF6'
    },
    'liondao': {
        active: true,  // ‚úÖ ENABLED
        name: 'Lion DAO',
        shortName: 'ROAR',
        propPrefix: 'A',
        proposalModule: null,  // Will be auto-discovered from core
        treasury: 'terra1tkersa2mqwy2h8exj799qx2xrhdu0dkymk9psp6v0k4kz4tkxucssgluec',
        core: 'terra1tkersa2mqwy2h8exj799qx2xrhdu0dkymk9psp6v0k4kz4tkxucssgluec',  // Main DAO address
        registryUrl: '',
        membersUrl: 'https://raw.githubusercontent.com/defipatriot/adao_json_storage/main/lion_dao_members.csv',
        propsUrl: 'https://raw.githubusercontent.com/defipatriot/adao_json_storage/main/liondao_props.json',
        quorum: 10,
        threshold: 50,
        color: '#F59E0B'
    },
    'pixelions': {
        active: true,  // ‚úÖ ENABLED
        name: 'pixeLions DAO',
        shortName: 'pxL',
        propPrefix: 'A',
        proposalModule: null,  // Will be auto-discovered from core
        treasury: 'terra1c690mdrwdetnr09zfk3tf9xz9jhrgd9wpjyf3tuccj74ql09eqmq6sh7en',
        core: 'terra1c690mdrwdetnr09zfk3tf9xz9jhrgd9wpjyf3tuccj74ql09eqmq6sh7en',  // Main DAO address
        registryUrl: '',
        membersUrl: 'https://raw.githubusercontent.com/defipatriot/adao_json_storage/main/pixellion_members.csv',
        propsUrl: 'https://raw.githubusercontent.com/defipatriot/adao_json_storage/main/pixelions_props.json',
        quorum: 10,
        threshold: 50,
        color: '#EC4899'
    }
};

let currentDao = 'alliancedao';

// ========================================
// PROPOSAL MODULE DISCOVERY
// Auto-discovers proposal module from DAO core contract
// ========================================
async function discoverProposalModule(daoId) {
    const config = daoConfigs[daoId];
    if (!config || !config.core) {
        console.error('No core address for', daoId);
        return null;
    }
    
    // If we already have it, return it
    if (config.proposalModule) {
        return config.proposalModule;
    }
    
    try {
        console.log(`üîç Discovering proposal module for ${config.name}...`);
        
        // Query the DAO core for proposal modules
        const query = btoa(JSON.stringify({ proposal_modules: { limit: 10 } }));
        const url = `https://terra-lcd.publicnode.com/cosmwasm/wasm/v1/contract/${config.core}/smart/${query}`;
        
        const response = await fetch(url);
        if (!response.ok) throw new Error('Failed to query DAO core');
        
        const data = await response.json();
        const modules = data.data;
        
        if (Array.isArray(modules) && modules.length > 0) {
            // Get the first proposal module (usually the main one)
            const propModule = modules[0].address || modules[0];
            console.log(`‚úÖ Found proposal module: ${propModule}`);
            
            // Cache it in the config
            config.proposalModule = propModule;
            return propModule;
        }
        
        throw new Error('No proposal modules found');
    } catch (e) {
        console.error(`‚ùå Failed to discover proposal module for ${daoId}:`, e);
        return null;
    }
}

// ========================================
// KNOWN PROPOSAL NOTES
// Annotations for specific proposals (test props, historical context, etc.)
// ========================================
const knownProposalNotes = {
    'a1': {
        note: '‚ö†Ô∏è INTENTIONAL TEST: This proposal was created to test the council veto function. The "suspicious" action was intentional to verify the veto mechanism works correctly. Proposal was successfully vetoed as expected.',
        type: 'test',
        resolved: true
    }
};

// ========================================
// RISK SCORE SYSTEM
// ========================================
function calculateRiskScore(prop) {
    let score = 100; // Start with perfect score
    const factors = [];
    
    if (!prop.decodedActions || prop.decodedActions.length === 0) {
        return { score: 50, level: 'unknown', factors: [{ type: 'info', msg: 'No actions to analyze' }] };
    }
    
    const audit = auditProposal(prop);
    const impact = calculateTreasuryImpact(prop);
    const hasExecutionTx = prop.executionTx && (prop.executionTx.received?.length > 0 || prop.executionTx.sent?.length > 0);
    
    // === WHAT WE CAN VERIFY (Open or Executed) ===
    
    // 1. Unknown addresses receiving funds
    // Differentiate: bank sends (wallet payments) are lower risk than contract calls
    const unknownContractRecipients = prop.decodedActions.filter(a => 
        a.contractType === 'unknown' && a.type !== 'bank' && (a.funds?.length > 0 || a.action === 'send' || a.action === 'transfer')
    );
    const unknownWalletPayments = prop.decodedActions.filter(a => 
        a.contractType === 'unknown' && a.type === 'bank' && a.funds?.length > 0
    );
    
    if (unknownContractRecipients.length > 0) {
        // Contract calls to unknown addresses - CRITICAL
        score -= 25 * unknownContractRecipients.length;
        factors.push({ type: 'error', msg: `${unknownContractRecipients.length} unknown contract(s) receiving funds - HIGH RISK` });
    }
    
    if (unknownWalletPayments.length > 0) {
        // Bank sends to unknown wallets - WARNING (likely private community member)
        score -= 10 * unknownWalletPayments.length;
        factors.push({ type: 'warning', msg: `${unknownWalletPayments.length} payment(s) to wallet not in registry - verify recipient` });
    }
    
    // 2. Hidden/extra raw messages - CRITICAL
    const rawCount = prop.rawMsgs?.length || 0;
    const actionCount = prop.decodedActions.length;
    if (rawCount > actionCount) {
        score -= 30;
        factors.push({ type: 'error', msg: `${rawCount - actionCount} hidden message(s) detected` });
    }
    
    // 3. Unknown contracts (not receiving funds) - WARNING
    const allUnknownAddresses = prop.decodedActions.filter(a => a.contractType === 'unknown').length;
    const alreadyCounted = unknownContractRecipients.length + unknownWalletPayments.length;
    if (allUnknownAddresses > alreadyCounted) {
        const nonFundUnknowns = allUnknownAddresses - alreadyCounted;
        score -= 5 * nonFundUnknowns;
        factors.push({ type: 'warning', msg: `${nonFundUnknowns} unknown contract(s) - verify before voting` });
    }
    
    // 4. Unregistered members
    const unregisteredMembers = prop.decodedActions.filter(a => a.contractType === 'unknown_member').length;
    if (unregisteredMembers > 0) {
        score -= 3 * unregisteredMembers;
        factors.push({ type: 'warning', msg: `${unregisteredMembers} unregistered member address(es)` });
    }
    
    // Wallet payments (member wallets are human-controlled - higher risk)
    // These need careful verification: addresses can be compromised, spoofed, or typo'd
    const walletPayments = prop.decodedActions.filter(a => 
        a.type === 'bank' && (a.contractType === 'member' || a.contractType === 'unknown_member')
    );
    if (walletPayments.length > 0) {
        // Base penalty: 15 points per wallet payment (significant risk)
        score -= 15 * walletPayments.length;
        factors.push({ type: 'warning', msg: `${walletPayments.length} payment(s) to member wallet(s) - verify addresses carefully` });
        
        // Extra penalty for unknown members (not in registry)
        const unknownWallets = walletPayments.filter(a => a.contractType === 'unknown_member').length;
        if (unknownWallets > 0) {
            score -= 10 * unknownWallets;
            factors.push({ type: 'warning', msg: `${unknownWallets} payment(s) to UNKNOWN wallet(s) - high risk!` });
        }
    }
    
    // Admin operations
    const adminOps = prop.decodedActions.filter(a => 
        ['update_config', 'execute', 'update_members'].includes(a.action)
    ).length;
    if (adminOps > 0) {
        score -= 5 * adminOps;
        factors.push({ type: 'warning', msg: `${adminOps} admin operation(s) - review config changes` });
    }
    
    // Large transfers (>10k LUNA equivalent)
    const largeTransfers = impact.outflows.filter(o => {
        if (o.token === 'LUNA' && o.amount > 10000) return true;
        // Could add USD conversion here later
        return false;
    });
    if (largeTransfers.length > 0) {
        score -= 5;
        factors.push({ type: 'warning', msg: `Large transfer(s): ${largeTransfers.map(t => t.amount.toLocaleString() + ' ' + t.token).join(', ')}` });
    }
    
    // Nested callbacks
    const callbackIssues = audit.issues.filter(i => i.title.includes('callback'));
    if (callbackIssues.length > 0) {
        score -= 10 * callbackIssues.length;
        factors.push({ type: 'warning', msg: `${callbackIssues.length} nested callback(s) detected` });
    }
    
    // Duplicate actions
    const duplicateIssues = audit.issues.filter(i => i.title.includes('Duplicate'));
    if (duplicateIssues.length > 0) {
        score -= 3 * duplicateIssues.length;
        factors.push({ type: 'warning', msg: `${duplicateIssues.length} duplicate action(s)` });
    }
    
    // === POSITIVE FACTORS (Small bonuses) ===
    
    // All addresses known
    const allKnown = prop.decodedActions.every(a => a.contractType === 'contract' || a.contractType === 'member');
    if (allKnown && prop.decodedActions.length > 0) {
        factors.push({ type: 'success', msg: `All ${prop.decodedActions.length} contract(s) verified in registry` });
    }
    
    // Standard operations only (claims, votes, withdrawals)
    const standardOps = ['claim_rewards', 'claim_bribes', 'claim_rebase', 'claim', 'vote', 'tune_amps', 'set_item', 'withdraw', 'send'];
    const allStandard = prop.decodedActions.every(a => standardOps.includes(a.action));
    if (allStandard && prop.decodedActions.length > 0) {
        score = Math.min(100, score + 5);
        factors.push({ type: 'success', msg: 'All standard/low-risk operations' });
    }
    
    // Info about execution status
    if (!hasExecutionTx) {
        factors.push({ type: 'info', msg: 'Open proposal - link execution TX after passing to verify actual amounts' });
    } else {
        factors.push({ type: 'info', msg: 'Execution TX linked - actual inflows/outflows recorded' });
    }
    
    // Clamp score
    score = Math.max(0, Math.min(100, score));
    
    // Determine level
    let level = 'low';
    if (score < 50) level = 'high';
    else if (score < 75) level = 'medium';
    
    return { score, level, factors };
}

// ========================================
// CONTRACT QUERY (fetch unknown contract info)
// ========================================
async function queryContractInfo(address) {
    try {
        const url = `https://terra-lcd.publicnode.com/cosmwasm/wasm/v1/contract/${address}`;
        const response = await fetch(url);
        if (!response.ok) return null;
        
        const data = await response.json();
        return {
            address,
            label: data.contract_info?.label || 'Unknown',
            codeId: data.contract_info?.code_id || 'Unknown',
            admin: data.contract_info?.admin || 'None',
            creator: data.contract_info?.creator || 'Unknown'
        };
    } catch (e) {
        console.warn('Contract query failed:', e);
        return null;
    }
}

// Query all unknown contracts in a proposal
async function queryUnknownContracts(prop) {
    const unknowns = [];
    
    // Find all unknown addresses
    prop.decodedActions?.forEach(action => {
        if (action.contractType === 'unknown' && action.contract) {
            if (!unknowns.includes(action.contract)) {
                unknowns.push(action.contract);
            }
        }
    });
    
    // Also check nested addresses
    prop.decodedActions?.forEach(action => {
        if (action.params) {
            const nested = findNestedAddresses(action.params);
            nested.forEach(n => {
                const resolved = resolveAddress(n.address);
                if (resolved.type === 'unknown' && !unknowns.includes(n.address)) {
                    unknowns.push(n.address);
                }
            });
        }
    });
    
    // Query each unknown
    const results = [];
    for (const addr of unknowns) {
        const info = await queryContractInfo(addr);
        if (info) results.push(info);
    }
    
    return results;
}

// ========================================
// VALIDATOR REGISTRY
// ========================================
const validatorRegistry = {
    'terravaloper1sl97x54v0u3extuj2zrf7h0qrrtpgpslmahxau': { name: 'Strangelove', status: 'inactive' },
    // Add more validators as encountered
};

// ========================================
// IBC DENOM REGISTRY (for readable token names)
// ========================================
const ibcDenomRegistry = {
    // Format: 'ibc/HASH' or just the hash portion
    // ASTRO
    'ibc/8D8A7F7257BE': 'ASTRO',
    '8D8A7F': 'ASTRO',
    // xASTRO (staked ASTRO)
    'ibc/65B3EB6263482979': 'xASTRO',
    '65B3EB': 'xASTRO',
    // bWHALE (Backbone WHALE / boneWHALE)
    'ibc/517E13F14A12': 'bWHALE',
    '517E13': 'bWHALE',
    // ampWHALE
    'ibc/B3F639855EE7': 'ampWHALE',
    'B3F639': 'ampWHALE',
    // arbWHALE
    'CC43C3': 'arbWHALE',
    'ibc/CC43C3': 'arbWHALE',
    // USDC
    'ibc/B3504E092456B': 'USDC',
    // USDT
    'ibc/CBF67A2BCF6C': 'USDT',
    // ATOM
    'ibc/27394FB092D2': 'ATOM',
    // Other IBC tokens - add as encountered
};

// CW20 Token name overrides (contract address ‚Üí readable name)
const tokenNameOverrides = {
    'terra1ecgazyd0waaj3g7l9cmy5gulhxkps2gmxu9ghducvuypjq68mq2s5lvsct': 'ampLUNA',
    'terra1nsuqsk6kh58ulczatwev87ttq2z6r3pusulg9r24mfj2fvtzd4uq3exn26': 'xASTRO',
    'terra186rpfczl7l2kugdsqqedegl4es4hp624phfc7ddy8my02a4e8lgq5rlx7y': 'ampCAPA',
    'terra1t4p3u8khpd7f8qzurwyafxt648dya6mp6vur3vaapswt6m24gkuqrfdhar': 'CAPA',
};

// ========================================
// EXTERNAL REGISTRY (loaded from GitHub)
// ========================================

// Base contracts that are always available (fallback if external registry fails)
const baseContracts = {
    // Alliance DAO
    'terra1sffd4efk2jpdt894r04qwmtjqrrjfc52tmj6vkzjxqhd8qqu2drs3m5vzm': { name: 'AllianceDAO Treasury', type: 'treasury', validActions: ['execute'], canReceiveFunds: true },
    'terra1va3tny5252fca04wqzf7gqh5naa8599nzxqq2vptycgv077zhmjqetanj2': { name: 'AllianceDAO Proposal Module', type: 'dao', validActions: ['propose', 'vote', 'execute'] },
    'terra1csp8gsjk2yyxzqewza6lkjvwkspn7zs2jvamk9uf05crtcakf6gszk2g8y': { name: 'AllianceDAO Core', type: 'dao', validActions: ['execute'] },
    
    // Lion DAO
    'terra1tkersa2mqwy2h8exj799qx2xrhdu0dkymk9psp6v0k4kz4tkxucssgluec': { name: 'Lion DAO Treasury', type: 'treasury', validActions: ['execute'], canReceiveFunds: true },
    'terra1smcelyjz7agf36fkzzfqus845jnme29mh7ltee64hnt9d5a936kq50lwza': { name: 'Lion DAO Proposal Module', type: 'dao', validActions: ['propose', 'vote', 'execute'] },
    'terra1xgg9cf94ws2mawr6lyrdvmyxt48xkwgp8gvtsrcg2yktqvk8w2rqxflq06': { name: 'Lion DAO Core', type: 'dao', validActions: ['execute'] },
    'terra1dxh9hpwfnttezvpncm4553zggs30ddt0x6w44yq8gfxwdf90rudqzezfj8': { name: 'Lion DAO Pre-Propose', type: 'dao', validActions: ['propose'] },
    'terra1gj5wd5855jnsua480rk6dhfnzaz9nvnl2ur36jn3hzhlle67ss5qq5y5uq': { name: 'Lion DAO Pre-Propose (Deposit)', type: 'dao', validActions: ['propose'], canReceiveFunds: true },
    'terra1xuqh84yz35h70p3ppt76dz5kgwwtwmsv34pg0gw6ld4ntptgjcrqe2e70t': { name: 'Lion DAO ROAR Staking', type: 'staking', validActions: ['stake', 'unstake', 'claim'], canReceiveFunds: true },
    'terra1zug2ur6d5ls7vgzwkh0m2002jrallfehpsadpltjqr3vhgvp6lnq90rj3w': { name: 'Lion DAO Rewards Distributor', type: 'rewards', validActions: ['claim', 'fund'], canReceiveFunds: true },
    
    // Shared contracts (used by multiple DAOs)
    'terra1lxx40s29qvkrcj8fsa3yzyehy7w50umdvvnls2r830rys6lu2zns63eelv': { name: 'ROAR Token', type: 'token', validActions: ['transfer', 'send', 'burn', 'increase_allowance'] },
    'terra1tuuwm8yrj54qeg0c8xu00aha9ryatyhtczq8qq2q8tntuw0auzas9037wh': { name: 'TLA Bribe Manager', type: 'rewards', validActions: ['claim_bribes', 'add_bribe'], canReceiveFunds: true },
};

// Initialize with base contracts - will be extended from GitHub
let contractRegistry = { ...baseContracts };
let lpPoolRegistry = {};
let registryLoaded = false;
let registryError = null;

// Load registry from GitHub (DAO-specific)
async function loadRegistry() {
    const config = daoConfigs[currentDao];
    const registryUrl = config?.registryUrl;
    
    // Start with base contracts
    contractRegistry = { ...baseContracts };
    
    if (!registryUrl) {
        console.log(`‚ÑπÔ∏è No external registry URL for ${currentDao}, using base contracts only`);
        registryLoaded = true;
        registryError = null;
        updateRegistryStatus();
        return true;
    }
    
    try {
        console.log(`Loading registry for ${currentDao} from GitHub...`);
        const response = await fetch(registryUrl);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        
        const data = await response.json();
        
        // Merge with base contracts (external takes precedence)
        contractRegistry = { ...baseContracts, ...(data.contracts || {}) };
        lpPoolRegistry = data.lpPools || {};
        registryLoaded = true;
        registryError = null;
        
        console.log(`‚úÖ Registry loaded: ${Object.keys(contractRegistry).length} contracts, ${Object.keys(lpPoolRegistry).length} LP pools`);
        
        // Update UI to show registry status
        updateRegistryStatus();
        
        // Re-render if we have proposals loaded
        if (Object.keys(store.proposals).length > 0) {
            renderProposals();
        }
        
        return true;
    } catch (err) {
        console.error('‚ùå Failed to load external registry:', err);
        console.log('‚ÑπÔ∏è Using base contracts only');
        registryError = `External failed: ${err.message} (using base)`;
        registryLoaded = true; // Still "loaded" with base contracts
        updateRegistryStatus();
        return false;
    }
}

function updateRegistryStatus() {
    const statusEl = document.getElementById('registry-status');
    if (statusEl) {
        if (registryLoaded) {
            statusEl.innerHTML = `<span class="text-green-400">‚úÖ Registry loaded (${Object.keys(contractRegistry).length} contracts)</span>`;
        } else if (registryError) {
            statusEl.innerHTML = `<span class="text-red-400">‚ùå Registry error: ${registryError}</span>`;
        } else {
            statusEl.innerHTML = `<span class="text-yellow-400">‚è≥ Loading registry...</span>`;
        }
    }
    
    // Update GitHub link to point to current DAO's registry
    const githubLink = document.getElementById('registry-github-link');
    if (githubLink) {
        const config = daoConfigs[currentDao];
        if (config?.registryUrl) {
            // Convert raw URL to GitHub blob URL
            const blobUrl = config.registryUrl.replace('raw.githubusercontent.com', 'github.com').replace('/main/', '/blob/main/');
            githubLink.href = blobUrl;
        }
    }
}

// Gauge type explanations
const gaugeTypes = {
    'project': { name: 'Project Gauge', description: '50% compound, 50% claimable rewards' },
    'single': { name: 'Single Gauge', description: '100% auto-compound' }
};

// ========================================
// ACTION REGISTRY
// ========================================
const actionRegistry = {
    'claim_rebase': { name: 'Claim Rebase', category: 'rewards' },
    'claim_rewards': { name: 'Claim Rewards', category: 'rewards' },
    'claim_bribes': { name: 'Claim Bribes', category: 'rewards' },
    'extend_lock_amount': { name: 'Extend Lock Amount', category: 'staking' },
    'extend_lock_time': { name: 'Extend Lock Time', category: 'staking' },
    'withdraw': { name: 'Withdraw', category: 'defi' },
    'deposit': { name: 'Deposit', category: 'defi' },
    'create_lp': { name: 'Create LP Position', category: 'defi' },
    'provide_liquidity': { name: 'Provide Liquidity', category: 'defi' },
    'tune_amps': { name: 'Tune Amps (TLA Vote)', category: 'governance' },
    'stake': { name: 'Stake Tokens', category: 'staking' },
    'unstake': { name: 'Unstake Tokens', category: 'staking' },
    'bond': { name: 'Bond Tokens', category: 'staking' },
    'unbond': { name: 'Unbond Tokens', category: 'staking' },
    'create_lock': { name: 'Create TLA VP Lock', category: 'staking', description: 'Lock LST ‚Üí VP NFT. time:null = auto-max lock (10x multiplier)' },
    'transfer': { name: 'Transfer Tokens', category: 'token' },
    'send': { name: 'Send Tokens', category: 'token' },
    'vote': { name: 'Vote', category: 'governance' },
    'update_config': { name: 'Update Config', category: 'admin', risk: 'high' },
    'set_item': { name: 'Set Item (Whitelist)', category: 'admin', risk: 'low' },
    'remove_item': { name: 'Remove Item (Delist)', category: 'admin', risk: 'low' },
    'MsgDelegate': { name: 'Delegate to Validator', category: 'staking' },
    'MsgUndelegate': { name: 'Undelegate', category: 'staking' },
    'MsgWithdrawDelegatorReward': { name: 'Withdraw Staking Rewards', category: 'rewards' },
    // Alliance Module Actions (ALLY staking)
    'alliance_delegate': { name: 'Alliance Delegate', category: 'alliance', description: 'Delegate ALLY to validator' },
    'alliance_undelegate': { name: 'Alliance Undelegate', category: 'alliance', description: 'Undelegate ALLY from validator' },
    'alliance_redelegate': { name: 'Alliance Redelegate', category: 'alliance', description: 'Move ALLY stake between validators' },
    'alliance_claim_rewards': { name: 'Alliance Claim Rewards', category: 'alliance', description: 'Claim ALLY staking rewards' }
};

// ========================================
// INITIALIZATION
// ========================================
document.addEventListener('DOMContentLoaded', async () => {
    // Load all member files from all DAOs (cross-reference names)
    await loadAllMemberFiles();
    
    // Load contract registry from GitHub
    await loadRegistry();
    
    // Load proposals from GitHub (source of truth)
    await loadProposalsFromGitHub();
    
    renderRegistry();
    renderProposals();
    updateCounts();
    
    // Check for new proposals beyond what's saved
    checkForNewProposals();
});

// Check if there are new proposals on-chain not yet in our saved data
async function checkForNewProposals() {
    const config = daoConfigs[currentDao];
    if (!config?.active || !config?.proposalModule) return;
    
    // Find highest saved proposal number
    const savedProps = Object.keys(store.proposals)
        .filter(id => id.match(/^[a-z]\d+$/i))
        .map(id => parseInt(id.replace(/\D/g, '')))
        .filter(n => !isNaN(n));
    
    if (savedProps.length === 0) return;
    
    const highestSaved = Math.max(...savedProps);
    const statusEl = document.getElementById('new-props-status');
    
    // Check next few proposal numbers
    let newCount = 0;
    let inProgressCount = 0;
    let lastFound = highestSaved;
    
    for (let i = highestSaved + 1; i <= highestSaved + 5; i++) {
        try {
            const query = btoa(JSON.stringify({ proposal: { proposal_id: i } }));
            const url = `https://terra-lcd.publicnode.com/cosmwasm/wasm/v1/contract/${config.proposalModule}/smart/${query}`;
            const response = await fetch(url);
            
            if (response.ok) {
                const data = await response.json();
                const proposal = data.data?.proposal;
                if (proposal) {
                    lastFound = i;
                    const status = proposal.status?.toLowerCase() || '';
                    if (status === 'open' || status === 'voting' || status === 'pending') {
                        inProgressCount++;
                    } else {
                        newCount++;
                    }
                }
            } else {
                // 404 or 500 means proposal doesn't exist yet
                break;
            }
        } catch (err) {
            break;
        }
    }
    
    // Update UI
    if (statusEl) {
        if (newCount > 0 || inProgressCount > 0) {
            const parts = [];
            if (newCount > 0) parts.push(`${newCount} new prop${newCount > 1 ? 's' : ''} to add`);
            if (inProgressCount > 0) parts.push(`${inProgressCount} in progress`);
            statusEl.innerHTML = `<span class="text-yellow-400">üì¢ ${parts.join(', ')} - <a href="#" onclick="showView('fetch')" class="underline">Fetch to add</a></span>`;
            statusEl.classList.remove('hidden');
        } else {
            statusEl.classList.add('hidden');
        }
    }
}

// Load saved proposals from GitHub (source of truth)
async function loadProposalsFromGitHub() {
    const config = daoConfigs[currentDao];
    if (!config?.propsUrl) {
        console.log('No propsUrl configured for', currentDao);
        // Try localStorage as fallback
        loadFromStorage();
        return false;
    }
    
    try {
        console.log('Loading proposals from GitHub...');
        const response = await fetch(config.propsUrl);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        
        const data = await response.json();
        const proposals = data.proposals || {};
        
        // Mark each proposal with its DAO
        for (const [id, prop] of Object.entries(proposals)) {
            prop.daoId = currentDao;
        }
        
        // Set store to GitHub data
        store.proposals = proposals;
        
        console.log(`‚úÖ Loaded ${Object.keys(proposals).length} proposals from GitHub`);
        
        // Update UI
        renderProposals();
        updateCounts();
        
        // Check for new proposals on chain
        checkForNewProposals();
        
        return true;
    } catch (err) {
        console.error('‚ùå Failed to load proposals from GitHub:', err);
        showToast('‚ö†Ô∏è GitHub unavailable, using local data');
        // Fall back to local storage
        loadFromStorage();
        renderProposals();
        updateCounts();
        return false;
    }
}

// Check if there are new proposals on chain beyond what we have saved
async function checkForNewProposals() {
    const config = daoConfigs[currentDao];
    if (!config.active) return;
    
    // Auto-discover proposal module if needed
    let proposalModule = config.proposalModule;
    if (!proposalModule && config.core) {
        proposalModule = await discoverProposalModule(currentDao);
    }
    if (!proposalModule) return;
    
    // Find highest proposal number we have
    const propNums = Object.keys(store.proposals)
        .map(id => parseInt(id.replace(/\D/g, '')))
        .filter(n => !isNaN(n));
    
    // If no proposals saved, start from 1
    const lastSaved = propNums.length > 0 ? Math.max(...propNums) : 0;
    const statusEl = document.getElementById('new-props-status');
    
    // Try fetching next few proposals to see what exists
    let inProgress = 0;
    let newCompleted = 0;
    let nextNum = lastSaved + 1;
    
    for (let i = 0; i < 5; i++) { // Check up to 5 ahead
        try {
            const query = btoa(JSON.stringify({ proposal: { proposal_id: nextNum } }));
            const url = `https://terra-lcd.publicnode.com/cosmwasm/wasm/v1/contract/${proposalModule}/smart/${query}`;
            const response = await fetch(url);
            
            if (!response.ok) {
                // Proposal doesn't exist yet - we've found the end
                break;
            }
            
            const data = await response.json();
            const proposal = data.data?.proposal;
            
            if (proposal) {
                const status = proposal.status?.toLowerCase() || '';
                if (status === 'open' || status === 'pending') {
                    inProgress++;
                } else {
                    newCompleted++;
                }
                nextNum++;
            }
        } catch (e) {
            // Error fetching - stop checking
            break;
        }
    }
    
    // Update UI with findings
    if (statusEl) {
        if (newCompleted > 0 || inProgress > 0) {
            let msg = [];
            if (newCompleted > 0) msg.push(`${newCompleted} new completed`);
            if (inProgress > 0) msg.push(`${inProgress} in progress`);
            statusEl.innerHTML = `<span class="text-yellow-400">üì¢ ${msg.join(', ')} - <a href="#" onclick="showView('fetch')" class="underline">Fetch to add</a></span>`;
            statusEl.classList.remove('hidden');
        } else {
            statusEl.classList.add('hidden');
        }
    }
    
    console.log(`üìä Proposal check: Last saved A${lastSaved}, found ${newCompleted} new completed, ${inProgress} in progress`);
}

async function loadMembersFromGitHub(customUrl = null) {
    // Legacy function - now calls loadAllMemberFiles
    if (!store.membersLoaded) {
        await loadAllMemberFiles();
    }
}

// Load ALL member files from all DAOs and combine them
async function loadAllMemberFiles() {
    const memberUrls = [
        'https://raw.githubusercontent.com/defipatriot/adao_json_storage/main/members.csv',           // Alliance DAO
        'https://raw.githubusercontent.com/defipatriot/adao_json_storage/main/lion_dao_members.csv', // Lion DAO
        'https://raw.githubusercontent.com/defipatriot/adao_json_storage/main/pixellion_members.csv' // PixelLions
    ];
    
    console.log('üìã Loading member files from all DAOs...');
    
    for (const url of memberUrls) {
        try {
            const response = await fetch(url);
            if (!response.ok) {
                console.warn(`‚ö†Ô∏è Could not load ${url}`);
                continue;
            }
            
            const csv = await response.text();
            const lines = csv.split('\n').slice(1); // Skip header
            let loadedCount = 0;
            
            for (const line of lines) {
                if (!line.trim()) continue;
                
                // Parse CSV (handle quoted fields)
                const match = line.match(/"([^"]+)","([^"]*)","([^"]*)","([^"]*)","([^"]*)"/);
                if (match) {
                    const [, address, name] = match;
                    if (address && address.startsWith('terra')) {
                        // Only add/update if we have a name, or if address doesn't exist yet
                        if (name && name.trim()) {
                            store.members[address] = {
                                address,
                                name: name.trim(),
                                isMember: true
                            };
                            loadedCount++;
                        } else if (!store.members[address]) {
                            // Address exists but no name - still track as member
                            store.members[address] = {
                                address,
                                name: null,
                                isMember: true
                            };
                        }
                    }
                }
            }
            
            console.log(`  ‚úÖ Loaded from ${url.split('/').pop()}: ${loadedCount} named members`);
        } catch (err) {
            console.warn(`‚ö†Ô∏è Error loading ${url}:`, err);
        }
    }
    
    store.membersLoaded = true;
    const namedCount = Object.values(store.members).filter(m => m.name).length;
    console.log(`‚úÖ Total members loaded: ${Object.keys(store.members).length} (${namedCount} with names)`);
}

// Resolve address to get classification
function resolveAddress(addr) {
    if (!addr) return { name: null, type: 'unknown', class: 'text-gray-500' };
    
    // Check validator registry first (for terravaloper addresses)
    if (addr.startsWith('terravaloper') && validatorRegistry[addr]) {
        return {
            name: validatorRegistry[addr].name,
            type: 'validator',
            status: validatorRegistry[addr].status,
            class: validatorRegistry[addr].status === 'active' ? 'text-green-400' : 'text-yellow-400'
        };
    }
    
    // Check contract registry
    if (contractRegistry[addr]) {
        return {
            name: contractRegistry[addr].name,
            type: 'contract',
            class: 'text-green-400'
        };
    }
    
    // Check members
    if (store.members[addr]) {
        const member = store.members[addr];
        if (member.name) {
            // Known DAO member with registered name
            return {
                name: 'DAO Member',
                displayName: member.name,
                type: 'member',
                class: 'text-green-400'
            };
        } else {
            // Member but no name registered
            return {
                name: 'Unknown Member',
                type: 'unknown_member',
                class: 'text-yellow-400'
            };
        }
    }
    
    // Completely unknown address
    return {
        name: 'Unknown',
        type: 'unknown',
        class: 'text-red-400'
    };
}

// ========================================
// FETCH PROPOSAL
// ========================================
async function fetchProposal() {
    const input = document.getElementById('fetch-id');
    const propNum = parseInt(input?.value);
    
    if (!propNum || propNum < 1) {
        alert('Please enter a valid proposal number');
        return;
    }
    
    const config = daoConfigs[currentDao];
    if (!config.active) {
        alert(`${config.name} is coming soon! We're still mapping out the contract structure.`);
        return;
    }
    
    const propId = (config.propPrefix || config.shortName[0]) + propNum; // A1, A2, etc.
    const statusEl = document.getElementById('fetch-status');
    statusEl.classList.remove('hidden');
    statusEl.innerHTML = '<span class="text-yellow-400">‚è≥ Fetching proposal ' + propId + '...</span>';
    
    try {
        // Auto-discover proposal module if not set
        let proposalModuleAddr = config.proposalModule;
        if (!proposalModuleAddr) {
            statusEl.innerHTML = '<span class="text-yellow-400">‚è≥ Discovering proposal module...</span>';
            proposalModuleAddr = await discoverProposalModule(currentDao);
            if (!proposalModuleAddr) {
                throw new Error('Could not find proposal module for this DAO');
            }
        }
        
        statusEl.innerHTML = '<span class="text-yellow-400">‚è≥ Fetching proposal ' + propId + '...</span>';
        
        // Fetch from LCD
        const query = btoa(JSON.stringify({ proposal: { proposal_id: propNum } }));
        const url = `https://terra-lcd.publicnode.com/cosmwasm/wasm/v1/contract/${proposalModuleAddr}/smart/${query}`;
        
        const response = await fetch(url);
        if (!response.ok) throw new Error('Proposal not found (HTTP ' + response.status + ')');
        
        const data = await response.json();
        const proposal = data.data?.proposal;
        
        if (!proposal) throw new Error('Proposal data empty');
        
        statusEl.innerHTML = '<span class="text-yellow-400">‚è≥ Fetching voters...</span>';
        
        // Fetch voters - try LCD first (more reliable), then indexer
        let voters = [];
        
        // Try LCD first
        try {
            console.log('Fetching voters from LCD...');
            const votersQuery = btoa(JSON.stringify({ list_votes: { proposal_id: propNum, limit: 100 } }));
            const votersUrl = `https://terra-lcd.publicnode.com/cosmwasm/wasm/v1/contract/${proposalModuleAddr}/smart/${votersQuery}`;
            const votersRes = await fetch(votersUrl);
            if (votersRes.ok) {
                const votersData = await votersRes.json();
                console.log('LCD voters response:', votersData);
                const votesList = votersData.data?.votes || [];
                console.log('Votes list:', votesList);
                
                voters = votesList.map(v => {
                    const resolved = resolveAddress(v.voter);
                    // Handle different vote formats: could be string "yes" or object {vote: "yes"}
                    let voteValue = 'unknown';
                    if (typeof v.vote === 'string') {
                        voteValue = v.vote.toLowerCase();
                    } else if (v.vote?.vote) {
                        voteValue = v.vote.vote.toLowerCase();
                    } else if (v.vote) {
                        voteValue = String(v.vote).toLowerCase();
                    }
                    
                    return {
                        address: v.voter,
                        name: resolved.displayName || resolved.name,
                        vote: voteValue,
                        power: parseInt(v.power) || 0
                    };
                }).sort((a, b) => b.power - a.power);
                
                console.log(`‚úÖ Loaded ${voters.length} voters from LCD`);
            }
        } catch (e) {
            console.warn('LCD voters fetch failed:', e);
        }
        
        // Fallback: try DAODAO indexer if LCD failed
        if (voters.length === 0) {
            try {
                console.log('Trying DAODAO indexer...');
                const votersUrl = `https://indexer.daodao.zone/terra-phoenix-1/contract/${proposalModuleAddr}/daoProposalSingle/listVotes?proposalId=${propNum}&limit=100`;
                const votersRes = await fetch(votersUrl);
                if (votersRes.ok) {
                    const votersData = await votersRes.json();
                    console.log('Indexer voters response:', votersData);
                    if (Array.isArray(votersData)) {
                        voters = votersData.map(v => {
                            const resolved = resolveAddress(v.voter);
                            return {
                                address: v.voter,
                                name: resolved.displayName || resolved.name,
                                vote: v.vote?.toLowerCase() || 'unknown',
                                power: parseInt(v.power) || 0
                            };
                        }).sort((a, b) => b.power - a.power);
                        console.log(`‚úÖ Loaded ${voters.length} voters from indexer`);
                    }
                }
            } catch (e) {
                console.warn('Indexer voters fetch also failed:', e);
            }
        }
        
        if (voters.length === 0) {
            console.warn('‚ö†Ô∏è No voters loaded from any source');
        }
        
        // Build proposal object
        const status = proposal.status?.charAt(0).toUpperCase() + proposal.status?.slice(1) || 'Unknown';
        
        // Calculate voting outcome
        const votesYes = parseInt(proposal.votes?.yes) || 0;
        const votesNo = parseInt(proposal.votes?.no) || 0;
        const votesAbstain = parseInt(proposal.votes?.abstain) || 0;
        const totalVoted = votesYes + votesNo + votesAbstain;
        const totalPower = parseInt(proposal.total_power) || 0;
        
        // Calculate percentages
        const turnout = totalPower > 0 ? (totalVoted / totalPower * 100) : 0;
        const yesPercent = totalVoted > 0 ? (votesYes / totalVoted * 100) : 0;
        const noPercent = totalVoted > 0 ? (votesNo / totalVoted * 100) : 0;
        const abstainPercent = totalVoted > 0 ? (votesAbstain / totalVoted * 100) : 0;
        
        // Determine outcome
        const quorumThreshold = daoConfigs[currentDao]?.quorum || 10; // Default 10%
        const passThreshold = daoConfigs[currentDao]?.threshold || 50; // Default 50%
        const quorumReached = turnout >= quorumThreshold;
        const thresholdReached = yesPercent > passThreshold;
        
        let outcome = 'unknown';
        let outcomeReason = '';
        if (status.toLowerCase() === 'open') {
            outcome = 'voting';
            outcomeReason = 'Voting in progress';
        } else if (status.toLowerCase() === 'executed') {
            outcome = 'passed';
            outcomeReason = 'Proposal passed and executed';
        } else if (!quorumReached) {
            outcome = 'rejected';
            outcomeReason = `Did not reach quorum (${turnout.toFixed(2)}% < ${quorumThreshold}% needed)`;
        } else if (!thresholdReached) {
            outcome = 'rejected';
            outcomeReason = `Did not reach threshold (${yesPercent.toFixed(2)}% Yes < ${passThreshold}% needed)`;
        } else if (status.toLowerCase() === 'passed') {
            outcome = 'passed';
            outcomeReason = 'Proposal passed, awaiting execution';
        } else if (status.toLowerCase() === 'rejected' || status.toLowerCase() === 'closed') {
            outcome = 'rejected';
            outcomeReason = quorumReached ? 'Rejected by voters' : 'Did not reach quorum';
        }
        
        store.currentFetched = {
            id: propId,
            title: proposal.title || 'Untitled',
            description: proposal.description || '',
            status: status,
            proposer: proposal.proposer,
            votes: {
                yes: votesYes,
                no: votesNo,
                abstain: votesAbstain,
                total: totalVoted
            },
            voting: {
                turnout: turnout,
                yesPercent: yesPercent,
                noPercent: noPercent,
                abstainPercent: abstainPercent,
                quorumReached: quorumReached,
                thresholdReached: thresholdReached,
                quorumThreshold: quorumThreshold,
                passThreshold: passThreshold
            },
            outcome: outcome,
            outcomeReason: outcomeReason,
            totalPower: totalPower,
            voters: voters,
            rawMsgs: proposal.msgs || [],
            decodedActions: decodeRawActions(proposal.msgs || []),
            fetchedAt: new Date().toISOString(),
            executionTx: null,  // Reset - don't carry over from previous fetch
            txHash: null        // Reset TX hash too
        };
        
        // Display result
        displayFetchResult(store.currentFetched);
        statusEl.innerHTML = '<span class="text-green-400">‚úÖ Loaded ' + propId + '</span>';
        
    } catch (err) {
        console.error('Fetch error:', err);
        statusEl.innerHTML = '<span class="text-red-400">‚ùå ' + err.message + '</span>';
        document.getElementById('fetch-result').classList.add('hidden');
    }
}

// ========================================
// EXECUTION TX LOOKUP
// ========================================
async function fetchExecutionTx() {
    const txHash = document.getElementById('tx-hash-input').value.trim();
    if (!txHash) {
        alert('Please enter a TX hash');
        return;
    }
    
    const statusEl = document.getElementById('tx-fetch-status');
    statusEl.classList.remove('hidden');
    statusEl.innerHTML = '<span class="text-blue-400">üîç Fetching TX...</span>';
    
    // Try multiple endpoints (some may have CORS enabled)
    const endpoints = [
        `https://terra-rest.publicnode.com/cosmos/tx/v1beta1/txs/${txHash}`,
        `https://terra-phoenix-lcd.publicnode.com/cosmos/tx/v1beta1/txs/${txHash}`,
        `https://rest.cosmos.directory/terra2/cosmos/tx/v1beta1/txs/${txHash}`,
        `https://phoenix-lcd.terra.dev/cosmos/tx/v1beta1/txs/${txHash}`
    ];
    
    let data = null;
    let lastError = null;
    
    for (const url of endpoints) {
        try {
            statusEl.innerHTML = `<span class="text-blue-400">üîç Trying ${new URL(url).hostname}...</span>`;
            const response = await fetch(url, {
                headers: { 'Accept': 'application/json' }
            });
            
            if (response.ok) {
                data = await response.json();
                break;
            }
        } catch (err) {
            lastError = err;
            console.log('Endpoint failed:', url, err.message);
        }
    }
    
    if (!data) {
        // If all endpoints fail, show manual entry option
        statusEl.innerHTML = `
            <div class="text-yellow-400">‚ö†Ô∏è CORS blocked - LCD endpoints don't allow browser requests</div>
            <div class="text-gray-400 text-xs mt-2">
                Alternative: Copy event logs from <a href="https://chainsco.pe/terra2/tx/${txHash}" target="_blank" class="text-purple-400 hover:underline">Chainscope</a> 
                and paste below:
            </div>
        `;
        document.getElementById('manual-tx-input').classList.remove('hidden');
        return;
    }
    
    try {
        const tx = data.tx_response;
        
        if (!tx) {
            throw new Error('Invalid TX response');
        }
        
        // Parse events
        const treasuryAddress = daoConfigs[currentDao]?.treasury || '';
        const events = parseExecutionEvents(tx.logs || [], treasuryAddress);
        
        // Display results
        displayExecutionResults(tx, events, txHash);
        statusEl.innerHTML = '<span class="text-green-400">‚úÖ TX loaded</span>';
        
    } catch (err) {
        console.error('TX parse error:', err);
        statusEl.innerHTML = '<span class="text-red-400">‚ùå ' + err.message + '</span>';
        document.getElementById('tx-result').classList.add('hidden');
    }
}

// Parse manually pasted event logs from Chainscope
function parseManualTxLogs() {
    const logsText = document.getElementById('manual-tx-logs').value.trim();
    if (!logsText) {
        alert('Please paste the event logs');
        return;
    }
    
    const txHash = document.getElementById('tx-hash-input').value.trim();
    const treasuryAddress = daoConfigs[currentDao]?.treasury || '';
    
    // Parse the Chainscope text format
    const events = parseChainScopeText(logsText, treasuryAddress);
    
    // Create a mock tx object for display
    const mockTx = {
        code: 0,
        height: 'N/A (manual)'
    };
    
    displayExecutionResults(mockTx, events, txHash);
    document.getElementById('manual-tx-input').classList.add('hidden');
    document.getElementById('tx-fetch-status').innerHTML = '<span class="text-green-400">‚úÖ Logs parsed manually</span>';
}

// Parse Chainscope's text-based event log format
function parseChainScopeText(text, treasuryAddress) {
    const result = {
        received: [],
        sent: [],
        allEvents: []
    };
    
    // Split by event markers like [0], [1], etc.
    const eventBlocks = text.split(/\[(\d+)\]\s*/);
    
    let currentEvent = null;
    
    for (let i = 1; i < eventBlocks.length; i += 2) {
        const index = parseInt(eventBlocks[i]);
        const content = eventBlocks[i + 1] || '';
        
        // Parse event type (first word after index)
        const lines = content.trim().split('\n');
        const eventType = lines[0]?.trim() || 'unknown';
        
        const attrs = {};
        
        // Parse attributes (key\tvalue or key:value format)
        for (let j = 1; j < lines.length; j++) {
            const line = lines[j].trim();
            // Try tab-separated first
            let parts = line.split('\t');
            if (parts.length < 2) {
                // Try colon-separated
                const colonIdx = line.indexOf(':');
                if (colonIdx > 0) {
                    parts = [line.slice(0, colonIdx), line.slice(colonIdx + 1)];
                }
            }
            if (parts.length >= 2) {
                const key = parts[0].trim();
                const value = parts.slice(1).join(':').trim();
                if (key && value) {
                    attrs[key] = value;
                }
            }
        }
        
        result.allEvents.push({
            index: index,
            type: eventType,
            attrs: attrs
        });
        
        // Track transfers to/from treasury
        if (eventType === 'transfer' || eventType === 'coin_received' || eventType === 'coin_spent') {
            const amount = attrs.amount || '';
            const recipient = attrs.recipient || attrs.receiver || '';
            const sender = attrs.sender || attrs.spender || '';
            
            const parsed = parseChainScopeAmount(amount);
            
            if (recipient && treasuryAddress && recipient.toLowerCase().includes(treasuryAddress.slice(0, 20).toLowerCase())) {
                result.received.push({
                    token: parsed.token,
                    amount: parsed.amount,
                    from: sender,
                    raw: amount
                });
            }
            
            if (sender && treasuryAddress && sender.toLowerCase().includes(treasuryAddress.slice(0, 20).toLowerCase())) {
                result.sent.push({
                    token: parsed.token,
                    amount: parsed.amount,
                    to: recipient,
                    raw: amount
                });
            }
        }
        
        // Track CW20 transfers
        if (eventType === 'wasm') {
            const action = attrs.action;
            if (action === 'transfer' || action === 'send') {
                const rawAmount = attrs.amount || '0';
                const amount = parseInt(rawAmount.replace(/,/g, '')) / 1e6;
                const to = attrs.to || attrs.recipient || '';
                const from = attrs.from || attrs.sender || '';
                const contract = attrs._contract_address || '';
                
                const tokenName = contract || 'Token';
                
                if (to && treasuryAddress && to.toLowerCase().includes(treasuryAddress.slice(0, 20).toLowerCase())) {
                    result.received.push({
                        token: tokenName,
                        amount: amount,
                        from: from,
                        raw: `${amount} ${tokenName}`
                    });
                }
                
                if (from && treasuryAddress && from.toLowerCase().includes(treasuryAddress.slice(0, 20).toLowerCase())) {
                    result.sent.push({
                        token: tokenName,
                        amount: amount,
                        to: to,
                        raw: `${amount} ${tokenName}`
                    });
                }
            }
            
            // Track mints (e.g., bonding CAPA ‚Üí ampCAPA)
            if (action === 'mint') {
                const rawAmount = attrs.amount || '0';
                const amount = parseInt(rawAmount.replace(/,/g, '')) / 1e6;
                const to = attrs.to || attrs.recipient || '';
                const contract = attrs._contract_address || '';
                
                const tokenName = contract || 'Token';
                
                if (to && treasuryAddress && to.toLowerCase().includes(treasuryAddress.slice(0, 20).toLowerCase())) {
                    result.received.push({
                        token: tokenName,
                        amount: amount,
                        from: 'minted',
                        raw: `${amount} ${tokenName}`
                    });
                }
            }
        }
    }
    
    // Deduplicate
    result.received = dedupeTransfers(result.received);
    result.sent = dedupeTransfers(result.sent);
    
    return result;
}

// Parse Chainscope amount format like "9,452.359132 ASTRO" or "474694217uluna"
function parseChainScopeAmount(amountStr) {
    if (!amountStr) return { token: 'Unknown', amount: 0 };
    
    // Handle "9,452.359132 ASTRO" format
    const match1 = amountStr.match(/^([\d,\.]+)\s+(.+)$/);
    if (match1) {
        const amount = parseFloat(match1[1].replace(/,/g, ''));
        const token = match1[2].trim();
        return { token: token, amount: amount };
    }
    
    // Handle "474694217uluna" format
    const match2 = amountStr.match(/^(\d+)([a-zA-Z].*)$/);
    if (match2) {
        let amount = parseInt(match2[1]);
        let denom = match2[2];
        
        if (denom.startsWith('u') || denom.startsWith('ibc/')) {
            amount = amount / 1e6;
        }
        
        denom = formatDenom(denom);
        return { token: denom, amount: amount };
    }
    
    return { token: 'Unknown', amount: 0 };
}

function parseExecutionEvents(logs, treasuryAddress) {
    const result = {
        received: [],  // Tokens received by treasury
        sent: [],      // Tokens sent from treasury
        allEvents: []  // All parsed events
    };
    
    // Handle both old log format and new events format
    const events = [];
    if (Array.isArray(logs)) {
        logs.forEach(log => {
            if (log.events) {
                events.push(...log.events);
            } else if (log.type) {
                events.push(log);
            }
        });
    }
    
    events.forEach((event, idx) => {
        const eventType = event.type;
        const attrs = {};
        
        // Parse attributes
        (event.attributes || []).forEach(attr => {
            const key = attr.key;
            const value = attr.value;
            attrs[key] = value;
        });
        
        result.allEvents.push({
            index: idx,
            type: eventType,
            attrs: attrs
        });
        
        // Track coin transfers to/from treasury
        if (eventType === 'transfer' || eventType === 'coin_received' || eventType === 'coin_spent') {
            const amount = attrs.amount || '';
            const recipient = attrs.recipient || attrs.receiver || '';
            const sender = attrs.sender || attrs.spender || '';
            
            // Parse amount (handle both "1000uluna" and "1000 LUNA" formats)
            const parsed = parseAmountString(amount);
            
            if (recipient && recipient.toLowerCase() === treasuryAddress.toLowerCase()) {
                result.received.push({
                    token: parsed.token,
                    amount: parsed.amount,
                    from: sender,
                    raw: amount
                });
            }
            
            if (sender && sender.toLowerCase() === treasuryAddress.toLowerCase()) {
                result.sent.push({
                    token: parsed.token,
                    amount: parsed.amount,
                    to: recipient,
                    raw: amount
                });
            }
        }
        
        // Track CW20 transfers
        if (eventType === 'wasm') {
            const action = attrs.action;
            if (action === 'transfer' || action === 'send') {
                const amount = parseInt(attrs.amount || '0') / 1e6;
                const to = attrs.to || attrs.recipient || '';
                const from = attrs.from || attrs.sender || '';
                const contract = attrs._contract_address || '';
                
                // Try to get token name from contract registry
                const tokenName = contractRegistry[contract]?.name || contract.slice(0, 10) + '...';
                
                if (to.toLowerCase() === treasuryAddress.toLowerCase()) {
                    result.received.push({
                        token: tokenName,
                        amount: amount,
                        from: from,
                        raw: `${amount} ${tokenName}`
                    });
                }
                
                if (from.toLowerCase() === treasuryAddress.toLowerCase()) {
                    result.sent.push({
                        token: tokenName,
                        amount: amount,
                        to: to,
                        raw: `${amount} ${tokenName}`
                    });
                }
            }
            
            // Track mints (e.g., when bonding to get ampTokens)
            if (action === 'mint') {
                const amount = parseInt(attrs.amount || '0') / 1e6;
                const to = attrs.to || attrs.recipient || '';
                const contract = attrs._contract_address || '';
                
                // Get token name - prefer tokenNameOverrides for CW20s
                const tokenName = tokenNameOverrides[contract] || contractRegistry[contract]?.name || contract.slice(0, 10) + '...';
                
                if (to.toLowerCase() === treasuryAddress.toLowerCase()) {
                    result.received.push({
                        token: tokenName,
                        amount: amount,
                        from: 'minted',
                        raw: `${amount} ${tokenName}`
                    });
                }
            }
        }
    });
    
    // Deduplicate (transfers often appear in multiple event types)
    result.received = dedupeTransfers(result.received);
    result.sent = dedupeTransfers(result.sent);
    
    return result;
}

function parseAmountString(amountStr) {
    if (!amountStr) return { token: 'Unknown', amount: 0 };
    
    // Handle "1000uluna" or "1000factory/terra.../ampCAPA" format
    const match1 = amountStr.match(/^(\d+)([a-zA-Z].*)$/);
    if (match1) {
        let amount = parseInt(match1[1]);
        let denom = match1[2];
        
        // Convert micro units - all native/ibc/factory tokens use 6 decimals
        if (denom.startsWith('u') || denom.startsWith('ibc/') || denom.startsWith('factory/')) {
            amount = amount / 1e6;
        }
        
        // Format denom
        denom = formatDenom(denom);
        
        return { token: denom, amount: amount };
    }
    
    // Handle "1,000 LUNA" format (already human-readable)
    const match2 = amountStr.match(/^([\d,\.]+)\s+(.+)$/);
    if (match2) {
        const amount = parseFloat(match2[1].replace(/,/g, ''));
        const token = match2[2] || 'Unknown';
        return { token: token, amount: amount };
    }
    
    return { token: 'Unknown', amount: 0 };
}

function dedupeTransfers(transfers) {
    const seen = new Map();
    transfers.forEach(t => {
        const key = `${t.token}-${t.amount.toFixed(2)}`;
        if (!seen.has(key)) {
            seen.set(key, t);
        }
    });
    return Array.from(seen.values());
}

function displayExecutionResults(tx, events, txHash) {
    document.getElementById('tx-result').classList.remove('hidden');
    
    // Set explorer link
    document.getElementById('tx-explorer-link').href = `https://chainsco.pe/terra2/tx/${txHash}`;
    
    // Status
    const success = tx.code === 0 || tx.code === undefined;
    document.getElementById('tx-status').textContent = success ? '‚úÖ Success' : '‚ùå Failed';
    document.getElementById('tx-status').className = success ? 'text-green-400 font-medium' : 'text-red-400 font-medium';
    
    // Block
    document.getElementById('tx-block').textContent = tx.height || '-';
    
    // Filter out receipt tokens (zLUNA is just an intermediate token)
    const receiptTokens = ['ZLUNA', 'ZLUN'];
    const filterReceipts = (items) => items.filter(t => {
        const name = formatTokenName(t.token).toUpperCase();
        return !receiptTokens.some(rt => name.includes(rt));
    });
    
    const filteredReceived = filterReceipts(events.received);
    const filteredSent = filterReceipts(events.sent);
    const hiddenCount = events.received.length + events.sent.length - filteredReceived.length - filteredSent.length;
    
    // Treasury Received
    const receivedEl = document.getElementById('tx-treasury-received');
    if (filteredReceived.length === 0) {
        receivedEl.innerHTML = '<div class="text-gray-600 text-sm">No tokens received</div>';
    } else {
        receivedEl.innerHTML = filteredReceived.map(t => `
            <div class="flex justify-between items-center bg-green-500/10 rounded px-3 py-2">
                <span class="text-green-400 font-medium">+${t.amount.toLocaleString(undefined, {maximumFractionDigits: 6})} ${formatTokenName(t.token)}</span>
                ${t.from ? `<span class="text-gray-500 text-xs">from ${t.from.slice(0, 12)}...</span>` : ''}
            </div>
        `).join('');
    }
    
    // Treasury Sent
    const sentEl = document.getElementById('tx-treasury-sent');
    if (filteredSent.length === 0) {
        sentEl.innerHTML = '<div class="text-gray-600 text-sm">No tokens sent</div>';
    } else {
        sentEl.innerHTML = filteredSent.map(t => `
            <div class="flex justify-between items-center bg-red-500/10 rounded px-3 py-2">
                <span class="text-red-400 font-medium">-${t.amount.toLocaleString(undefined, {maximumFractionDigits: 6})} ${formatTokenName(t.token)}</span>
                ${t.to ? `<span class="text-gray-500 text-xs">to ${t.to.slice(0, 12)}...</span>` : ''}
            </div>
        `).join('');
    }
    
    // Note about hidden receipt tokens
    if (hiddenCount > 0) {
        const noteEl = document.createElement('div');
        noteEl.className = 'text-gray-500 text-xs mt-2 italic';
        noteEl.textContent = `‚ÑπÔ∏è ${hiddenCount} intermediate token transfer(s) hidden (zLUNA receipt tokens)`;
        receivedEl.parentElement.appendChild(noteEl);
    }
    
    // All Events
    document.getElementById('tx-event-count').textContent = events.allEvents.length;
    const eventsEl = document.getElementById('tx-events');
    eventsEl.innerHTML = events.allEvents.map(e => {
        const attrStr = Object.entries(e.attrs)
            .map(([k, v]) => `<span class="text-gray-500">${k}:</span> <span class="text-gray-300">${v?.slice(0, 40)}${v?.length > 40 ? '...' : ''}</span>`)
            .join(', ');
        return `
            <div class="bg-white/5 rounded p-2">
                <span class="text-purple-400">[${e.index}]</span>
                <span class="text-yellow-400">${e.type}</span>
                <div class="text-gray-400 mt-1">${attrStr}</div>
            </div>
        `;
    }).join('');
}

function decodeRawActions(rawMsgs) {
    return rawMsgs.map((msg, idx) => {
        const decoded = {
            index: idx + 1,
            type: null,
            action: null,
            actionName: null,
            contract: null,
            contractName: null,
            contractClass: 'text-gray-500',
            contractType: 'unknown',
            funds: null,
            params: null
        };
        
        if (msg.wasm?.execute) {
            decoded.type = 'wasm';
            decoded.contract = msg.wasm.execute.contract_addr;
            
            // Resolve contract address
            const resolved = resolveAddress(decoded.contract);
            decoded.contractName = resolved.name;
            decoded.contractClass = resolved.class;
            decoded.contractType = resolved.type;
            if (resolved.displayName) decoded.contractDisplayName = resolved.displayName;
            
            // Decode message
            let msgData = msg.wasm.execute.msg;
            if (typeof msgData === 'string') {
                try {
                    msgData = JSON.parse(atob(msgData));
                } catch (e) {
                    msgData = {};
                }
            }
            
            decoded.action = Object.keys(msgData)[0] || 'unknown';
            decoded.actionName = actionRegistry[decoded.action]?.name || decoded.action;
            decoded.params = msgData[decoded.action];
            
            // Detect LP type from post_action
            if (decoded.action === 'create_lp' && decoded.params?.post_action) {
                if (decoded.params.post_action.liquid_stake) {
                    decoded.lpType = 'compounding';
                    decoded.lpTypeLabel = 'üîÑ Auto-Compounding';
                } else if (decoded.params.post_action.stake) {
                    decoded.lpType = 'non-compounding';
                    decoded.lpTypeLabel = 'üì• Non-Compounding';
                } else {
                    decoded.lpType = 'unknown';
                    decoded.lpTypeLabel = '‚ùì Unknown LP Type';
                }
            }
            
            // Parse funds
            if (msg.wasm.execute.funds?.length > 0) {
                decoded.funds = msg.wasm.execute.funds.map(f => ({
                    amount: parseInt(f.amount) / 1e6,
                    denom: formatDenom(f.denom)
                }));
            }
            
        } else if (msg.bank?.send) {
            decoded.type = 'bank';
            decoded.action = 'send';
            decoded.actionName = 'Bank Send';
            decoded.contract = msg.bank.send.to_address;
            
            // Resolve recipient address
            const resolved = resolveAddress(decoded.contract);
            decoded.contractName = resolved.name;
            decoded.contractClass = resolved.class;
            decoded.contractType = resolved.type;
            if (resolved.displayName) decoded.contractDisplayName = resolved.displayName;
            
            if (msg.bank.send.amount?.length > 0) {
                decoded.funds = msg.bank.send.amount.map(f => ({
                    amount: parseInt(f.amount) / 1e6,
                    denom: formatDenom(f.denom)
                }));
            }
            
        } else if (msg.stargate) {
            decoded.type = 'stargate';
            decoded.action = msg.stargate.typeUrl?.split('.').pop() || 'stargate';
            decoded.actionName = actionRegistry[decoded.action]?.name || decoded.action;
            decoded.params = msg.stargate.value;
            decoded.contractName = decoded.actionName;
            decoded.contractClass = 'text-blue-400';
            decoded.contractType = 'stargate';
        }
        
        return decoded;
    });
}

function displayFetchResult(prop) {
    document.getElementById('fetch-result').classList.remove('hidden');
    
    document.getElementById('result-id').textContent = prop.id;
    document.getElementById('result-title').textContent = prop.title;
    document.getElementById('result-description').textContent = prop.description || 'No description';
    
    const statusEl = document.getElementById('result-status');
    statusEl.textContent = prop.status;
    statusEl.className = 'px-2 py-0.5 rounded text-xs font-medium status-' + prop.status.toLowerCase();
    
    document.getElementById('result-yes').textContent = prop.votes.yes.toLocaleString();
    document.getElementById('result-no').textContent = prop.votes.no.toLocaleString();
    document.getElementById('result-abstain').textContent = prop.votes.abstain.toLocaleString();
    document.getElementById('result-voters').textContent = prop.voters.length;
    
    // Display outcome
    const outcomeEl = document.getElementById('result-outcome');
    const outcomeIcon = document.getElementById('result-outcome-icon');
    const outcomeText = document.getElementById('result-outcome-text');
    const outcomeReason = document.getElementById('result-outcome-reason');
    
    if (prop.outcome === 'passed') {
        outcomeEl.className = 'mb-6 p-4 rounded-lg bg-green-500/10 border border-green-500/30';
        outcomeIcon.textContent = '‚úÖ';
        outcomeText.textContent = 'PASSED';
        outcomeText.className = 'font-bold text-green-400';
    } else if (prop.outcome === 'rejected') {
        outcomeEl.className = 'mb-6 p-4 rounded-lg bg-red-500/10 border border-red-500/30';
        outcomeIcon.textContent = '‚ùå';
        outcomeText.textContent = 'REJECTED';
        outcomeText.className = 'font-bold text-red-400';
    } else if (prop.outcome === 'voting') {
        outcomeEl.className = 'mb-6 p-4 rounded-lg bg-blue-500/10 border border-blue-500/30';
        outcomeIcon.textContent = 'üó≥Ô∏è';
        outcomeText.textContent = 'VOTING';
        outcomeText.className = 'font-bold text-blue-400';
    } else {
        outcomeEl.className = 'mb-6 p-4 rounded-lg bg-gray-500/10 border border-gray-500/30';
        outcomeIcon.textContent = '‚ùì';
        outcomeText.textContent = 'UNKNOWN';
        outcomeText.className = 'font-bold text-gray-400';
    }
    
    outcomeReason.textContent = prop.outcomeReason || '';
    
    // Display voting percentages
    if (prop.voting) {
        document.getElementById('result-turnout').textContent = prop.voting.turnout.toFixed(2) + '%';
        document.getElementById('result-yes-pct').textContent = prop.voting.yesPercent.toFixed(2) + '%';
        document.getElementById('result-no-pct').textContent = prop.voting.noPercent.toFixed(2) + '%';
        document.getElementById('result-abstain-pct').textContent = prop.voting.abstainPercent.toFixed(2) + '%';
        
        const quorumStatus = document.getElementById('result-quorum-status');
        if (prop.voting.quorumReached) {
            quorumStatus.textContent = `(‚úì quorum met, needed ${prop.voting.quorumThreshold}%)`;
            quorumStatus.className = 'text-green-500 text-xs';
        } else {
            quorumStatus.textContent = `(‚úó below ${prop.voting.quorumThreshold}% quorum)`;
            quorumStatus.className = 'text-red-500 text-xs';
        }
    }
    
    document.getElementById('result-action-count').textContent = prop.decodedActions.length;
    
    // Render actions
    const actionsEl = document.getElementById('result-actions');
    if (prop.decodedActions.length === 0) {
        actionsEl.innerHTML = '<div class="text-gray-600 text-sm">No actions in this proposal</div>';
    } else {
        actionsEl.innerHTML = prop.decodedActions.map(a => {
            // Determine icon based on type
            let icon = '‚úÖ';
            if (a.contractType === 'unknown') icon = '‚ùå';
            else if (a.contractType === 'unknown_member') icon = '‚ö†Ô∏è';
            else if (a.contractType === 'stargate') icon = 'üåê';
            
            // Build name display
            let nameDisplay = a.contractName;
            if (a.contractDisplayName) {
                nameDisplay = `${a.contractName} (${a.contractDisplayName})`;
            }
            
            return `
                <div class="bg-white/5 rounded-lg p-3">
                    <div class="flex items-center gap-2 mb-1">
                        <span class="text-purple-400 font-medium">${a.actionName}</span>
                        <span class="text-gray-600">‚Üí</span>
                        <span class="${a.contractClass}">${icon} ${nameDisplay}</span>
                    </div>
                    ${a.funds ? `<div class="text-yellow-400 text-xs">üí∞ ${a.funds.map(f => f.amount.toLocaleString() + ' ' + f.denom).join(', ')}</div>` : ''}
                    ${a.contract ? `
                    <div class="flex items-center gap-2 mt-1">
                        <span class="text-gray-600 text-xs mono">${a.contract}</span>
                        <button onclick="copyText('${a.contract}')" class="text-gray-600 hover:text-white text-xs px-1 rounded bg-white/5">üìã</button>
                    </div>
                    ` : ''}
                </div>
            `;
        }).join('');
    }
    
    // Show execution TX link for executed proposals
    const executionLinkEl = document.getElementById('result-execution-link');
    const executionDataEl = document.getElementById('result-execution-data');
    
    if (prop.status?.toLowerCase() === 'executed') {
        // Check if execution data already exists
        if (prop.executionTx) {
            executionLinkEl.classList.add('hidden');
            executionDataEl.classList.remove('hidden');
            displayLinkedExecutionResults(prop.executionTx);
        } else {
            executionLinkEl.classList.remove('hidden');
            executionDataEl.classList.add('hidden');
            document.getElementById('result-tx-hash').value = '';
            document.getElementById('result-tx-status').classList.add('hidden');
        }
    } else {
        executionLinkEl.classList.add('hidden');
        executionDataEl.classList.add('hidden');
    }
}

// Link execution TX to current fetched proposal
async function linkExecutionTx() {
    const txHash = document.getElementById('result-tx-hash').value.trim();
    if (!txHash) {
        alert('Please enter a TX hash');
        return;
    }
    
    const statusEl = document.getElementById('result-tx-status');
    statusEl.classList.remove('hidden');
    statusEl.innerHTML = '<span class="text-blue-400">üîç Fetching TX...</span>';
    
    const endpoints = [
        `https://terra-rest.publicnode.com/cosmos/tx/v1beta1/txs/${txHash}`,
        `https://terra-phoenix-lcd.publicnode.com/cosmos/tx/v1beta1/txs/${txHash}`,
        `https://rest.cosmos.directory/terra2/cosmos/tx/v1beta1/txs/${txHash}`
    ];
    
    let data = null;
    
    for (const url of endpoints) {
        try {
            const response = await fetch(url, { headers: { 'Accept': 'application/json' } });
            if (response.ok) {
                data = await response.json();
                break;
            }
        } catch (err) {
            console.log('Endpoint failed:', url);
        }
    }
    
    if (!data) {
        statusEl.innerHTML = `
            <span class="text-yellow-400">‚ö†Ô∏è CORS blocked. </span>
            <button onclick="showManualTxEntry()" class="text-purple-400 hover:underline">Enter manually</button>
        `;
        return;
    }
    
    try {
        const tx = data.tx_response;
        const treasuryAddress = daoConfigs[currentDao]?.treasury || '';
        
        // Try logs first, then events field as fallback
        const logsData = (tx.logs && tx.logs.length > 0) ? tx.logs : 
                         (tx.events && tx.events.length > 0) ? [{msg_index: 0, events: tx.events}] : [];
        
        const events = parseExecutionEvents(logsData, treasuryAddress);
        
        // Store on current fetched proposal
        store.currentFetched.executionTx = {
            hash: txHash,
            block: tx.height,
            success: tx.code === 0 || tx.code === undefined,
            received: events.received,
            sent: events.sent,
            rawLogs: JSON.stringify(logsData, null, 2),  // Store raw logs for reference
            fetchedAt: new Date().toISOString()
        };
        
        // Display results
        displayLinkedExecutionResults(store.currentFetched.executionTx);
        document.getElementById('result-execution-link').classList.add('hidden');
        document.getElementById('result-execution-data').classList.remove('hidden');
        statusEl.innerHTML = '<span class="text-green-400">‚úÖ Linked!</span>';
        
    } catch (err) {
        statusEl.innerHTML = '<span class="text-red-400">‚ùå ' + err.message + '</span>';
    }
}

function showManualTxEntry() {
    const statusEl = document.getElementById('result-tx-status');
    const txHash = document.getElementById('result-tx-hash').value.trim();
    statusEl.innerHTML = `
        <div class="mt-3 p-3 rounded bg-purple-500/10 border border-purple-500/30">
            <div class="text-purple-400 text-sm mb-2">üìã Manual Entry</div>
            <div class="text-gray-400 text-xs mb-3">
                1. Go to <a href="https://chainsco.pe/terra2/tx/${txHash || 'TX_HASH'}" target="_blank" class="text-purple-400 hover:underline">Chainscope TX page</a><br>
                2. Scroll to "event logs" section<br>
                3. Select all text from "[0] message" to the end<br>
                4. Paste below:
            </div>
            <textarea id="manual-execution-logs" rows="6" placeholder="[0] message
action    /cosmwasm.wasm.v1.MsgExecuteContract
sender    terra1vjgada9t78eh4v8whp9p8cg4evq4erusx9w6w8
..."
                class="w-full bg-white/5 border border-white/10 rounded px-3 py-2 text-xs mono text-white mb-2"></textarea>
            <button onclick="parseManualExecutionLogs()" class="px-4 py-2 bg-green-600 hover:bg-green-500 rounded text-sm">
                ‚úÖ Parse & Link
            </button>
        </div>
    `;
}

function parseManualExecutionLogs() {
    const logsText = document.getElementById('manual-execution-logs').value.trim();
    const txHash = document.getElementById('result-tx-hash').value.trim() || 'manual';
    
    if (!logsText) {
        alert('Please paste the event logs');
        return;
    }
    
    const treasuryAddress = daoConfigs[currentDao]?.treasury || '';
    const events = parseChainScopeText(logsText, treasuryAddress);
    
    store.currentFetched.executionTx = {
        hash: txHash,
        block: 'N/A',
        success: true,
        received: events.received,
        sent: events.sent,
        rawLogs: logsText,  // Store raw logs for reference
        fetchedAt: new Date().toISOString()
    };
    
    displayLinkedExecutionResults(store.currentFetched.executionTx);
    document.getElementById('result-execution-link').classList.add('hidden');
    document.getElementById('result-execution-data').classList.remove('hidden');
    document.getElementById('result-tx-status').innerHTML = '<span class="text-green-400">‚úÖ Linked (manual)!</span>';
}

function displayLinkedExecutionResults(execTx) {
    // Set explorer link
    if (execTx.hash && execTx.hash !== 'manual') {
        const explorerLink = document.getElementById('result-execution-explorer');
        explorerLink.href = `https://chainsco.pe/terra2/tx/${execTx.hash}`;
        explorerLink.classList.remove('hidden');
    }
    
    // Filter out receipt tokens (zLUNA is just an intermediate token)
    const receiptTokens = ['ZLUNA', 'ZLUN'];
    const filterReceipts = (items) => {
        if (!items) return [];
        return items.filter(t => {
            const name = formatTokenName(t.token).toUpperCase();
            return !receiptTokens.some(rt => name.includes(rt));
        });
    };
    
    const filteredReceived = filterReceipts(execTx.received);
    const filteredSent = filterReceipts(execTx.sent);
    
    // Treasury Received
    const receivedEl = document.getElementById('result-execution-received');
    if (filteredReceived.length === 0) {
        receivedEl.innerHTML = '<div class="text-gray-600 text-xs">None</div>';
    } else {
        receivedEl.innerHTML = filteredReceived.map(t => `
            <div class="bg-green-500/10 rounded px-2 py-1 text-xs">
                <span class="text-green-400">+${t.amount.toLocaleString(undefined, {maximumFractionDigits: 6})} ${formatTokenName(t.token)}</span>
            </div>
        `).join('');
    }
    
    // Treasury Sent
    const sentEl = document.getElementById('result-execution-sent');
    if (filteredSent.length === 0) {
        sentEl.innerHTML = '<div class="text-gray-600 text-xs">None</div>';
    } else {
        sentEl.innerHTML = filteredSent.map(t => `
            <div class="bg-red-500/10 rounded px-2 py-1 text-xs">
                <span class="text-red-400">-${t.amount.toLocaleString(undefined, {maximumFractionDigits: 6})} ${formatTokenName(t.token)}</span>
            </div>
        `).join('');
    }
}

function saveProposal() {
    if (!store.currentFetched) {
        alert('No proposal to save');
        return;
    }
    
    // Calculate and store treasury impact
    const propWithImpact = { 
        ...store.currentFetched,
        daoId: currentDao,
        treasuryImpact: calculateTreasuryImpact(store.currentFetched)
    };
    
    store.proposals[store.currentFetched.id] = propWithImpact;
    saveToStorage();
    updateCounts();
    alert('‚úÖ Saved ' + store.currentFetched.id);
}

// ========================================
// VIEWS
// ========================================
function showView(view) {
    document.querySelectorAll('.view-content').forEach(el => el.classList.add('hidden'));
    document.querySelectorAll('.nav-item').forEach(el => el.classList.remove('active'));
    
    document.getElementById('view-' + view).classList.remove('hidden');
    event.target.closest('.nav-item').classList.add('active');
    
    const titles = {
        fetch: ['Fetch Proposal', 'Load proposal data from chain'],
        autofetch: ['Auto-Fetch All', 'Fetch all proposals automatically'],
        proposals: ['Saved Proposals', 'All proposals you\'ve fetched'],
        registry: ['Contract Registry', 'Known addresses and names'],
        export: ['Export Data', 'Export for GitHub commit']
    };
    document.getElementById('view-title').textContent = titles[view]?.[0] || view;
    document.getElementById('view-subtitle').textContent = titles[view]?.[1] || '';
    
    if (view === 'proposals') renderProposals();
    if (view === 'registry') renderRegistry();
    if (view === 'export') updateExportStats();
    if (view === 'autofetch') renderAutoFetchResults();
}

// ========================================
// DAO SWITCHING
// ========================================
function switchDao(daoId) {
    const config = daoConfigs[daoId];
    if (!config) return;
    
    // Check if DAO is active
    if (!config.active) {
        alert(`${config.name} is coming soon! We're still mapping out the contract structure.`);
        // Reset dropdown to current active DAO
        document.getElementById('dao-selector').value = currentDao;
        return;
    }
    
    // Save current proposals back to storage
    if (currentDao && store.proposalsByDao[currentDao]) {
        store.proposalsByDao[currentDao] = { ...store.proposals };
    }
    
    currentDao = daoId;
    
    // Load this DAO's proposals from storage
    store.proposals = store.proposalsByDao[daoId] || {};
    
    // Update UI
    document.getElementById('dao-name').textContent = config.name;
    document.getElementById('dao-icon').textContent = config.shortName[0];
    document.getElementById('sidebar-dao').textContent = config.shortName;
    
    // Update icon color
    const colors = {
        'alliancedao': 'from-blue-500 to-purple-600',
        'liondao': 'from-amber-500 to-orange-600',
        'pixelions': 'from-pink-500 to-rose-600'
    };
    document.getElementById('dao-icon').className = `w-9 h-9 rounded-lg bg-gradient-to-br ${colors[daoId] || colors.alliancedao} flex items-center justify-center font-bold text-white`;
    
    // Show/hide nav items based on DAO type
    const isPartnerDao = (daoId === 'liondao' || daoId === 'pixelions');
    document.getElementById('nav-autofetch').classList.toggle('hidden', !isPartnerDao);
    document.getElementById('nav-registry').classList.toggle('hidden', isPartnerDao);  // Hide registry for partner DAOs
    
    // Show/hide export buttons based on DAO type
    const treasuryBtn = document.getElementById('btn-treasury-export');
    const registryBtn = document.getElementById('btn-registry-export');
    const auditBtn = document.getElementById('btn-audit-export');
    if (treasuryBtn) treasuryBtn.classList.toggle('hidden', isPartnerDao);
    if (registryBtn) registryBtn.classList.toggle('hidden', isPartnerDao);
    if (auditBtn) auditBtn.classList.toggle('hidden', isPartnerDao);
    
    // Auto-discover proposal module if needed
    if (!config.proposalModule && config.core) {
        discoverProposalModule(daoId).then(propModule => {
            if (propModule) {
                console.log(`‚úÖ ${config.name} proposal module ready: ${propModule}`);
            }
        });
    }
    
    // Load registry (only Alliance DAO has one)
    if (config.registryUrl) {
        loadRegistry().then(() => {
            renderRegistry();
        });
    } else {
        // Clear registry for DAOs without one
        store.registry = { contracts: {}, lpPools: {} };
        renderRegistry();
    }
    
    // Load proposals from GitHub if we don't have any yet
    if (Object.keys(store.proposals).length === 0 && config.propsUrl) {
        loadProposalsFromGitHub();
    }
    
    renderProposals();
    renderAutoFetchResults();
    
    // Load all member files once (cross-reference)
    if (!store.membersLoaded) {
        loadAllMemberFiles();
    }
    
    // Update counts for this DAO
    updateCounts();
}

// ========================================
// AUTO-FETCH FOR PARTNER DAOs (Lion DAO, PixelLions)
// ========================================
let isAutoFetching = false;

function formatVotingPower(power, daoId) {
    const num = parseInt(power) || 0;
    
    if (daoId === 'liondao') {
        // ROAR: has 6 decimals, display in millions
        const inTokens = num / 1e6;  // Convert from micro
        const inMillions = inTokens / 1e6;  // Then to millions
        if (inMillions >= 1) {
            return inMillions.toFixed(2) + 'M';
        } else if (inMillions >= 0.001) {
            return inMillions.toFixed(3) + 'M';
        } else {
            return (inTokens / 1000).toFixed(2) + 'K';
        }
    } else {
        // PixelLions & Alliance: whole numbers (NFT-based)
        return num.toLocaleString();
    }
}

function getMemberName(address) {
    // Check store.members for the address
    if (store.members[address]) {
        return store.members[address].name || null;
    }
    return null;
}

async function autoFetchAllProposals() {
    if (isAutoFetching) return;
    
    const config = daoConfigs[currentDao];
    if (!config) return;
    
    isAutoFetching = true;
    const btn = document.getElementById('autofetch-btn');
    btn.disabled = true;
    btn.textContent = '‚è≥ Fetching...';
    
    document.getElementById('autofetch-progress').classList.remove('hidden');
    
    // Clear existing proposals
    store.proposals = {};
    
    try {
        // Discover proposal module if needed
        let propModule = config.proposalModule;
        if (!propModule && config.core) {
            document.getElementById('autofetch-status').innerHTML = '<span class="text-yellow-400">üîç Discovering proposal module...</span>';
            propModule = await discoverProposalModule(currentDao);
        }
        
        if (!propModule) {
            throw new Error('Could not find proposal module');
        }
        
        document.getElementById('autofetch-status').innerHTML = '<span class="text-blue-400">üìã Starting auto-fetch...</span>';
        
        let propNum = 1;
        let consecutiveErrors = 0;
        const maxErrors = 3;
        
        while (consecutiveErrors < maxErrors) {
            try {
                document.getElementById('autofetch-status').innerHTML = `<span class="text-blue-400">‚è≥ Fetching A${propNum}...</span>`;
                document.getElementById('autofetch-bar').style.width = `${Math.min(100, propNum * 5)}%`;
                document.getElementById('autofetch-text').textContent = `Proposal A${propNum}...`;
                
                // Fetch proposal data
                const propQuery = btoa(JSON.stringify({ proposal: { proposal_id: propNum } }));
                const propUrl = `https://terra-lcd.publicnode.com/cosmwasm/wasm/v1/contract/${propModule}/smart/${propQuery}`;
                const propRes = await fetch(propUrl);
                
                if (!propRes.ok) {
                    throw new Error(`HTTP ${propRes.status}`);
                }
                
                const propData = await propRes.json();
                const proposal = propData.data?.proposal;
                
                if (!proposal) {
                    throw new Error('No proposal data');
                }
                
                // Fetch voters
                let voters = [];
                try {
                    const votersQuery = btoa(JSON.stringify({ list_votes: { proposal_id: propNum, limit: 100 } }));
                    const votersUrl = `https://terra-lcd.publicnode.com/cosmwasm/wasm/v1/contract/${propModule}/smart/${votersQuery}`;
                    const votersRes = await fetch(votersUrl);
                    
                    if (votersRes.ok) {
                        const votersData = await votersRes.json();
                        const votesList = votersData.data?.votes || [];
                        
                        voters = votesList.map(v => {
                            const memberName = getMemberName(v.voter);
                            let voteValue = 'unknown';
                            if (typeof v.vote === 'string') {
                                voteValue = v.vote.toLowerCase();
                            } else if (v.vote?.vote) {
                                voteValue = v.vote.vote.toLowerCase();
                            }
                            
                            return {
                                address: v.voter,
                                name: memberName,
                                vote: voteValue,
                                power: parseInt(v.power) || 0
                            };
                        }).sort((a, b) => b.power - a.power);
                        
                        // Paginate if needed (100+ voters)
                        while (voters.length > 0 && voters.length % 100 === 0) {
                            const lastVoter = voters[voters.length - 1].address;
                            const moreQuery = btoa(JSON.stringify({ list_votes: { proposal_id: propNum, limit: 100, start_after: lastVoter } }));
                            const moreUrl = `https://terra-lcd.publicnode.com/cosmwasm/wasm/v1/contract/${propModule}/smart/${moreQuery}`;
                            const moreRes = await fetch(moreUrl);
                            
                            if (moreRes.ok) {
                                const moreData = await moreRes.json();
                                const moreVotes = (moreData.data?.votes || []).map(v => {
                                    const memberName = getMemberName(v.voter);
                                    let voteValue = typeof v.vote === 'string' ? v.vote.toLowerCase() : (v.vote?.vote?.toLowerCase() || 'unknown');
                                    return {
                                        address: v.voter,
                                        name: memberName,
                                        vote: voteValue,
                                        power: parseInt(v.power) || 0
                                    };
                                });
                                if (moreVotes.length === 0) break;
                                voters = voters.concat(moreVotes);
                            } else {
                                break;
                            }
                        }
                    }
                } catch (e) {
                    console.warn(`Could not fetch voters for A${propNum}:`, e);
                }
                
                // Store simplified proposal
                store.proposals[`A${propNum}`] = {
                    id: `A${propNum}`,
                    propNum: propNum,
                    title: proposal.title || `Proposal ${propNum}`,
                    status: proposal.status || 'unknown',
                    voters: voters
                };
                
                console.log(`‚úÖ A${propNum}: ${proposal.title} (${voters.length} voters)`);
                consecutiveErrors = 0;
                propNum++;
                
                // Update display every few proposals
                if (propNum % 3 === 0) {
                    updateAutoFetchStats();
                    renderAutoFetchResults();
                }
                
                // Small delay to avoid rate limiting
                await new Promise(r => setTimeout(r, 300));
                
            } catch (e) {
                console.log(`‚ùå A${propNum} not found or error:`, e.message);
                consecutiveErrors++;
                propNum++;
            }
        }
        
        document.getElementById('autofetch-status').innerHTML = `<span class="text-green-400">‚úÖ Done! Fetched ${Object.keys(store.proposals).length} proposals</span>`;
        updateAutoFetchStats();
        renderAutoFetchResults();
        saveToStorage();  // Save to localStorage
        
    } catch (e) {
        document.getElementById('autofetch-status').innerHTML = `<span class="text-red-400">‚ùå Error: ${e.message}</span>`;
        console.error(e);
    }
    
    isAutoFetching = false;
    btn.disabled = false;
    btn.textContent = 'üöÄ Start Auto-Fetch';
    document.getElementById('autofetch-progress').classList.add('hidden');
}

function updateAutoFetchStats() {
    const propCount = Object.keys(store.proposals).length;
    const uniqueVoters = new Set();
    let totalVotes = 0;
    
    Object.values(store.proposals).forEach(p => {
        (p.voters || []).forEach(v => uniqueVoters.add(v.address));
        totalVotes += (p.voters || []).length;
    });
    
    document.getElementById('af-stat-props').textContent = propCount;
    document.getElementById('af-stat-voters').textContent = uniqueVoters.size;
    document.getElementById('af-stat-votes').textContent = totalVotes;
}

function renderAutoFetchResults() {
    const container = document.getElementById('autofetch-results');
    const search = (document.getElementById('af-search')?.value || '').toLowerCase();
    const propList = Object.values(store.proposals).sort((a, b) => (b.propNum || 0) - (a.propNum || 0));
    
    if (propList.length === 0) {
        container.innerHTML = '<div class="text-center text-gray-600 py-8">Click "Start Auto-Fetch" to load all proposals</div>';
        return;
    }
    
    let html = '';
    
    for (const prop of propList) {
        // Filter voters by search
        let voters = prop.voters || [];
        if (search) {
            voters = voters.filter(v => 
                v.address.toLowerCase().includes(search) || 
                (v.name && v.name.toLowerCase().includes(search))
            );
        }
        
        if (search && voters.length === 0) continue;
        
        const statusColor = prop.status === 'executed' ? 'text-green-400' : 
                           prop.status === 'passed' ? 'text-blue-400' :
                           prop.status === 'rejected' ? 'text-red-400' : 
                           prop.status === 'open' ? 'text-yellow-400' : 'text-gray-400';
        
        html += `
            <div class="border-b border-white/5">
                <div class="p-3 bg-white/5 flex items-center justify-between">
                    <div class="flex items-center gap-3">
                        <span class="px-2 py-1 bg-blue-600 rounded font-bold text-sm text-white">${prop.id}</span>
                        <span class="font-medium text-white text-sm">${prop.title}</span>
                        <span class="${statusColor} text-xs uppercase">${prop.status}</span>
                    </div>
                    <span class="text-xs text-gray-500">${voters.length} voters</span>
                </div>
                <div class="divide-y divide-white/5">
                    ${voters.map(v => {
                        const voteColor = v.vote === 'yes' ? 'text-green-400' : v.vote === 'no' ? 'text-red-400' : 'text-gray-400';
                        const voteIcon = v.vote === 'yes' ? '‚úÖ' : v.vote === 'no' ? '‚ùå' : '‚ö™';
                        const displayName = v.name ? `<span class="text-white">${v.name}</span>` : '';
                        const vpFormatted = formatVotingPower(v.power, currentDao);
                        
                        return `
                        <div class="px-4 py-2 flex items-center justify-between hover:bg-white/5 text-sm">
                            <div class="flex items-center gap-3 min-w-0 flex-1">
                                <span class="${voteColor} shrink-0">${voteIcon}</span>
                                <div class="min-w-0">
                                    ${displayName ? `<div>${displayName}</div>` : ''}
                                    <div class="mono text-xs text-gray-500 truncate">${v.address}</div>
                                </div>
                            </div>
                            <span class="text-purple-400 font-medium shrink-0 ml-3">${vpFormatted} VP</span>
                        </div>
                        `;
                    }).join('')}
                </div>
            </div>
        `;
    }
    
    container.innerHTML = html || '<div class="text-center text-gray-600 py-8">No matching results</div>';
}

// ========================================
// EXPORT FUNCTIONS
// ========================================
function updateExportStats() {
    const props = Object.values(store.proposals);
    document.getElementById('export-prop-count').textContent = props.length;
    
    // Partner DAOs don't have audit
    const isPartnerDao = (currentDao === 'liondao' || currentDao === 'pixelions');
    if (isPartnerDao) {
        document.getElementById('export-clean-count').textContent = '-';
    } else {
        const cleanCount = props.filter(p => {
            const audit = auditProposal(p);
            return audit.issues.length === 0;
        }).length;
        document.getElementById('export-clean-count').textContent = cleanCount;
    }
}

function exportProposalsJson() {
    const config = daoConfigs[currentDao];
    const props = Object.values(store.proposals);
    const isPartnerDao = (currentDao === 'liondao' || currentDao === 'pixelions');
    
    let exportData;
    
    if (isPartnerDao) {
        // Simplified export for partner DAOs
        exportData = {
            dao: currentDao,
            daoName: config.name,
            exportedAt: new Date().toISOString(),
            proposalCount: props.length,
            proposals: {}
        };
        
        props.forEach(p => {
            exportData.proposals[p.id] = {
                id: p.id,
                title: p.title,
                status: p.status,
                voters: p.voters
            };
        });
    } else {
        // Full export for Alliance DAO
        exportData = {
            meta: {
                dao: config.name,
                daoId: currentDao,
                exportedAt: new Date().toISOString(),
                version: '1.0.0',
                proposalCount: props.length
            },
            proposals: props.map(p => {
                const audit = auditProposal(p);
                const risk = calculateRiskScore(p);
                const impact = calculateTreasuryImpact(p);
                
                return {
                    id: p.id,
                    title: p.title,
                    description: p.description,
                    status: p.status,
                    fetchedAt: p.fetchedAt,
                    votes: p.votes,
                    voters: p.voters,
                    totalPower: p.totalPower,
                    actionCount: p.decodedActions?.length || 0,
                    riskScore: risk.score,
                    riskLevel: risk.level,
                    auditStatus: audit.issues.length === 0 ? 'clean' : 'issues',
                    auditIssueCount: audit.issues.length,
                    treasuryImpact: impact.netByToken,
                    decodedActions: p.decodedActions,
                    rawMsgs: p.rawMsgs
                };
            })
        };
    }
    
    const json = JSON.stringify(exportData, null, 2);
    document.getElementById('export-preview').textContent = json;
    downloadJson(json, `${currentDao}_proposals.json`);
}

function exportVotersCSV() {
    const config = daoConfigs[currentDao];
    const props = Object.values(store.proposals);
    
    let csv = 'DAO,Proposal_ID,Title,Status,Voter_Address,Voter_Name,Vote,VP_Raw,VP_Formatted\n';
    
    props.forEach(p => {
        (p.voters || []).forEach(v => {
            const vpFormatted = formatVotingPower(v.power, currentDao);
            csv += `"${config.name}","${p.id}","${(p.title || '').replace(/"/g, '""')}","${p.status}","${v.address}","${v.name || ''}","${v.vote}","${v.power}","${vpFormatted}"\n`;
        });
    });
    
    const blob = new Blob([csv], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${currentDao}_voters.csv`;
    a.click();
    URL.revokeObjectURL(url);
}

function exportTreasuryImpact() {
    const config = daoConfigs[currentDao];
    const props = Object.values(store.proposals);
    
    const exportData = {
        meta: {
            dao: config.name,
            daoId: currentDao,
            exportedAt: new Date().toISOString(),
            version: '1.0.0'
        },
        summary: {},
        byProposal: []
    };
    
    // Aggregate by token
    const totalByToken = {};
    
    props.forEach(p => {
        const impact = calculateTreasuryImpact(p);
        
        exportData.byProposal.push({
            id: p.id,
            title: p.title,
            status: p.status,
            executedAt: p.fetchedAt,
            outflows: impact.outflows,
            inflows: impact.inflows,
            netByToken: impact.netByToken,
            expectedReturns: impact.expectedReturns
        });
        
        // Aggregate
        for (const [token, amount] of Object.entries(impact.netByToken)) {
            if (!totalByToken[token]) totalByToken[token] = 0;
            totalByToken[token] += amount;
        }
    });
    
    exportData.summary = totalByToken;
    
    const json = JSON.stringify(exportData, null, 2);
    document.getElementById('export-preview').textContent = json;
    downloadJson(json, `${currentDao}_treasury_impact.json`);
}

function exportRegistryJson() {
    const exportData = {
        meta: {
            exportedAt: new Date().toISOString(),
            version: '1.0.0'
        },
        contracts: contractRegistry,
        members: store.members
    };
    
    const json = JSON.stringify(exportData, null, 2);
    document.getElementById('export-preview').textContent = json;
    downloadJson(json, `${currentDao}_registry.json`);
}

function exportFullAuditReport() {
    const config = daoConfigs[currentDao];
    const props = Object.values(store.proposals);
    
    const exportData = {
        meta: {
            dao: config.name,
            daoId: currentDao,
            exportedAt: new Date().toISOString(),
            version: '1.0.0'
        },
        summary: {
            totalProposals: props.length,
            byStatus: {},
            byRiskLevel: { low: 0, medium: 0, high: 0 },
            totalTreasuryImpact: {}
        },
        proposals: []
    };
    
    props.forEach(p => {
        const audit = auditProposal(p);
        const risk = calculateRiskScore(p);
        const impact = calculateTreasuryImpact(p);
        const comparison = compareDescribedVsActual(p);
        
        // Update summary
        const status = p.status?.toLowerCase() || 'unknown';
        exportData.summary.byStatus[status] = (exportData.summary.byStatus[status] || 0) + 1;
        exportData.summary.byRiskLevel[risk.level]++;
        
        for (const [token, amount] of Object.entries(impact.netByToken)) {
            if (!exportData.summary.totalTreasuryImpact[token]) {
                exportData.summary.totalTreasuryImpact[token] = 0;
            }
            exportData.summary.totalTreasuryImpact[token] += amount;
        }
        
        exportData.proposals.push({
            id: p.id,
            title: p.title,
            description: p.description,
            status: p.status,
            fetchedAt: p.fetchedAt,
            votes: p.votes,
            voters: p.voters,
            totalPower: p.totalPower,
            riskScore: risk.score,
            riskLevel: risk.level,
            riskFactors: risk.factors,
            auditIssues: audit.issues,
            treasuryImpact: impact,
            describedVsActual: comparison,
            decodedActions: p.decodedActions,
            rawMsgs: p.rawMsgs
        });
    });
    
    const json = JSON.stringify(exportData, null, 2);
    document.getElementById('export-preview').textContent = json;
    downloadJson(json, `${currentDao}_full_audit.json`);
}

function downloadJson(content, filename) {
    const blob = new Blob([content], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    showToast(`Downloaded ${filename}`);
}

function renderProposals() {
    const search = (document.getElementById('search-proposals')?.value || '').toLowerCase();
    const statusFilter = (document.getElementById('filter-status')?.value || '').toLowerCase();
    const outcomeFilter = (document.getElementById('filter-outcome')?.value || '').toLowerCase();
    let props = Object.entries(store.proposals);
    
    // Filter by current DAO
    props = props.filter(([id, p]) => !p.daoId || p.daoId === currentDao);
    
    if (search) {
        props = props.filter(([id, p]) => 
            id.toLowerCase().includes(search) || 
            p.title?.toLowerCase().includes(search) ||
            p.description?.toLowerCase().includes(search)
        );
    }
    
    if (statusFilter) {
        props = props.filter(([id, p]) => p.status?.toLowerCase() === statusFilter);
    }
    
    if (outcomeFilter) {
        props = props.filter(([id, p]) => p.outcome?.toLowerCase() === outcomeFilter);
    }
    
    // Sort by ID descending
    props.sort((a, b) => {
        const numA = parseInt(a[0].replace(/\D/g, '')) || 0;
        const numB = parseInt(b[0].replace(/\D/g, '')) || 0;
        return numB - numA;
    });
    
    const listEl = document.getElementById('proposals-list');
    
    if (props.length === 0) {
        listEl.innerHTML = '<div class="text-gray-600 text-center py-8">No proposals match filters</div>';
        return;
    }
    
    listEl.innerHTML = props.map(([id, p]) => {
        // Run audit
        const audit = auditProposal(p);
        
        // Build audit badge - click to see issues
        let auditBadge = '';
        if (audit.issues.length > 0) {
            const errorCount = audit.issues.filter(i => i.severity === 'error').length;
            const warningCount = audit.issues.filter(i => i.severity === 'warning').length;
            const color = errorCount > 0 ? 'text-red-400' : 'text-yellow-400';
            auditBadge = `<span class="${color} text-xs cursor-pointer hover:underline" onclick="event.stopPropagation(); showIssuesPopup('${id}')" title="Click to view issues">
                ‚ö† ${audit.issues.length} issue${audit.issues.length > 1 ? 's' : ''}
            </span>`;
        } else {
            auditBadge = `<span class="text-green-400 text-xs">‚úÖ Clean</span>`;
        }
        
        // Receipt tokens to filter out (intermediate/mechanics tokens)
        const receiptTokens = ['ZLUNA', 'ZLUN'];
        const isReceiptToken = (t) => {
            const name = formatTokenName(t.token).toUpperCase();
            return receiptTokens.some(rt => name.includes(rt));
        };
        
        // Calculate treasury impact summary for header
        // Prefer actual execution data over proposed if available
        let treasuryBadge = '';
        if (p.executionTx && (p.executionTx.received?.length > 0 || p.executionTx.sent?.length > 0)) {
            // Show actual execution results (filtered)
            const parts = [];
            if (p.executionTx.received?.length > 0) {
                p.executionTx.received.filter(t => !isReceiptToken(t)).forEach(t => {
                    parts.push(`<span class="text-green-400 text-xs">+${t.amount.toLocaleString(undefined, {maximumFractionDigits: 0})} ${formatTokenName(t.token)}</span>`);
                });
            }
            if (p.executionTx.sent?.length > 0) {
                p.executionTx.sent.filter(t => !isReceiptToken(t)).forEach(t => {
                    parts.push(`<span class="text-red-400 text-xs">-${t.amount.toLocaleString(undefined, {maximumFractionDigits: 0})} ${formatTokenName(t.token)}</span>`);
                });
            }
            if (parts.length > 0) {
                treasuryBadge = parts.slice(0, 3).join(' ') + (parts.length > 3 ? ` <span class="text-gray-500 text-xs">+${parts.length - 3} more</span>` : '');
                treasuryBadge += ` <span class="text-purple-400 text-xs">(actual)</span>`;
            } else {
                treasuryBadge = `<span class="text-gray-500 text-xs">Receipt token exchange only</span>`;
            }
        } else {
            // Show proposed impact
            const impact = calculateTreasuryImpact(p);
            const netTokens = Object.entries(impact.netByToken);
            treasuryBadge = netTokens.length > 0 
                ? netTokens.map(([token, amount]) => {
                    const isNeg = amount < 0;
                    return `<span class="${isNeg ? 'text-red-400' : 'text-green-400'} text-xs">${isNeg ? '' : '+'}${amount.toLocaleString()} ${formatTokenName(token)}</span>`;
                }).join(' ')
                : `<span class="text-gray-500 text-xs">No treasury movement</span>`;
        }
        
        // Execution TX linked badge
        const execBadge = p.executionTx ? `<span class="text-purple-400 text-xs">üîó TX</span>` : '';
        
        // Calculate risk score
        const risk = calculateRiskScore(p);
        const riskColors = {
            low: 'bg-green-500/20 text-green-400',
            medium: 'bg-yellow-500/20 text-yellow-400',
            high: 'bg-red-500/20 text-red-400'
        };
        const riskBadge = `<span class="px-2 py-0.5 rounded text-xs ${riskColors[risk.level]}">${risk.score}/100</span>`;
        
        // Outcome badge
        let outcomeBadge = '';
        if (p.outcome === 'passed') {
            outcomeBadge = `<span class="px-2 py-0.5 rounded text-xs bg-green-500/20 text-green-400">‚úÖ Passed</span>`;
        } else if (p.outcome === 'rejected') {
            outcomeBadge = `<span class="px-2 py-0.5 rounded text-xs bg-red-500/20 text-red-400">‚ùå Rejected</span>`;
        } else if (p.outcome === 'voting') {
            outcomeBadge = `<span class="px-2 py-0.5 rounded text-xs bg-blue-500/20 text-blue-400">üó≥Ô∏è Voting</span>`;
        }
        
        // Turnout badge
        const turnoutBadge = p.voting?.turnout 
            ? `<span class="text-xs ${p.voting.quorumReached ? 'text-gray-400' : 'text-red-400'}">${p.voting.turnout.toFixed(1)}% turnout</span>`
            : '';
        
        return `
        <div class="glass rounded-xl overflow-hidden">
            <!-- Header (clickable) -->
            <div class="p-4 cursor-pointer hover:bg-white/5 transition" onclick="toggleProposal('${id}')">
                <div class="flex items-center justify-between">
                    <div class="flex items-center gap-3">
                        <span class="text-xl font-bold text-white">${id}</span>
                        ${outcomeBadge || `<span class="text-xs px-2 py-0.5 rounded status-${p.status?.toLowerCase()}">${p.status}</span>`}
                        ${riskBadge}
                        ${auditBadge}
                        ${turnoutBadge}
                    </div>
                    <div class="flex items-center gap-3">
                        <div class="flex items-center gap-2">${treasuryBadge}</div>
                        <span class="text-gray-500 text-xl transform transition" id="chevron-${id}">‚ñº</span>
                    </div>
                </div>
                <div class="text-white font-medium mt-1">${p.title || 'Untitled'}</div>
                ${p.outcomeReason ? `<div class="text-gray-500 text-xs mt-1">${p.outcomeReason}</div>` : ''}
            </div>
            
            <!-- Expanded Content (hidden by default) -->
            <div id="expand-${id}" class="hidden border-t border-white/10">
                <!-- Description -->
                <div class="p-4 border-b border-white/5">
                    <div class="text-xs text-gray-500 uppercase mb-2">üìù Description</div>
                    <div class="text-gray-300 text-sm whitespace-pre-wrap max-h-48 overflow-auto">${p.description || 'No description provided'}</div>
                </div>
                
                <!-- Meta Info -->
                <div class="p-4 border-b border-white/5 grid grid-cols-3 gap-4">
                    <div>
                        <div class="text-xs text-gray-500 uppercase mb-1">üìÖ Timestamp</div>
                        <div class="text-gray-300 text-sm">${p.fetchedAt ? new Date(p.fetchedAt).toLocaleString() : 'Unknown'}</div>
                    </div>
                    <div>
                        <div class="text-xs text-gray-500 uppercase mb-1">üîó TX Hash</div>
                        ${p.txHash 
                            ? `<a href="https://chainsco.pe/terra2/tx/${p.txHash}" target="_blank" class="text-blue-400 hover:text-blue-300 text-sm mono break-all">${p.txHash.slice(0,20)}...</a>`
                            : `<span class="text-gray-600 text-sm">Not executed yet</span>`
                        }
                    </div>
                    <div>
                        <div class="text-xs text-gray-500 uppercase mb-1">üìã DAODAO Link</div>
                        <button onclick="event.stopPropagation(); openDaodaoPopup('${id}')" 
                                class="text-purple-400 hover:text-purple-300 text-sm">
                            Open Proposal ‚Üó
                        </button>
                    </div>
                </div>
                
                <!-- Vote Breakdown -->
                <div class="p-4 border-b border-white/5">
                    <div class="text-xs text-gray-500 uppercase mb-2">üó≥Ô∏è Vote Breakdown</div>
                    <div class="grid grid-cols-4 gap-3">
                        <div class="bg-white/5 rounded-lg p-3 text-center">
                            <div class="text-green-400 text-xl font-bold">${p.votes?.yes || 0}</div>
                            <div class="text-xs text-gray-500">Yes</div>
                        </div>
                        <div class="bg-white/5 rounded-lg p-3 text-center">
                            <div class="text-red-400 text-xl font-bold">${p.votes?.no || 0}</div>
                            <div class="text-xs text-gray-500">No</div>
                        </div>
                        <div class="bg-white/5 rounded-lg p-3 text-center">
                            <div class="text-gray-400 text-xl font-bold">${p.votes?.abstain || 0}</div>
                            <div class="text-xs text-gray-500">Abstain</div>
                        </div>
                        <div class="bg-white/5 rounded-lg p-3 text-center">
                            <div class="text-cyan-400 text-xl font-bold">${p.totalPower || 0}</div>
                            <div class="text-xs text-gray-500">Total Power</div>
                        </div>
                    </div>
                </div>
                
                <!-- Treasury Impact -->
                <div class="p-4 border-b border-white/5">
                    <div class="flex items-center justify-between mb-2">
                        <div class="text-xs text-gray-500 uppercase">üí∞ Treasury Impact</div>
                        <button onclick="event.stopPropagation(); copyTreasuryImpact('${id}')" class="text-xs px-2 py-1 bg-white/10 hover:bg-white/20 rounded text-gray-400 hover:text-white">üìã Copy</button>
                    </div>
                    ${(() => {
                        const impact = calculateTreasuryImpact(p);
                        
                        if (impact.outflows.length === 0 && impact.inflows.length === 0) {
                            return `<div class="text-gray-600 text-sm">No treasury movement in this proposal</div>`;
                        }
                        
                        let html = '';
                        
                        // Outflows
                        if (impact.outflows.length > 0) {
                            html += `
                            <div class="mb-3">
                                <div class="text-red-400 text-xs font-medium mb-2">üì§ Outflows (Treasury ‚Üí External)</div>
                                <div class="space-y-1">
                                    ${impact.outflows.map(o => `
                                        <div class="flex items-center justify-between py-1 px-2 rounded bg-red-500/10 text-sm">
                                            <div class="flex items-center gap-2">
                                                <span class="text-red-400">-${o.amount.toLocaleString()}</span>
                                                <span class="text-white">${o.token}</span>
                                            </div>
                                            <div class="text-gray-500 text-xs">‚Üí ${o.recipientName || o.recipient?.slice(0,12) + '...'}</div>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                            `;
                        }
                        
                        // Inflows
                        if (impact.inflows.length > 0) {
                            html += `
                            <div class="mb-3">
                                <div class="text-green-400 text-xs font-medium mb-2">üì• Inflows (External ‚Üí Treasury)</div>
                                <div class="space-y-1">
                                    ${impact.inflows.map(i => `
                                        <div class="flex items-center justify-between py-1 px-2 rounded bg-green-500/10 text-sm">
                                            <div class="flex items-center gap-2">
                                                <span class="text-green-400">+${i.amount.toLocaleString()}</span>
                                                <span class="text-white">${i.token}</span>
                                            </div>
                                            <div class="text-gray-500 text-xs">‚Üê ${i.sourceName || 'External'}</div>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                            `;
                        }
                        
                        // Net Summary
                        const netTokens = Object.entries(impact.netByToken);
                        if (netTokens.length > 0) {
                            html += `
                            <div class="mt-3 pt-3 border-t border-white/10">
                                <div class="text-xs text-gray-500 mb-2">Net Impact</div>
                                <div class="flex flex-wrap gap-2">
                                    ${netTokens.map(([token, amount]) => {
                                        const isNegative = amount < 0;
                                        return `
                                        <div class="px-2 py-1 rounded ${isNegative ? 'bg-red-500/20 text-red-400' : 'bg-green-500/20 text-green-400'} text-sm font-medium">
                                            ${isNegative ? '' : '+'}${amount.toLocaleString()} ${token}
                                        </div>
                                        `;
                                    }).join('')}
                                </div>
                            </div>
                            `;
                        }
                        
                        // Expected Returns (inferred)
                        if (impact.expectedReturns && impact.expectedReturns.length > 0) {
                            html += `
                            <div class="mt-3 pt-3 border-t border-white/10">
                                <div class="text-xs text-blue-400 mb-2">üì• Expected Returns (inferred from contract type)</div>
                                <div class="space-y-2">
                                    ${impact.expectedReturns.map(ret => `
                                        <div class="p-2 rounded bg-blue-500/10 border border-blue-500/20">
                                            <div class="flex items-center gap-2">
                                                <span class="text-blue-400 font-medium">+ ${ret.token}</span>
                                            </div>
                                            <div class="text-gray-400 text-xs mt-1">${ret.description}</div>
                                            ${ret.note ? `<div class="text-gray-600 text-xs italic mt-1">${ret.note}</div>` : ''}
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                            `;
                        }
                        
                        return html;
                    })()}
                </div>
                
                <!-- Actual Execution Results (if linked) -->
                ${p.executionTx ? `
                <div class="p-4 border-b border-white/5">
                    <div class="flex items-center justify-between mb-2">
                        <div class="text-xs text-gray-500 uppercase">üìä Actual Execution Results</div>
                        <div class="flex items-center gap-3">
                            <button onclick="event.stopPropagation(); copyExecutionResults('${id}')" 
                                    class="text-xs text-gray-400 hover:text-white transition-colors">üìã Copy</button>
                            ${p.executionTx.rawLogs ? `
                            <button onclick="event.stopPropagation(); copyRawLogs('${id}')" 
                                    class="text-xs text-gray-400 hover:text-white transition-colors">üìÑ Raw Logs</button>
                            ` : ''}
                            <button onclick="event.stopPropagation(); unlinkExecutionTx('${id}')" 
                                    class="text-xs text-red-400 hover:text-red-300 transition-colors">üóëÔ∏è Unlink</button>
                            ${p.executionTx.hash && p.executionTx.hash !== 'manual' ? `
                            <a href="https://chainsco.pe/terra2/tx/${p.executionTx.hash}" target="_blank" 
                               class="text-xs text-purple-400 hover:underline">View TX ‚Üó</a>
                            ` : ''}
                        </div>
                    </div>
                    ${(() => {
                        // Receipt/intermediate tokens to hide (these are just mechanics, not real assets)
                        const receiptTokens = ['ZLUNA', 'ZLUN'];
                        
                        // Check if an address is an internal VP lock (NOT all staking - only explicit locks)
                        const isVPLock = (addr) => {
                            const info = contractRegistry[addr];
                            return info && info.isInternalLock === true;  // Only explicit VP locks
                        };
                        
                        // Check if destination is a staking/deposit contract
                        const isStakingContract = (addr) => {
                            const info = contractRegistry[addr];
                            return info && (info.type === 'staking' || info.type === 'defi' || info.type === 'connector');
                        };
                        
                        // Filter out receipt tokens
                        const filterReceipts = (items) => {
                            if (!items) return [];
                            return items.filter(t => {
                                const tokenName = formatTokenName(t.token).toUpperCase();
                                return !receiptTokens.some(rt => tokenName.includes(rt));
                            });
                        };
                        
                        const filteredReceived = filterReceipts(p.executionTx.received);
                        const allSent = filterReceipts(p.executionTx.sent);
                        
                        // Separate: VP Locked vs Staked vs External
                        const filteredLocked = allSent.filter(t => t.to && isVPLock(t.to));
                        const filteredStaked = allSent.filter(t => t.to && !isVPLock(t.to) && isStakingContract(t.to));
                        const filteredSent = allSent.filter(t => !t.to || (!isVPLock(t.to) && !isStakingContract(t.to)));
                        
                        // Check if we filtered anything
                        const hiddenCount = (p.executionTx.received?.length || 0) + (p.executionTx.sent?.length || 0) 
                                          - filteredReceived.length - allSent.length;
                        
                        const hasReceived = filteredReceived.length > 0;
                        const hasLocked = filteredLocked.length > 0;
                        const hasStaked = filteredStaked.length > 0;
                        const hasSent = filteredSent.length > 0;
                        
                        // Calculate net effect by token
                        const netByToken = {};
                        filteredReceived.forEach(t => {
                            const name = formatTokenName(t.token);
                            netByToken[name] = (netByToken[name] || 0) + t.amount;
                        });
                        allSent.forEach(t => {
                            const name = formatTokenName(t.token);
                            netByToken[name] = (netByToken[name] || 0) - t.amount;
                        });
                        
                        let html = '';
                        
                        // Build display based on what we have
                        const sections = [];
                        
                        // Check if any received are amplp (LP position receipts)
                        const hasAmplp = filteredReceived.some(t => formatTokenName(t.token).toLowerCase().includes('amplp'));
                        
                        if (hasReceived) {
                            sections.push(`
                                <div>
                                    <div class="text-xs text-green-400 mb-2">üì• Received</div>
                                    <div class="space-y-1">
                                        ${filteredReceived.map(t => {
                                            const tokenName = formatTokenName(t.token);
                                            const isAmplp = tokenName.toLowerCase().includes('amplp');
                                            // Parse gauge type from token name for explanation
                                            const isProject = tokenName.includes('(P)');
                                            const isSingle = tokenName.includes('(S)');
                                            const gaugeNote = isProject ? '50% compound' : isSingle ? '100% compound' : '';
                                            return `
                                            <div class="py-1 px-2 rounded bg-green-500/10 text-sm">
                                                <span class="text-green-400">+${t.amount.toLocaleString(undefined, {maximumFractionDigits: 2})} ${tokenName}</span>
                                                ${isAmplp ? `<span class="text-gray-500 text-xs ml-2">(receipt${gaugeNote ? ', ' + gaugeNote : ''})</span>` : ''}
                                            </div>
                                        `}).join('')}
                                    </div>
                                    ${hasAmplp ? '<div class="text-gray-500 text-xs mt-2 italic">‚ÑπÔ∏è amplp = receipt for LP position in Eris Compounder. (P)=Project gauge 50% compound, (S)=Single gauge 100% compound</div>' : ''}
                                </div>
                            `);
                        }
                        
                        if (hasLocked) {
                            sections.push(`
                                <div>
                                    <div class="text-xs text-purple-400 mb-2">üîí Locked (VP)</div>
                                    <div class="space-y-1">
                                        ${filteredLocked.map(t => `
                                            <div class="py-1 px-2 rounded bg-purple-500/10 text-sm">
                                                <span class="text-purple-400">${t.amount.toLocaleString(undefined, {maximumFractionDigits: 2})} ${formatTokenName(t.token)}</span>
                                            </div>
                                        `).join('')}
                                    </div>
                                </div>
                            `);
                        }
                        
                        if (hasStaked) {
                            sections.push(`
                                <div>
                                    <div class="text-xs text-cyan-400 mb-2">üìä Staked/Deposited</div>
                                    <div class="space-y-1">
                                        ${filteredStaked.map(t => {
                                            const destName = contractRegistry[t.to]?.name || 'Staking';
                                            return `
                                            <div class="py-1 px-2 rounded bg-cyan-500/10 text-sm">
                                                <span class="text-cyan-400">${t.amount.toLocaleString(undefined, {maximumFractionDigits: 2})} ${formatTokenName(t.token)}</span>
                                                <span class="text-gray-500 text-xs ml-2">‚Üí ${destName}</span>
                                            </div>
                                        `}).join('')}
                                    </div>
                                </div>
                            `);
                        }
                        
                        if (hasSent) {
                            sections.push(`
                                <div>
                                    <div class="text-xs text-red-400 mb-2">üì§ Sent Out</div>
                                    <div class="space-y-1">
                                        ${filteredSent.map(t => {
                                            // Get destination context
                                            const destInfo = contractRegistry[t.to];
                                            const destContext = destInfo 
                                                ? `‚Üí ${destInfo.name}` 
                                                : t.to ? `‚Üí ${t.to.slice(0, 12)}...` : '';
                                            const destType = destInfo?.type || '';
                                            const destExplain = destType === 'staking' ? '(staking)' 
                                                : destType === 'dex' ? '(LP)' 
                                                : destType === 'compounder' ? '(compounding)'
                                                : destType === 'escrow' ? '(escrow)'
                                                : '';
                                            return `
                                            <div class="py-1 px-2 rounded bg-red-500/10 text-sm flex justify-between items-center gap-2">
                                                <span class="text-red-400">-${t.amount.toLocaleString(undefined, {maximumFractionDigits: 2})} ${formatTokenName(t.token)}</span>
                                                ${destContext ? `<span class="text-gray-500 text-xs">${destContext} ${destExplain}</span>` : ''}
                                            </div>
                                        `}).join('')}
                                    </div>
                                </div>
                            `);
                        }
                        
                        if (sections.length === 0) {
                            if (hiddenCount > 0) {
                                html = `<div class="text-gray-500 text-sm">Only intermediate tokens (zLUNA) - no real asset movement</div>`;
                            } else {
                                html = `<div class="text-gray-600 text-sm">No token movements recorded</div>`;
                            }
                        } else if (sections.length === 1) {
                            html = sections[0];
                        } else {
                            html = `<div class="grid grid-cols-${Math.min(sections.length, 3)} gap-4">${sections.join('')}</div>`;
                        }
                        
                        // Add net effect summary if there were both in and out movements
                        if (hasReceived && (hasLocked || hasStaked || hasSent)) {
                            const netEntries = Object.entries(netByToken).filter(([k, v]) => Math.abs(v) > 0.01);
                            if (netEntries.length > 0) {
                                html += `
                                <div class="mt-3 pt-3 border-t border-white/10">
                                    <div class="text-xs text-gray-400 mb-2">üí∞ Net Effect (Liquid)</div>
                                    <div class="flex flex-wrap gap-2">
                                        ${netEntries.map(([token, amount]) => `
                                            <span class="px-2 py-1 rounded ${amount >= 0 ? 'bg-green-500/10 text-green-400' : 'bg-red-500/10 text-red-400'} text-sm">
                                                ${amount >= 0 ? '+' : ''}${amount.toLocaleString(undefined, {maximumFractionDigits: 2})} ${token}
                                            </span>
                                        `).join('')}
                                    </div>
                                </div>`;
                            }
                        }
                        
                        // Add note about hidden receipt tokens
                        if (hiddenCount > 0) {
                            html += `<div class="text-gray-500 text-xs mt-2 italic">‚ÑπÔ∏è ${hiddenCount} intermediate transfer(s) hidden (receipt tokens)</div>`;
                        }
                        
                        return html;
                    })()}
                    <div class="text-gray-600 text-xs mt-2">Block: ${p.executionTx.block || 'N/A'}</div>
                </div>
                ` : p.status?.toLowerCase() === 'executed' ? `
                <div class="p-4 border-b border-white/5">
                    <div class="text-xs text-gray-500 uppercase mb-2">üìä Actual Execution Results</div>
                    <div class="text-gray-500 text-sm">
                        No execution TX linked. 
                        <button onclick="event.stopPropagation(); promptLinkExecution('${id}')" class="text-purple-400 hover:underline">Link TX</button>
                    </div>
                </div>
                ` : ''}
                
                <!-- Described vs Actual Comparison -->
                <div class="p-4 border-b border-white/5">
                    <div class="text-xs text-gray-500 uppercase mb-2">üìù Description Analysis</div>
                    ${(() => {
                        const comparison = compareDescribedVsActual(p);
                        
                        let html = '<div class="space-y-4">';
                        
                        // What we found in the description
                        html += '<div>';
                        html += '<div class="text-xs text-gray-400 mb-2">Found in description:</div>';
                        
                        const mentions = [];
                        if (comparison.described && comparison.described.length > 0) {
                            comparison.described.forEach(d => {
                                mentions.push(`<span class="px-2 py-1 rounded bg-white/10 text-gray-300 text-sm">${d.amount.toLocaleString()} ${d.token}</span>`);
                            });
                        }
                        if (comparison.lpPairs && comparison.lpPairs.length > 0) {
                            comparison.lpPairs.forEach(lp => {
                                mentions.push(`<span class="px-2 py-1 rounded bg-blue-500/20 text-blue-300 text-sm">LP: ${lp.raw}</span>`);
                            });
                        }
                        
                        if (mentions.length > 0) {
                            html += `<div class="flex flex-wrap gap-2">${mentions.join('')}</div>`;
                        } else {
                            html += '<div class="text-gray-600 text-sm italic">No specific token amounts or LP pairs found</div>';
                        }
                        html += '</div>';
                        
                        // If we have execution data, show what actually happened
                        if (p.executionTx && (comparison.executionReceived?.length > 0 || comparison.executionSent?.length > 0)) {
                            html += '<div class="p-3 rounded bg-white/5 border border-white/10">';
                            html += '<div class="text-xs text-gray-400 mb-3">Actual Execution Results:</div>';
                            
                            // Inflows
                            if (comparison.executionReceived && comparison.executionReceived.length > 0) {
                                html += '<div class="mb-3">';
                                html += '<div class="text-xs text-green-400 mb-1">üì• Received:</div>';
                                html += '<div class="flex flex-wrap gap-2">';
                                comparison.executionReceived.forEach(t => {
                                    const tokenName = formatTokenName(t.token);
                                    const isReceipt = tokenName.toLowerCase().includes('amplp') || tokenName.toLowerCase().includes('zluna');
                                    const bgClass = isReceipt ? 'bg-gray-500/20 text-gray-400' : 'bg-green-500/20 text-green-300';
                                    html += `<span class="px-2 py-1 rounded ${bgClass} text-sm">+${t.amount.toLocaleString(undefined, {maximumFractionDigits: 2})} ${tokenName}</span>`;
                                });
                                html += '</div></div>';
                            }
                            
                            // Outflows  
                            if (comparison.executionSent && comparison.executionSent.length > 0) {
                                html += '<div>';
                                html += '<div class="text-xs text-red-400 mb-1">üì§ Sent:</div>';
                                html += '<div class="flex flex-wrap gap-2">';
                                comparison.executionSent.forEach(t => {
                                    const tokenName = formatTokenName(t.token);
                                    const isReceipt = tokenName.toLowerCase().includes('amplp') || tokenName.toLowerCase().includes('zluna');
                                    const bgClass = isReceipt ? 'bg-gray-500/20 text-gray-400' : 'bg-red-500/20 text-red-300';
                                    html += `<span class="px-2 py-1 rounded ${bgClass} text-sm">-${t.amount.toLocaleString(undefined, {maximumFractionDigits: 2})} ${tokenName}</span>`;
                                });
                                html += '</div></div>';
                            }
                            
                            html += '<div class="text-gray-500 text-xs mt-2 italic">Gray items are receipt/internal tokens</div>';
                            html += '</div>';
                        } else if (!p.executionTx) {
                            html += `
                            <div class="p-3 rounded bg-gray-500/10 border border-gray-500/30">
                                <div class="flex items-center gap-2 text-gray-400">
                                    <span>üìã</span>
                                    <span>Link execution TX to see actual results</span>
                                </div>
                            </div>`;
                        }
                        
                        html += '</div>';
                        return html;
                    })()}
                </div>
                
                <!-- Voters -->
                <div class="p-4 border-b border-white/5">
                    <div class="text-xs text-gray-500 uppercase mb-2">üë• Voters (${p.voters?.length || 0})</div>
                    ${p.voters && p.voters.length > 0 
                        ? `<div class="max-h-48 overflow-auto space-y-1">
                            ${p.voters.map(v => {
                                const voteColor = v.vote === 'yes' ? 'text-green-400' : v.vote === 'no' ? 'text-red-400' : 'text-gray-400';
                                const voteIcon = v.vote === 'yes' ? '‚úÖ' : v.vote === 'no' ? '‚ùå' : '‚ö™';
                                const isUnknown = !v.name || v.name === 'Unknown' || v.name === 'Unknown Member';
                                const displayName = isUnknown ? v.address : v.name;
                                const nameClass = isUnknown ? 'text-yellow-400 mono text-xs' : 'text-white';
                                return `
                                <div class="flex items-center justify-between py-1 px-2 rounded bg-white/5 text-sm group">
                                    <div class="flex items-center gap-2 flex-1 min-w-0">
                                        <span class="${voteColor} shrink-0">${voteIcon}</span>
                                        <span class="${nameClass} truncate" title="${v.address}">${displayName}</span>
                                        ${isUnknown ? '<span class="text-yellow-600 text-xs shrink-0">(Unknown)</span>' : ''}
                                    </div>
                                    <div class="flex items-center gap-2 shrink-0">
                                        <span class="text-gray-500">${v.power} VP</span>
                                        <button onclick="event.stopPropagation(); copyText('${v.address}')" class="text-xs px-1 py-0.5 bg-white/10 hover:bg-white/20 rounded text-gray-500 hover:text-white opacity-0 group-hover:opacity-100 transition" title="Copy address">üìã</button>
                                        <a href="https://chainsco.pe/terra2/address/${v.address}" target="_blank" onclick="event.stopPropagation()" class="text-xs px-1 py-0.5 bg-blue-500/20 hover:bg-blue-500/30 rounded text-blue-400 hover:text-blue-300 opacity-0 group-hover:opacity-100 transition" title="View on Chainscope">üîó</a>
                                    </div>
                                </div>
                                `;
                            }).join('')}
                           </div>`
                        : `<div class="text-gray-600 text-sm">Voter data not loaded. Re-fetch proposal to load voters.</div>`
                    }
                </div>
                
                <!-- Cross-Check: Actions vs Raw Messages -->
                <div class="p-4 border-b border-white/5">
                    <div class="flex items-center justify-between mb-2">
                        <div class="text-xs text-gray-500 uppercase">‚ö° Action Cross-Check (${p.decodedActions?.length || 0} actions)</div>
                        <button onclick="event.stopPropagation(); copyAllActions('${id}')" class="text-xs px-2 py-1 bg-white/10 hover:bg-white/20 rounded text-gray-400 hover:text-white">üìã Copy All Actions</button>
                    </div>
                    <div class="space-y-3">
                        ${(p.decodedActions || []).map((a, idx) => {
                            let icon = '‚úÖ';
                            let addrStatus = 'Known Contract';
                            if (a.contractType === 'unknown') { icon = '‚ùå'; addrStatus = 'UNKNOWN ADDRESS'; }
                            else if (a.contractType === 'unknown_member') { icon = '‚ö†Ô∏è'; addrStatus = 'Unregistered Member'; }
                            else if (a.contractType === 'stargate') { icon = 'üåê'; addrStatus = 'Stargate/IBC'; }
                            else if (a.contractType === 'member') { addrStatus = 'DAO Member'; }
                            
                            let nameDisplay = a.contractName || 'Unknown';
                            if (a.contractDisplayName) nameDisplay = `${a.contractName} (${a.contractDisplayName})`;
                            
                            // Get the raw message for this action
                            const rawMsg = p.rawMsgs?.[idx];
                            const rawJson = rawMsg ? JSON.stringify(rawMsg, null, 2) : 'No raw data';
                            
                            return `
                            <div class="bg-white/5 rounded-lg overflow-hidden" id="action-${id}-${idx}">
                                <!-- Action Header -->
                                <div class="p-3 border-b border-white/10">
                                    <div class="flex items-center justify-between">
                                        <div class="flex items-center gap-2">
                                            <span class="text-gray-500 text-sm font-bold">#${idx + 1}</span>
                                            <span class="text-purple-400 font-medium text-lg">${a.actionName}</span>
                                            ${a.lpTypeLabel ? `<span class="text-xs px-2 py-0.5 rounded ${a.lpType === 'compounding' ? 'bg-blue-500/20 text-blue-400' : 'bg-orange-500/20 text-orange-400'}">${a.lpTypeLabel}</span>` : ''}
                                        </div>
                                        <div class="flex items-center gap-2">
                                            <span class="text-xs px-2 py-1 rounded ${a.contractType === 'unknown' ? 'bg-red-500/20 text-red-400' : a.contractType === 'unknown_member' ? 'bg-yellow-500/20 text-yellow-400' : 'bg-green-500/20 text-green-400'}">${icon} ${addrStatus}</span>
                                            <button onclick="event.stopPropagation(); copyAction('${id}', ${idx})" class="text-xs px-2 py-1 bg-white/10 hover:bg-white/20 rounded text-gray-400 hover:text-white" title="Copy this action">üìã</button>
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- Two Column: DAODAO View vs Raw -->
                                <div class="grid grid-cols-2 divide-x divide-white/10">
                                    <!-- DAODAO Decoded View -->
                                    <div class="p-3">
                                        <div class="flex items-center justify-between mb-2">
                                            <div class="text-xs text-blue-400 uppercase">DAODAO Action</div>
                                            <button onclick="event.stopPropagation(); copyDecodedAction('${id}', ${idx})" class="text-xs px-1.5 py-0.5 bg-white/10 hover:bg-white/20 rounded text-gray-500 hover:text-white" title="Copy decoded">üìã</button>
                                        </div>
                                        <div class="space-y-2 text-sm">
                                            <div><span class="text-gray-500">Type:</span> <span class="text-white">${a.type || 'unknown'}</span></div>
                                            <div><span class="text-gray-500">Action:</span> <span class="text-purple-400">${a.action}</span></div>
                                            <div><span class="text-gray-500">Target:</span> <span class="${a.contractClass}">${nameDisplay}</span></div>
                                            ${a.funds ? `<div><span class="text-gray-500">Funds:</span> <span class="text-yellow-400">${a.funds.map(f => f.amount.toLocaleString() + ' ' + f.denom).join(', ')}</span></div>` : ''}
                                            ${a.params ? `
                                            <details class="mt-2">
                                                <summary class="text-xs text-gray-500 cursor-pointer hover:text-gray-300">Parameters</summary>
                                                <pre class="text-xs text-gray-400 mt-1 p-2 bg-black/30 rounded overflow-auto max-h-24 mono">${escapeHtml(JSON.stringify(a.params, null, 2))}</pre>
                                            </details>
                                            ` : ''}
                                        </div>
                                    </div>
                                    
                                    <!-- Raw Message -->
                                    <div class="p-3">
                                        <div class="flex items-center justify-between mb-2">
                                            <div class="text-xs text-orange-400 uppercase">Raw Message</div>
                                            <button onclick="event.stopPropagation(); copyRawMessage('${id}', ${idx})" class="text-xs px-1.5 py-0.5 bg-white/10 hover:bg-white/20 rounded text-gray-500 hover:text-white" title="Copy raw">üìã</button>
                                        </div>
                                        <pre class="text-xs text-gray-400 p-2 bg-black/30 rounded overflow-auto max-h-32 mono">${escapeHtml(rawJson)}</pre>
                                    </div>
                                </div>
                                
                                <!-- Contract Address -->
                                ${a.contract ? `
                                <div class="p-2 bg-black/20 border-t border-white/10 flex items-center gap-2">
                                    <span class="text-gray-600 text-xs">Contract:</span>
                                    <span class="text-gray-400 text-xs mono flex-1">${a.contract}</span>
                                    <button onclick="event.stopPropagation(); copyText('${a.contract}')" class="text-gray-600 hover:text-white text-xs px-1.5 py-0.5 rounded bg-white/10">üìã</button>
                                </div>
                                ` : ''}
                            </div>
                            `;
                        }).join('')}
                    </div>
                </div>
                
                <!-- Unaccounted Raw Data Check -->
                <div class="p-4 border-b border-white/5">
                    <div class="text-xs text-gray-500 uppercase mb-2">üîé Raw Data Integrity Check</div>
                    ${(() => {
                        const actionCount = p.decodedActions?.length || 0;
                        const rawCount = p.rawMsgs?.length || 0;
                        
                        if (rawCount > actionCount) {
                            const extra = rawCount - actionCount;
                            return `
                            <div class="p-3 rounded bg-red-500/10 border border-red-500/30">
                                <div class="flex items-center gap-2 text-red-400 font-medium">
                                    <span>‚ùå</span>
                                    <span>UNACCOUNTED RAW MESSAGES DETECTED</span>
                                </div>
                                <div class="text-gray-400 text-sm mt-1">
                                    Found ${rawCount} raw messages but only ${actionCount} decoded actions.
                                    <strong class="text-red-400">${extra} message(s) not accounted for!</strong>
                                </div>
                                <details class="mt-2">
                                    <summary class="text-xs text-red-400 cursor-pointer">View unaccounted messages</summary>
                                    <pre class="text-xs text-gray-400 mt-2 p-2 bg-black/30 rounded overflow-auto max-h-48 mono">${escapeHtml(JSON.stringify(p.rawMsgs?.slice(actionCount), null, 2))}</pre>
                                </details>
                            </div>
                            `;
                        } else if (rawCount < actionCount) {
                            return `
                            <div class="p-3 rounded bg-yellow-500/10 border border-yellow-500/30">
                                <div class="flex items-center gap-2 text-yellow-400">
                                    <span>‚ö†Ô∏è</span>
                                    <span>Action count mismatch</span>
                                </div>
                                <div class="text-gray-400 text-sm mt-1">
                                    ${actionCount} actions decoded but only ${rawCount} raw messages. Some actions may be missing raw data.
                                </div>
                            </div>
                            `;
                        } else {
                            return `
                            <div class="p-3 rounded bg-green-500/10 border border-green-500/30">
                                <div class="flex items-center gap-2 text-green-400">
                                    <span>‚úÖ</span>
                                    <span>All raw messages accounted for</span>
                                </div>
                                <div class="text-gray-400 text-sm mt-1">
                                    ${actionCount} actions match ${rawCount} raw messages. No hidden data detected.
                                </div>
                            </div>
                            `;
                        }
                    })()}
                </div>
                
                <!-- Risk Assessment -->
                <div class="p-4 border-b border-white/5">
                    <div class="text-xs text-gray-500 uppercase mb-2">üéØ Risk Assessment</div>
                    ${(() => {
                        const risk = calculateRiskScore(p);
                        const levelColors = {
                            low: 'bg-green-500/20 border-green-500/30 text-green-400',
                            medium: 'bg-yellow-500/20 border-yellow-500/30 text-yellow-400',
                            high: 'bg-red-500/20 border-red-500/30 text-red-400'
                        };
                        const levelLabels = {
                            low: 'üü¢ LOW FLAGS - Standard review',
                            medium: 'üü° MEDIUM FLAGS - Extra review recommended',
                            high: 'üî¥ HIGH FLAGS - Careful review required'
                        };
                        
                        return `
                        <div class="p-4 rounded-lg border ${levelColors[risk.level]}">
                            <div class="flex items-center justify-between mb-3">
                                <div class="font-medium">${levelLabels[risk.level]}</div>
                                <div class="text-2xl font-bold">${risk.score}/100</div>
                            </div>
                            <div class="space-y-1">
                                ${risk.factors.map(f => {
                                    const icon = f.type === 'error' ? '‚ùå' : f.type === 'warning' ? '‚ö†Ô∏è' : '‚úÖ';
                                    const color = f.type === 'error' ? 'text-red-400' : f.type === 'warning' ? 'text-yellow-400' : 'text-green-400';
                                    return `<div class="text-sm ${color}">${icon} ${f.msg}</div>`;
                                }).join('')}
                            </div>
                            <div class="text-xs text-gray-500 mt-3 pt-3 border-t border-white/10 italic">
                                ‚ö†Ô∏è Automated assessment only. Always verify addresses & amounts independently before voting.
                            </div>
                        </div>
                        `;
                    })()}
                </div>
                
                <!-- Audit Section -->
                <div class="p-4">
                    <div class="flex items-center justify-between mb-2">
                        <div class="text-xs text-gray-500 uppercase">üîç Audit Report</div>
                        <button onclick="event.stopPropagation(); copyAuditReport('${id}')" class="text-xs px-2 py-1 bg-white/10 hover:bg-white/20 rounded text-gray-400 hover:text-white">üìã Copy Report</button>
                    </div>
                    ${(() => {
                        const audit = auditProposal(p);
                        const knownNote = knownProposalNotes[p.id?.toLowerCase()];
                        
                        let html = '';
                        
                        // Show known proposal note if exists
                        if (knownNote) {
                            const noteStyle = knownNote.resolved 
                                ? 'bg-blue-500/10 border-blue-500/30 text-blue-300'
                                : 'bg-purple-500/10 border-purple-500/30 text-purple-300';
                            html += `
                            <div class="mb-4 p-3 rounded border ${noteStyle}">
                                <div class="flex items-start gap-2">
                                    <span>üìù</span>
                                    <div>
                                        <div class="font-medium mb-1">Historical Note</div>
                                        <div class="text-sm opacity-90">${knownNote.note}</div>
                                    </div>
                                </div>
                            </div>`;
                        }
                        
                        if (audit.issues.length > 0) {
                            const errorCount = audit.issues.filter(i => i.severity === 'error').length;
                            const warningCount = audit.issues.filter(i => i.severity === 'warning').length;
                            const infoCount = audit.issues.filter(i => i.severity === 'info').length;
                            html += `
                            <div class="space-y-2">
                                <div class="flex items-center gap-2 mb-3">
                                    <span class="text-red-400 font-medium">${errorCount} Errors</span>
                                    <span class="text-yellow-400 font-medium">${warningCount} Warnings</span>
                                    ${infoCount > 0 ? `<span class="text-blue-400 font-medium">${infoCount} Info</span>` : ''}
                                </div>
                                ${audit.issues.map((issue, issueIdx) => {
                                    // Extract address from detail if present
                                    const addrMatch = issue.detail.match(/(terra1[a-z0-9]{38,})/);
                                    const address = addrMatch ? addrMatch[1] : null;
                                    
                                    // Extract callback action if present
                                    const callbackMatch = issue.detail.match(/execute "([^"]+)"/);
                                    const callback = callbackMatch ? callbackMatch[1] : null;
                                    
                                    // Severity-based styling
                                    const severityStyles = {
                                        error: { bg: 'bg-red-500/10 border-red-500/30', icon: '‚ùå', text: 'text-red-400' },
                                        warning: { bg: 'bg-yellow-500/10 border-yellow-500/30', icon: '‚ö†Ô∏è', text: 'text-yellow-400' },
                                        info: { bg: 'bg-blue-500/10 border-blue-500/30', icon: '‚ÑπÔ∏è', text: 'text-blue-400' }
                                    };
                                    const style = severityStyles[issue.severity] || severityStyles.warning;
                                    
                                    return `
                                    <div class="p-3 rounded ${style.bg} border">
                                        <div class="flex items-start justify-between gap-2">
                                            <div class="flex items-start gap-2 flex-1">
                                                <span class="mt-0.5">${style.icon}</span>
                                                <div class="flex-1">
                                                    <div class="${style.text} font-medium">${issue.title}</div>
                                                    <div class="text-gray-400 text-sm mt-1">${issue.detail}</div>
                                                    
                                                    ${address ? `
                                                    <div class="mt-2 p-2 bg-black/30 rounded flex items-center gap-2 flex-wrap">
                                                        <span class="text-gray-500 text-xs">Address:</span>
                                                        <span class="text-gray-300 text-xs mono break-all">${address}</span>
                                                        <div class="flex items-center gap-1 ml-auto">
                                                            <button onclick="event.stopPropagation(); copyText('${address}')" class="text-xs px-1.5 py-0.5 bg-white/10 hover:bg-white/20 rounded text-gray-400 hover:text-white" title="Copy address">üìã</button>
                                                            <a href="https://chainsco.pe/terra2/address/${address}" target="_blank" onclick="event.stopPropagation()" class="text-xs px-1.5 py-0.5 bg-blue-500/20 hover:bg-blue-500/30 rounded text-blue-400 hover:text-blue-300" title="View on Chainscope">üîó</a>
                                                        </div>
                                                    </div>
                                                    ` : ''}
                                                    
                                                    ${callback ? `
                                                    <div class="mt-2 p-2 bg-black/30 rounded flex items-center gap-2">
                                                        <span class="text-gray-500 text-xs">Callback:</span>
                                                        <span class="text-purple-400 text-sm mono">${callback}</span>
                                                        <button onclick="event.stopPropagation(); copyText('${callback}')" class="text-xs px-1.5 py-0.5 bg-white/10 hover:bg-white/20 rounded text-gray-400 hover:text-white ml-auto" title="Copy callback">üìã</button>
                                                    </div>
                                                    ` : ''}
                                                </div>
                                            </div>
                                            <button onclick="event.stopPropagation(); copyText(this.dataset.text)" data-text="${(issue.title + ': ' + issue.detail).replace(/"/g, '&quot;')}" class="text-xs px-1.5 py-0.5 bg-white/10 hover:bg-white/20 rounded text-gray-400 hover:text-white shrink-0" title="Copy issue">üìã</button>
                                        </div>
                                    </div>
                                    `;
                                }).join('')}
                            </div>
                            `;
                        } else {
                            html += `
                            <div class="p-3 rounded bg-green-500/10 border border-green-500/30">
                                <div class="flex items-center gap-2 text-green-400">
                                    <span>‚úÖ</span>
                                    <span class="font-medium">All checks passed</span>
                                </div>
                                <div class="text-gray-400 text-sm mt-1">
                                    ‚Ä¢ All addresses verified against registry<br>
                                    ‚Ä¢ All raw messages accounted for<br>
                                    ‚Ä¢ No suspicious activity detected
                                </div>
                            </div>
                            `;
                        }
                        return html;
                    })()}
                </div>
            </div>
        </div>
        `;
    }).join('');
}

// Prompt to link execution TX to saved proposal
async function promptLinkExecution(propId) {
    const prop = store.proposals[propId];
    if (!prop) {
        alert('Proposal not found');
        return;
    }
    
    const txHash = prompt('Enter the execution TX hash from DAODAO:\n\n(Find it on the proposal page under "TX")');
    if (!txHash) return;
    
    // Show loading
    alert('Fetching TX data... (This may fail due to CORS if running locally)');
    
    const endpoints = [
        `https://terra-rest.publicnode.com/cosmos/tx/v1beta1/txs/${txHash}`,
        `https://terra-phoenix-lcd.publicnode.com/cosmos/tx/v1beta1/txs/${txHash}`,
        `https://rest.cosmos.directory/terra2/cosmos/tx/v1beta1/txs/${txHash}`
    ];
    
    let data = null;
    
    for (const url of endpoints) {
        try {
            const response = await fetch(url, { headers: { 'Accept': 'application/json' } });
            if (response.ok) {
                data = await response.json();
                break;
            }
        } catch (err) {
            console.log('Endpoint failed:', url);
        }
    }
    
    if (!data) {
        // Manual entry fallback with better instructions
        const logsText = prompt(
            'CORS blocked (normal for local files).\n\n' +
            'To enter manually:\n' +
            '1. Go to: https://chainsco.pe/terra2/tx/' + txHash + '\n' +
            '2. Scroll to "event logs" section\n' +
            '3. Select all text from "[0] message" to the end\n' +
            '4. Paste here:\n\n' +
            '(Or click Cancel to skip)'
        );
        if (!logsText) return;
        
        const treasuryAddress = daoConfigs[currentDao]?.treasury || '';
        const events = parseChainScopeText(logsText, treasuryAddress);
        
        prop.executionTx = {
            hash: txHash,
            block: 'N/A',
            success: true,
            received: events.received,
            sent: events.sent,
            fetchedAt: new Date().toISOString()
        };
    } else {
        const tx = data.tx_response;
        const treasuryAddress = daoConfigs[currentDao]?.treasury || '';
        const events = parseExecutionEvents(tx.logs || [], treasuryAddress);
        
        prop.executionTx = {
            hash: txHash,
            block: tx.height,
            success: tx.code === 0 || tx.code === undefined,
            received: events.received,
            sent: events.sent,
            fetchedAt: new Date().toISOString()
        };
    }
    
    saveToStorage();
    renderProposals();
    alert('‚úÖ Execution TX linked to ' + propId + '\n\nReceived: ' + (prop.executionTx.received?.length || 0) + ' tokens\nSent: ' + (prop.executionTx.sent?.length || 0) + ' tokens');
}

function toggleProposal(id) {
    const expandEl = document.getElementById('expand-' + id);
    const chevronEl = document.getElementById('chevron-' + id);
    
    if (expandEl.classList.contains('hidden')) {
        expandEl.classList.remove('hidden');
        chevronEl.style.transform = 'rotate(180deg)';
    } else {
        expandEl.classList.add('hidden');
        chevronEl.style.transform = 'rotate(0deg)';
    }
}

function auditProposal(prop) {
    const issues = [];
    
    if (!prop.decodedActions || prop.decodedActions.length === 0) {
        return { issues, status: 'empty' };
    }
    
    // Check raw data count vs action count
    const actionCount = prop.decodedActions.length;
    const rawCount = prop.rawMsgs?.length || 0;
    
    if (rawCount > actionCount) {
        issues.push({
            severity: 'error',
            title: `Unaccounted raw messages detected`,
            detail: `Found ${rawCount} raw messages but only ${actionCount} decoded actions. ${rawCount - actionCount} message(s) may be hidden!`
        });
    } else if (rawCount < actionCount) {
        issues.push({
            severity: 'warning',
            title: `Missing raw data`,
            detail: `${actionCount} actions decoded but only ${rawCount} raw messages found.`
        });
    }
    
    // Check for DUPLICATE actions
    const actionSignatures = [];
    prop.decodedActions.forEach((action, idx) => {
        // Create a signature for this action
        const sig = JSON.stringify({
            action: action.action,
            contract: action.contract,
            params: action.params
        });
        
        const duplicateIdx = actionSignatures.findIndex(s => s.sig === sig);
        if (duplicateIdx !== -1) {
            // Check if this is an intentional DeFi pattern (transfer ‚Üí different execute)
            // Common pattern: multiple identical transfers each followed by different actions
            const isTransferAction = ['transfer', 'send'].includes(action.action);
            const nextAction = prop.decodedActions[idx + 1];
            const originalNextAction = prop.decodedActions[actionSignatures[duplicateIdx].idx + 1];
            
            // Also check preceding actions for patterns like (different unstake ‚Üí same withdraw)
            const prevAction = idx > 0 ? prop.decodedActions[idx - 1] : null;
            const originalPrevAction = actionSignatures[duplicateIdx].idx > 0 ? prop.decodedActions[actionSignatures[duplicateIdx].idx - 1] : null;
            
            // If both are transfers followed by DIFFERENT actions, it's likely intentional
            const followedByDifferentAction = nextAction && originalNextAction && 
                JSON.stringify({a: nextAction.action, c: nextAction.contract, p: nextAction.params}) !== 
                JSON.stringify({a: originalNextAction.action, c: originalNextAction.contract, p: originalNextAction.params});
            
            // If both are preceded by DIFFERENT actions, it's also likely intentional (e.g., different unstake ‚Üí same withdraw)
            const precededByDifferentAction = prevAction && originalPrevAction &&
                JSON.stringify({a: prevAction.action, c: prevAction.contract, p: prevAction.params}) !== 
                JSON.stringify({a: originalPrevAction.action, c: originalPrevAction.contract, p: originalPrevAction.params});
            
            if (isTransferAction && followedByDifferentAction) {
                // Intentional pattern - downgrade to info or skip entirely
                issues.push({
                    severity: 'info',
                    title: `Repeated transfer (workflow pattern)`,
                    detail: `Action #${idx + 1} (${action.actionName}) repeats action #${actionSignatures[duplicateIdx].idx + 1}, but each is followed by a different action. This is a common DeFi pattern (transfer ‚Üí execute).`
                });
            } else if (precededByDifferentAction) {
                // Different action leads to same result - also likely intentional
                issues.push({
                    severity: 'info',
                    title: `Repeated action (workflow pattern)`,
                    detail: `Action #${idx + 1} (${action.actionName}) repeats action #${actionSignatures[duplicateIdx].idx + 1}, but each is preceded by a different action. This is a common DeFi pattern (execute ‚Üí finalize).`
                });
            } else {
                issues.push({
                    severity: 'warning',
                    title: `Duplicate action detected`,
                    detail: `Action #${idx + 1} (${action.actionName}) is identical to action #${actionSignatures[duplicateIdx].idx + 1}. This may be intentional or an error.`
                });
            }
        }
        actionSignatures.push({ sig, idx });
    });
    
    prop.decodedActions.forEach((action, idx) => {
        const rawMsg = prop.rawMsgs?.[idx];
        const contractInfo = contractRegistry[action.contract];
        
        // Check for unknown contracts (skip bank sends - handled by wallet payment check below)
        if (action.contractType === 'unknown' && action.type !== 'bank') {
            issues.push({
                severity: 'error',
                title: `Unknown address in action #${idx + 1} (${action.actionName})`,
                detail: `Address ${action.contract || 'unknown'} is not in registry or member list. This could be suspicious.`
            });
        }
        
        // Check if action is valid for this specific contract
        if (action.contractType === 'contract' && contractInfo) {
            const hasValidActions = contractInfo.validActions && Array.isArray(contractInfo.validActions);
            
            if (hasValidActions) {
                const actionIsValid = contractInfo.validActions.includes(action.action);
                if (!actionIsValid) {
                    issues.push({
                        severity: 'error',
                        title: `UNEXPECTED action on ${contractInfo.name}`,
                        detail: `Action "${action.action}" is NOT in validActions for this contract! Expected: [${contractInfo.validActions.join(', ')}]. This could be an exploit attempt!`
                    });
                }
            } else {
                // Contract known but no validActions defined - warn for manual review
                issues.push({
                    severity: 'warning',
                    title: `Unvalidated action in action #${idx + 1}`,
                    detail: `Action "${action.action}" on ${contractInfo.name} - contract has no validActions defined. Manual verification recommended.`
                });
            }
        }
        
        // Check for unknown members (yellow warning)
        if (action.contractType === 'unknown_member') {
            issues.push({
                severity: 'warning',
                title: `Unregistered member in action #${idx + 1}`,
                detail: `Address ${action.contract || 'unknown'} is a DAO member but has no registered name.`
            });
        }
        
        // ========================================
        // WALLET PAYMENT SECURITY
        // Bank sends and transfers to ANY wallet (even known members) require scrutiny
        // Unlike contracts (immutable code), wallets are human-controlled and can go rogue
        // ========================================
        const highRiskActions = ['send', 'transfer', 'bank_send'];
        const isWalletPayment = action.type === 'bank' || 
            (highRiskActions.includes(action.action) && !contractInfo);
        
        if (isWalletPayment && action.funds && action.funds.length > 0) {
            const totalFunds = action.funds.map(f => `${f.amount} ${f.denom}`).join(', ');
            const resolved = resolveAddress(action.contract);
            
            if (action.contractType === 'unknown') {
                // Unknown wallet - WARNING for bank sends (recipient should be in proposal description)
                // Native transfers are lower risk than contract calls
                issues.push({
                    severity: 'warning',
                    title: `üí∏ Payment to wallet not in registry`,
                    detail: `${totalFunds} being sent to ${action.contract}. Verify recipient matches proposal description. (Wallet may be private community member)`
                });
            } else if (action.contractType === 'member' || action.contractType === 'unknown_member') {
                // Known member - still flag but show name
                const memberName = resolved.name || resolved.displayName || 'Unknown Member';
                issues.push({
                    severity: 'warning',
                    title: `üí∏ Payment to member wallet: ${memberName}`,
                    detail: `${totalFunds} being sent to ${memberName} (${action.contract}). Wallets are human-controlled - verify this payment is correct and the address hasn't been compromised.`
                });
            }
        }
        
        // Check for high-risk actions to unknown addresses (non-payment)
        if (highRiskActions.includes(action.action) && action.contractType === 'unknown' && (!action.funds || action.funds.length === 0)) {
            issues.push({
                severity: 'error',
                title: `High-risk action to unknown address`,
                detail: `"${action.actionName}" targeting unverified address ${action.contract || 'unknown'}. Verify this is intentional.`
            });
        }
        
        // Check for funds being sent to contract that shouldn't receive funds
        if (action.funds && action.funds.length > 0 && contractInfo && !contractInfo.canReceiveFunds) {
            const totalFunds = action.funds.map(f => `${f.amount} ${f.denom}`).join(', ');
            issues.push({
                severity: 'warning',
                title: `Funds sent to unexpected contract`,
                detail: `${totalFunds} being sent to ${contractInfo.name} which doesn't normally receive funds. Verify this is intended.`
            });
        }
        
        // DEEP INSPECTION: Check for hidden callbacks in send messages
        if (rawMsg?.wasm?.execute) {
            const execMsg = rawMsg.wasm.execute;
            let decodedInnerMsg = execMsg.msg;
            
            // Decode base64 message if needed
            if (typeof decodedInnerMsg === 'string') {
                try {
                    decodedInnerMsg = JSON.parse(atob(decodedInnerMsg));
                } catch (e) {
                    // Not valid base64/JSON
                }
            }
            
            // Check for nested 'msg' field (CW20 send with callback)
            if (decodedInnerMsg && typeof decodedInnerMsg === 'object') {
                const innerAction = Object.keys(decodedInnerMsg)[0];
                const innerParams = decodedInnerMsg[innerAction];
                
                // CW20 send/transfer with hidden callback
                if ((innerAction === 'send' || innerAction === 'transfer') && innerParams?.msg) {
                    let callbackMsg = innerParams.msg;
                    const targetContract = innerParams.contract || innerParams.recipient || 'unknown';
                    const targetResolved = resolveAddress(targetContract);
                    const targetIsKnown = targetResolved.type === 'contract' || targetResolved.type === 'member';
                    const targetInfo = contractRegistry[targetContract];
                    
                    try {
                        if (typeof callbackMsg === 'string') {
                            callbackMsg = JSON.parse(atob(callbackMsg));
                        }
                        const callbackAction = Object.keys(callbackMsg)[0];
                        const callbackParams = JSON.stringify(callbackMsg[callbackAction] || {});
                        
                        // Check if this specific callback is valid for this specific contract
                        const hasValidCallbacks = targetInfo?.validCallbacks && Array.isArray(targetInfo.validCallbacks);
                        const callbackIsValidForContract = hasValidCallbacks && targetInfo.validCallbacks.includes(callbackAction);
                        
                        // Determine severity and message
                        if (!targetIsKnown) {
                            // Unknown target = ERROR (could be malicious)
                            issues.push({
                                severity: 'error',
                                title: `Callback to UNKNOWN contract in action #${idx + 1}`,
                                detail: `CW20 ${innerAction} sends to unknown contract ${targetContract} with callback "${callbackAction}". This could be malicious - verify the contract!`
                            });
                        } else if (!hasValidCallbacks) {
                            // Known contract but no validCallbacks defined = WARNING (need to verify)
                            issues.push({
                                severity: 'warning',
                                title: `Callback to contract without validation in action #${idx + 1}`,
                                detail: `CW20 ${innerAction} to ${targetResolved.name} (${targetContract}) with callback "${callbackAction}". Contract has no validCallbacks defined - manually verify this is expected.`
                            });
                        } else if (!callbackIsValidForContract) {
                            // Known contract but UNEXPECTED callback = ERROR (suspicious!)
                            issues.push({
                                severity: 'error',
                                title: `UNEXPECTED callback in action #${idx + 1}`,
                                detail: `CW20 ${innerAction} to ${targetResolved.name} with callback "${callbackAction}" - but this action is NOT in the valid callbacks list for this contract! Expected: [${targetInfo.validCallbacks.join(', ')}]. This is suspicious!`
                            });
                        }
                        // If targetIsKnown AND callbackIsValidForContract ‚Üí No issue, this is verified safe
                        
                    } catch (e) {
                        issues.push({
                            severity: 'warning',
                            title: `Encoded callback in action #${idx + 1}`,
                            detail: `CW20 ${innerAction} to ${targetContract} contains an encoded callback message that couldn't be decoded.`
                        });
                    }
                }
                
                // Check for unexpected extra keys in the inner message
                if (innerParams && typeof innerParams === 'object') {
                    const expectedKeys = getExpectedKeys(innerAction);
                    // Only check if we have defined expected keys for this action
                    if (expectedKeys !== null && expectedKeys.length > 0) {
                        const actualKeys = Object.keys(innerParams);
                        const extraKeys = actualKeys.filter(k => !expectedKeys.includes(k) && k !== 'msg');
                        
                        if (extraKeys.length > 0) {
                            issues.push({
                                severity: 'warning',
                                title: `Unexpected fields in action #${idx + 1}`,
                                detail: `Action "${innerAction}" has extra fields: ${extraKeys.join(', ')}. These may contain hidden instructions.`
                            });
                        }
                    }
                }
            }
        }
        
        // Check for unexpected top-level keys in raw message
        if (rawMsg && typeof rawMsg === 'object') {
            const knownTopKeys = ['wasm', 'bank', 'stargate', 'staking', 'distribution', 'gov', 'ibc'];
            const topKeys = Object.keys(rawMsg);
            const unknownTopKeys = topKeys.filter(k => !knownTopKeys.includes(k));
            
            if (unknownTopKeys.length > 0) {
                issues.push({
                    severity: 'error',
                    title: `Unknown message type in action #${idx + 1}`,
                    detail: `Raw message contains unknown type(s): ${unknownTopKeys.join(', ')}. This could be malicious!`
                });
            }
        }
        
        // NESTED ADDRESS SCAN: Find all terra addresses in params and verify them
        if (action.params) {
            const nestedAddresses = findNestedAddresses(action.params);
            nestedAddresses.forEach(addr => {
                const resolved = resolveAddress(addr.address);
                if (resolved.type === 'unknown') {
                    issues.push({
                        severity: 'warning',
                        title: `Unknown nested address in action #${idx + 1}`,
                        detail: `Found unverified address in "${addr.path}": ${addr.address}`
                    });
                }
            });
        }
    });
    
    const hasRealIssues = issues.some(i => i.severity === 'error' || i.severity === 'warning');
    return { issues, status: hasRealIssues ? 'issues' : 'clean' };
}

// Recursively find all terra addresses in an object
function findNestedAddresses(obj, path = '') {
    const addresses = [];
    
    if (!obj || typeof obj !== 'object') return addresses;
    
    for (const [key, value] of Object.entries(obj)) {
        const currentPath = path ? `${path}.${key}` : key;
        
        if (typeof value === 'string' && value.startsWith('terra1') && value.length >= 44) {
            addresses.push({ address: value, path: currentPath });
        } else if (typeof value === 'object' && value !== null) {
            addresses.push(...findNestedAddresses(value, currentPath));
        }
    }
    
    return addresses;
}

// Calculate treasury impact from proposal actions
function calculateTreasuryImpact(prop) {
    const impact = {
        outflows: [],   // Assets leaving treasury
        inflows: [],    // Assets coming to treasury
        expectedReturns: [], // Inferred returns based on contract type
        netByToken: {}, // Net impact per token
        totalUsdEstimate: null // Could add price lookup later
    };
    
    if (!prop.decodedActions) return impact;
    
    prop.decodedActions.forEach((action, idx) => {
        // Track outflows from funds attached to wasm executes (NOT bank sends - handled below)
        if (action.funds && action.funds.length > 0 && action.type !== 'bank') {
            action.funds.forEach(fund => {
                impact.outflows.push({
                    action: idx + 1,
                    actionName: action.actionName,
                    token: fund.denom,
                    amount: fund.amount,
                    recipient: action.contract,
                    recipientName: action.contractName
                });
                
                // Update net
                if (!impact.netByToken[fund.denom]) {
                    impact.netByToken[fund.denom] = 0;
                }
                impact.netByToken[fund.denom] -= fund.amount;
            });
            
            // Infer expected returns based on action + contract
            const expectedReturn = inferExpectedReturn(action, action.funds);
            if (expectedReturn) {
                impact.expectedReturns.push(expectedReturn);
            }
        }
        
        // Track outflows from bank.send
        if (action.type === 'bank' && action.action === 'send') {
            const rawMsg = prop.rawMsgs?.[idx];
            if (rawMsg?.bank?.send?.amount) {
                rawMsg.bank.send.amount.forEach(coin => {
                    const amount = parseInt(coin.amount) / 1e6;
                    const denom = formatDenom(coin.denom);
                    
                    impact.outflows.push({
                        action: idx + 1,
                        actionName: action.actionName,
                        token: denom,
                        amount: amount,
                        recipient: action.contract,
                        recipientName: action.contractName
                    });
                    
                    if (!impact.netByToken[denom]) {
                        impact.netByToken[denom] = 0;
                    }
                    impact.netByToken[denom] -= amount;
                });
            }
        }
        
        // Track CW20 token sends (from params)
        if (action.action === 'send' || action.action === 'transfer') {
            if (action.params?.amount) {
                const amount = parseInt(action.params.amount) / 1e6;
                // Try to identify the token from the contract
                const tokenName = action.contractName || 'Unknown Token';
                
                impact.outflows.push({
                    action: idx + 1,
                    actionName: action.actionName,
                    token: tokenName,
                    amount: amount,
                    recipient: action.params.recipient || action.params.contract || 'Unknown',
                    recipientName: resolveAddress(action.params.recipient || action.params.contract || '').name
                });
                
                if (!impact.netByToken[tokenName]) {
                    impact.netByToken[tokenName] = 0;
                }
                impact.netByToken[tokenName] -= amount;
                
                // Infer expected returns for CW20 sends to known contracts
                const recipient = action.params.recipient || action.params.contract;
                if (recipient) {
                    const expectedReturn = inferExpectedReturn({
                        ...action,
                        contract: recipient,
                        contractName: resolveAddress(recipient).name
                    }, [{ amount, denom: tokenName }]);
                    if (expectedReturn) {
                        impact.expectedReturns.push(expectedReturn);
                    }
                }
            }
        }
        
        // Track create_lp expected returns
        if (action.action === 'create_lp') {
            const lpType = action.lpType || 'unknown';
            impact.expectedReturns.push({
                action: idx + 1,
                token: 'LP Tokens',
                description: lpType === 'compounding' 
                    ? 'Auto-compounding LP position (rewards reinvested)'
                    : lpType === 'non-compounding'
                    ? 'Non-compounding LP position (claim rewards manually)'
                    : 'LP position',
                destination: action.params?.post_action?.liquid_stake?.compounder 
                    || action.params?.post_action?.stake?.asset_staking
                    || 'Unknown'
            });
        }
    });
    
    return impact;
}

// Infer what tokens will be received based on action and contract
function inferExpectedReturn(action, funds) {
    const contractName = action.contractName?.toLowerCase() || '';
    const actionName = action.action?.toLowerCase() || '';
    
    // Deposit to arbLUNA Hub ‚Üí receive arbLUNA
    if (contractName.includes('arbluna') || contractName.includes('arbitrage vault')) {
        return {
            action: action.action,
            token: 'arbLUNA',
            description: 'Liquid staking derivative with arbitrage yield',
            note: 'Amount determined at execution based on exchange rate'
        };
    }
    
    // Deposit to ampLUNA Hub ‚Üí receive ampLUNA
    if (contractName.includes('ampluna hub') && actionName === 'bond') {
        return {
            action: action.action,
            token: 'ampLUNA',
            description: 'Liquid staking derivative',
            note: 'Amount determined at execution based on exchange rate'
        };
    }
    
    // Zapper creates LP
    if (contractName.includes('zapper')) {
        return {
            action: action.action,
            token: 'LP Tokens',
            description: 'Liquidity pool tokens',
            note: 'Staked in TLA or Compounder'
        };
    }
    
    return null;
}

// Parse token amounts from text (title/description)
function parseTokenAmountsFromText(text) {
    if (!text) return [];
    
    const found = [];
    
    // Helper to extract context around a match
    function getContext(text, matchIndex, matchLength) {
        const contextChars = 60; // chars before/after
        const start = Math.max(0, matchIndex - contextChars);
        const end = Math.min(text.length, matchIndex + matchLength + contextChars);
        
        let context = text.substring(start, end);
        
        // Clean up - find nearest word/sentence boundaries
        if (start > 0) context = '...' + context.substring(context.indexOf(' ') + 1);
        if (end < text.length) context = context.substring(0, context.lastIndexOf(' ')) + '...';
        
        // Clean whitespace
        context = context.replace(/\s+/g, ' ').trim();
        
        return context;
    }
    
    // Known tokens to look for (including variations)
    const tokenPattern = 'LUNA|CAPA|ROAR|ampLUNA|ampROAR|bLUNA|arbLUNA|BMOS|USDC|USDT|ASTRO|SOLID|SWTH|EURE|bWHALE|boneWHALE|ampWHALE|arbWHALE|WHALE';
    
    // Multipliers for k/m/b
    const multipliers = { 'k': 1000, 'm': 1000000, 'b': 1000000000 };
    
    // Try pattern with suffix (200k CAPA)
    let match;
    const regex1 = new RegExp(`(\\d+(?:\\.\\d+)?)\\s*([kmb])\\s+(${tokenPattern})`, 'gi');
    while ((match = regex1.exec(text)) !== null) {
        const num = parseFloat(match[1]);
        const mult = multipliers[match[2].toLowerCase()];
        const token = match[3].toUpperCase();
        const context = getContext(text, match.index, match[0].length);
        found.push({ token, amount: num * mult, raw: match[0], context });
    }
    
    // Try pattern with commas (200,000 CAPA)
    const regex2 = new RegExp(`(\\d{1,3}(?:,\\d{3})+(?:\\.\\d+)?)\\s*(${tokenPattern})`, 'gi');
    while ((match = regex2.exec(text)) !== null) {
        const num = parseFloat(match[1].replace(/,/g, ''));
        const token = match[2].toUpperCase();
        const context = getContext(text, match.index, match[0].length);
        // Avoid duplicates
        if (!found.some(f => f.token === token && Math.abs(f.amount - num) < 1)) {
            found.push({ token, amount: num, raw: match[0], context });
        }
    }
    
    // Try plain numbers (1769 LUNA) - but not tiny numbers that might be IDs
    // Use negative lookbehind to avoid matching "500" from "4,500"
    const regex3 = new RegExp(`(?<![,\\d])(\\d+(?:\\.\\d+)?)\\s+(${tokenPattern})`, 'gi');
    while ((match = regex3.exec(text)) !== null) {
        const num = parseFloat(match[1]);
        const token = match[2].toUpperCase();
        const context = getContext(text, match.index, match[0].length);
        // Skip if looks like an ID (single/double digit) or already found
        if (num >= 1 && !found.some(f => f.token === token && Math.abs(f.amount - num) < 1)) {
            found.push({ token, amount: num, raw: match[0], context });
        }
    }
    
    return found;
}

// Compare described amounts to actual amounts
function compareDescribedVsActual(prop) {
    const comparison = {
        described: [],
        executionReceived: [],
        executionSent: [],
        deltas: [],  // Show difference between described and actual (inflows)
        outflowDeltas: [], // Outflows comparison
        discrepancies: [],  // For when no execution data
        canCompare: false,
        hasExecutionData: false
    };
    
    // If we have execution TX data, use ACTUAL tokens to search description
    if (prop.executionTx && (prop.executionTx.received?.length > 0 || prop.executionTx.sent?.length > 0)) {
        comparison.hasExecutionData = true;
        comparison.executionReceived = prop.executionTx.received || [];
        comparison.executionSent = prop.executionTx.sent || [];
        
        // Token name aliases (maps variations to canonical name)
        const tokenAliases = {
            'BONEWHALE': 'BWHALE', 'BWHALE': 'BWHALE',
            'AMPWHALE': 'AMPWHALE', 'ARBWHALE': 'ARBWHALE',
        };
        
        // Build map of actual amounts from execution - BOTH received and sent
        const actualReceivedByToken = {};
        const actualSentByToken = {};
        const allTokenNames = new Set();
        
        for (const t of comparison.executionReceived) {
            let tokenName = formatTokenName(t.token).toUpperCase();
            actualReceivedByToken[tokenName] = (actualReceivedByToken[tokenName] || 0) + t.amount;
            allTokenNames.add(tokenName);
        }
        
        for (const t of comparison.executionSent) {
            let tokenName = formatTokenName(t.token).toUpperCase();
            actualSentByToken[tokenName] = (actualSentByToken[tokenName] || 0) + t.amount;
            allTokenNames.add(tokenName);
        }
        
        // ========================================
        // LP PAIR DETECTION
        // Look for LP pairs mentioned in description (LUNA/ampLUNA, ROAR-LUNA, etc.)
        // ========================================
        const text = (prop.title || '') + ' ' + (prop.description || '');
        const lpPairsFound = [];
        
        // More flexible LP detection - match word/word or word-word patterns
        // Then check if both parts are known tokens
        const knownTokensSet = new Set(['LUNA', 'AMPLUNA', 'ARBLUNA', 'ROAR', 'AMPROAR', 'CAPA', 'AMPCAPA', 'ASTRO', 'XASTRO', 'WHALE', 'BWHALE', 'AMPWHALE', 'ARBWHALE', 'UST', 'USDC', 'USDT', 'AXLUSDC']);
        
        // Match patterns like word/word or word-word (flexible matching)
        const lpPatterns = [
            /(\w+)\s*\/\s*(\w+)/gi,   // LUNA/ampLUNA, Luna / ampLUNA
            /(\w+)\s*-\s*(\w+)/gi,    // LUNA-ampLUNA, Luna - ampLUNA
        ];
        
        for (const regex of lpPatterns) {
            let match;
            while ((match = regex.exec(text)) !== null) {
                const token1 = match[1].toUpperCase();
                const token2 = match[2].toUpperCase();
                
                // Check if BOTH tokens are known (or close to known)
                const token1Known = knownTokensSet.has(token1) || [...knownTokensSet].some(k => k.includes(token1) || token1.includes(k));
                const token2Known = knownTokensSet.has(token2) || [...knownTokensSet].some(k => k.includes(token2) || token2.includes(k));
                
                if (token1Known && token2Known) {
                    // Don't add duplicates
                    if (!lpPairsFound.some(lp => 
                        (lp.token1 === token1 && lp.token2 === token2) ||
                        (lp.token1 === token2 && lp.token2 === token1))) {
                        lpPairsFound.push({
                            token1,
                            token2,
                            raw: match[0],
                            pattern: `${token1}/${token2}`
                        });
                    }
                }
            }
        }
        
        // Mark tokens that are part of an LP pair mentioned in description
        const lpRelatedTokens = new Set();
        
        for (const lp of lpPairsFound) {
            // Check if both tokens from the LP appear in actual execution
            // Use a smarter matching function
            const matchesLpToken = (actualToken, lpToken) => {
                // Exact match
                if (actualToken === lpToken) return true;
                // actualToken is AMPLUNA, lpToken is AMPLUNA
                if (actualToken.includes(lpToken) && lpToken.length >= 4) return true;
                // lpToken is AMPLUNA, actualToken is AMPLUNA  
                if (lpToken.includes(actualToken) && actualToken.length >= 4) return true;
                return false;
            };
            
            const token1InReceived = Object.keys(actualReceivedByToken).some(t => matchesLpToken(t, lp.token1));
            const token2InReceived = Object.keys(actualReceivedByToken).some(t => matchesLpToken(t, lp.token2));
            const token1InSent = Object.keys(actualSentByToken).some(t => matchesLpToken(t, lp.token1));
            const token2InSent = Object.keys(actualSentByToken).some(t => matchesLpToken(t, lp.token2));
            
            
            // If both tokens of the LP appear in received OR both in sent, mark them as LP-related
            if ((token1InReceived && token2InReceived) || (token1InSent && token2InSent)) {
                // Find the actual token names that match
                for (const actualToken of allTokenNames) {
                    if (matchesLpToken(actualToken, lp.token1) || matchesLpToken(actualToken, lp.token2)) {
                        lpRelatedTokens.add(actualToken);
                    }
                }
            }
        }
        
        // Store LP pairs for display
        comparison.lpPairs = lpPairsFound;
        comparison.lpRelatedTokens = lpRelatedTokens;
        
        // Build dynamic search patterns from actual token names
        // Include common variations/aliases
        const searchTerms = [];
        for (const token of allTokenNames) {
            searchTerms.push(token);
            // Add common variations
            if (token === 'BWHALE') searchTerms.push('boneWHALE', 'bWHALE');
            if (token === 'AMPWHALE') searchTerms.push('ampWHALE');
            if (token === 'ARBWHALE') searchTerms.push('arbWHALE');
            if (token === 'ROAR') searchTerms.push('roar');
            if (token === 'LUNA') searchTerms.push('luna', 'Luna');
        }
        
        // Search description for amounts of these specific tokens
        const foundInDescription = [];
        
        for (const searchTerm of searchTerms) {
            // Build regex for this token: number (with commas/decimals) + token name
            const escapedTerm = searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            const patterns = [
                // "12,354.02 boneWHALE" or "12354.02 bWHALE"
                new RegExp(`([\\d,]+(?:\\.\\d+)?)\\s*${escapedTerm}`, 'gi'),
                // "12.3k LUNA" style
                new RegExp(`(\\d+(?:\\.\\d+)?)\\s*([kmb])\\s*${escapedTerm}`, 'gi'),
                // "3 Billion ROAR" style
                new RegExp(`(\\d+(?:\\.\\d+)?)\\s*(billion|million|thousand)\\s*${escapedTerm}`, 'gi'),
            ];
            
            const multipliers = { 'k': 1000, 'm': 1000000, 'b': 1000000000, 'thousand': 1000, 'million': 1000000, 'billion': 1000000000 };
            
            for (const regex of patterns) {
                let match;
                while ((match = regex.exec(text)) !== null) {
                    let amount;
                    if (match[2]) {
                        // Has multiplier (k/m/b or word)
                        amount = parseFloat(match[1]) * multipliers[match[2].toLowerCase()];
                    } else {
                        amount = parseFloat(match[1].replace(/,/g, ''));
                    }
                    
                    // Normalize token name to match actual
                    let normalizedToken = searchTerm.toUpperCase();
                    normalizedToken = tokenAliases[normalizedToken] || normalizedToken;
                    
                    // Only add if not already found for this token and amount is reasonable
                    if (amount > 0 && !foundInDescription.some(f => 
                        f.token === normalizedToken && Math.abs(f.amount - amount) < 1)) {
                        foundInDescription.push({
                            token: normalizedToken,
                            amount: amount,
                            raw: match[0],
                            searchTerm: searchTerm
                        });
                    }
                }
            }
        }
        
        comparison.described = foundInDescription;
        comparison.canCompare = foundInDescription.length > 0 || 
            Object.keys(actualReceivedByToken).length > 0 || 
            Object.keys(actualSentByToken).length > 0;
        
        // Match described amounts to EITHER received or sent
        const matchedReceivedTokens = new Set();
        const matchedSentTokens = new Set();
        
        // Sort by amount descending (larger amounts first to avoid false matches)
        foundInDescription.sort((a, b) => b.amount - a.amount);
        
        for (const desc of foundInDescription) {
            const receivedAmount = actualReceivedByToken[desc.token];
            const sentAmount = actualSentByToken[desc.token];
            
            // Try to match to received first
            if (receivedAmount !== undefined && !matchedReceivedTokens.has(desc.token)) {
                const difference = receivedAmount - desc.amount;
                const percentDiff = Math.abs((difference / desc.amount) * 100);
                
                if (percentDiff < 50 || Math.abs(difference) < 100) {
                    comparison.deltas.push({
                        token: desc.searchTerm || desc.token,
                        described: desc.amount,
                        actual: receivedAmount,
                        difference: difference,
                        percentChange: ((difference / desc.amount) * 100).toFixed(2),
                        status: 'matched',
                        direction: 'inflow'
                    });
                    matchedReceivedTokens.add(desc.token);
                    continue;
                }
            }
            
            // Try to match to sent
            if (sentAmount !== undefined && !matchedSentTokens.has(desc.token)) {
                const difference = sentAmount - desc.amount;
                const percentDiff = Math.abs((difference / desc.amount) * 100);
                
                if (percentDiff < 50 || Math.abs(difference) < 100) {
                    comparison.outflowDeltas.push({
                        token: desc.searchTerm || desc.token,
                        described: desc.amount,
                        actual: sentAmount,
                        difference: difference,
                        percentChange: ((difference / desc.amount) * 100).toFixed(2),
                        status: 'matched',
                        direction: 'outflow'
                    });
                    matchedSentTokens.add(desc.token);
                }
            }
        }
        
        // Add tokens that were RECEIVED but NOT described
        for (const [token, amount] of Object.entries(actualReceivedByToken)) {
            if (!matchedReceivedTokens.has(token) && amount > 0.01) {
                // Skip receipt tokens (amplp, zLUNA, etc.) - these are expected and don't need description
                const isReceiptToken = token.toLowerCase().includes('amplp') || 
                    token.toLowerCase().includes('zluna') ||
                    token.toLowerCase().includes('zlun');
                
                // Check if token is part of an LP pair mentioned in description
                const isLpRelated = lpRelatedTokens.has(token);
                
                // Find which LP pair it belongs to
                let lpPairName = null;
                if (isLpRelated) {
                    for (const lp of lpPairsFound) {
                        if (token.includes(lp.token1) || lp.token1.includes(token) ||
                            token.includes(lp.token2) || lp.token2.includes(token)) {
                            lpPairName = lp.pattern;
                            break;
                        }
                    }
                }
                
                comparison.deltas.push({
                    token: token,
                    described: isLpRelated ? lpPairName : null,
                    actual: amount,
                    difference: null,
                    percentChange: null,
                    status: isReceiptToken ? 'receipt' : (isLpRelated ? 'lp-related' : 'undescribed'),
                    direction: 'inflow',
                    lpPair: lpPairName
                });
            }
        }
        
        // Add tokens that were SENT but NOT described
        for (const [token, amount] of Object.entries(actualSentByToken)) {
            if (!matchedSentTokens.has(token) && amount > 0.01) {
                // Skip receipt tokens being returned
                const isReceiptToken = token.toLowerCase().includes('amplp') || 
                    token.toLowerCase().includes('zluna') ||
                    token.toLowerCase().includes('zlun');
                
                // Check if token is part of an LP pair mentioned in description
                const isLpRelated = lpRelatedTokens.has(token);
                
                // Find which LP pair it belongs to
                let lpPairName = null;
                if (isLpRelated) {
                    for (const lp of lpPairsFound) {
                        if (token.includes(lp.token1) || lp.token1.includes(token) ||
                            token.includes(lp.token2) || lp.token2.includes(token)) {
                            lpPairName = lp.pattern;
                            break;
                        }
                    }
                }
                
                comparison.outflowDeltas.push({
                    token: token,
                    described: isLpRelated ? lpPairName : null,
                    actual: amount,
                    difference: null,
                    percentChange: null,
                    status: isReceiptToken ? 'receipt' : (isLpRelated ? 'lp-related' : 'undescribed'),
                    direction: 'outflow',
                    lpPair: lpPairName
                });
            }
        }
        
        // Sort deltas: matched first, then lp-related, then undescribed, then receipts
        const statusOrder = { 'matched': 0, 'lp-related': 1, 'undescribed': 2, 'receipt': 3 };
        comparison.deltas.sort((a, b) => statusOrder[a.status] - statusOrder[b.status]);
        comparison.outflowDeltas.sort((a, b) => statusOrder[a.status] - statusOrder[b.status]);
        
        return comparison;
    }
    
    // No execution data - use static token list to parse description
    const staticTokens = parseTokenAmountsFromText((prop.title || '') + ' ' + (prop.description || ''));
    comparison.described = staticTokens;
    comparison.canCompare = staticTokens.length > 0;
    
    if (!comparison.canCompare) {
        return comparison;
    }
    
    // Compare against proposed treasury impact
    comparison.discrepancies = [];
    const impact = calculateTreasuryImpact(prop);
    
    const actualByToken = {};
    for (const [token, amount] of Object.entries(impact.netByToken)) {
        let normalizedToken = token.toUpperCase()
            .replace(' TOKEN', '').replace('TOKEN', '').trim();
        actualByToken[normalizedToken] = Math.abs(amount);
    }
    
    for (const desc of comparison.described) {
        const normalizedDescToken = desc.token.toUpperCase();
        const actualAmount = actualByToken[normalizedDescToken];
        
        if (actualAmount === undefined) {
            comparison.discrepancies.push({
                token: desc.token,
                described: desc.amount,
                actual: 0,
                difference: desc.amount,
                context: desc.context || null,
                issue: `Described ${desc.amount.toLocaleString()} ${desc.token} but no ${desc.token} found in proposal actions`
            });
        } else {
            const tolerance = desc.amount * 0.01;
            const diff = Math.abs(desc.amount - actualAmount);
            
            if (diff > tolerance && diff > 1) {
                comparison.discrepancies.push({
                    token: desc.token,
                    described: desc.amount,
                    actual: actualAmount,
                    difference: actualAmount - desc.amount,
                    context: desc.context || null,
                    issue: `Described ${desc.amount.toLocaleString()} ${desc.token} but proposal shows ${actualAmount.toLocaleString()} ${desc.token}`
                });
            }
        }
    }
    
    return comparison;
}

// Expected parameters for common actions
function getExpectedKeys(action) {
    const expectedParams = {
        'vote': ['votes', 'voter', 'proposal_id', 'gauge'], // gauge for TLA Amp Gauges voting
        'send': ['contract', 'amount', 'recipient', 'msg'],
        'transfer': ['recipient', 'amount', 'owner'],
        'claim_rewards': ['recipient', 'stages', 'lockup_id', 'claim_type'],
        'claim_bribes': ['recipient', 'claims'],
        'claim_rebase': ['recipient'],
        'stake': ['recipient', 'amount', 'gauge'],
        'unstake': ['amount', 'asset', 'recipient'],
        'bond': ['receiver', 'exec_msg'],
        'unbond': ['receiver', 'amount'],
        'withdraw': ['amount', 'recipient'],
        'extend_lock_amount': ['amount'],
        'extend_lock_time': ['time'],
        'tune_amps': ['pools'],
        'provide_liquidity': ['assets', 'slippage_tolerance', 'auto_stake', 'receiver'],
        'withdraw_liquidity': ['assets', 'amount'],
        'swap': ['offer_asset', 'belief_price', 'max_spread', 'to'],
        'execute': ['msgs', 'contract', 'msg', 'timeout_seconds', 'callback'], // callback/timeout for Polytone cross-chain
        'update_config': [], // Can have many keys - skip check
        'set_item': ['key', 'value', 'addr'],
        'remove_item': ['key'],
        // DeFi / LP actions
        'create_lp': ['min_received', 'assets', 'stage', 'post_action', 'receiver'],
        'deposit': ['asset', 'receiver', 'amount'],
        'zap': ['into', 'minimum_receive', 'post_action', 'assets'],
        'compound': ['minimum_receive', 'stages'],
        // Staking actions with callbacks
        'withdraw_unbonded': ['receiver'],
        'queue_unbond': ['receiver'],
        'submit_batch': [],
        // Governance
        'cast_vote': ['proposal_id', 'vote'],
        'propose': ['title', 'description', 'msgs'],
        // Alliance Module
        'alliance_delegate': ['delegations', 'validator', 'amount'],
        'alliance_undelegate': ['undelegations', 'validator', 'amount'],
        'alliance_redelegate': ['redelegations', 'src_validator', 'dst_validator', 'amount'],
        'alliance_claim_rewards': ['recipient', 'validators'],
        // Polytone cross-chain callback
        'callback': ['callback_id', 'result', 'initiator', 'initiator_msg'],
        // NFT actions
        'send_nft': ['contract', 'token_id', 'msg'],
        'transfer_nft': ['recipient', 'token_id'],
        'approve': ['spender', 'token_id', 'expires'],
        // OTC / Escrow
        'fund': [],  // Usually just funds attached, no params
        'refund': ['recipient']
    };
    
    // Return empty array for unknown actions (skip the check)
    return expectedParams[action] || null;
}

function renderRegistry() {
    const search = (document.getElementById('search-registry')?.value || '').toLowerCase();
    let entries = Object.entries(contractRegistry).map(([addr, info]) => ({ addr, ...info }));
    
    if (search) {
        entries = entries.filter(e => 
            e.name.toLowerCase().includes(search) || 
            e.addr.toLowerCase().includes(search)
        );
    }
    
    entries.sort((a, b) => a.name.localeCompare(b.name));
    
    const typeColors = {
        dao: 'text-blue-400',
        treasury: 'text-yellow-400',
        staking: 'text-purple-400',
        connector: 'text-purple-300',
        rewards: 'text-green-400',
        token: 'text-cyan-400',
        nft: 'text-pink-400',
        'cross-chain': 'text-orange-400',
        wallet: 'text-gray-400'
    };
    
    document.getElementById('registry-table').innerHTML = entries.map(e => `
        <tr class="border-b border-white/5 hover:bg-white/5">
            <td class="px-4 py-3 text-white">${e.name}</td>
            <td class="px-4 py-3 ${typeColors[e.type] || 'text-gray-400'}">${e.type}</td>
            <td class="px-4 py-3">
                <div class="flex items-center gap-2">
                    <span class="mono text-gray-400 text-xs">${e.addr}</span>
                    <button onclick="copyText('${e.addr}')" class="text-gray-600 hover:text-white text-xs px-1.5 py-0.5 rounded bg-white/5 hover:bg-white/10">üìã</button>
                </div>
            </td>
        </tr>
    `).join('');
}

function closeDetail() {
    document.getElementById('detail-panel').classList.add('translate-x-full');
}

// ========================================
// UTILITIES
// ========================================
function formatDenom(denom) {
    if (!denom) return '';
    
    // Check IBC tokens
    if (denom.startsWith('ibc/')) {
        const hash = denom.slice(4);
        // Try full hash first, then shorter prefixes
        if (ibcDenomRegistry[denom]) return ibcDenomRegistry[denom];
        if (ibcDenomRegistry['ibc/' + hash.slice(0, 12)]) return ibcDenomRegistry['ibc/' + hash.slice(0, 12)];
        if (ibcDenomRegistry[hash.slice(0, 6)]) return ibcDenomRegistry[hash.slice(0, 6)];
        // Fallback to short hash
        return 'IBC/' + hash.slice(0, 6);
    }
    
    // Check factory tokens (format: factory/contract_address/token_name)
    if (denom.includes('/')) {
        const parts = denom.split('/');
        
        // Check for amplp tokens: factory/{compounder}/{poolId}/{gauge}/amplp
        // Example: factory/terra1zly.../12/project/amplp
        if (parts.length >= 4 && parts[parts.length - 1].toLowerCase() === 'amplp') {
            const poolId = parts[parts.length - 3];
            const gauge = parts[parts.length - 2];
            const poolInfo = lpPoolRegistry[poolId];
            
            if (poolInfo) {
                const gaugeSuffix = gauge === 'project' ? ' (P)' : gauge === 'single' ? ' (S)' : '';
                return `amplp ${poolInfo.name}${gaugeSuffix}`;
            }
            // Fallback with pool ID
            return `amplp #${poolId}/${gauge}`;
        }
        
        // Check for uLP tokens: factory/{pair}/uLP
        if (parts[parts.length - 1].toLowerCase() === 'ulp') {
            const pairContract = parts[1];
            const pairInfo = contractRegistry[pairContract];
            if (pairInfo) {
                return pairInfo.name.replace(' Pair', ' LP');
            }
            return 'LP Token';
        }
        
        const tokenPart = parts[parts.length - 1];
        // Check if it's a known token
        const knownFactoryTokens = {
            'zluna': 'zLUNA',
            'ampcapa': 'ampCAPA',
            'ampluna': 'ampLUNA',
            'amproar': 'ampROAR',
        };
        const lower = tokenPart.toLowerCase();
        if (knownFactoryTokens[lower]) return knownFactoryTokens[lower];
        return tokenPart;
    }
    
    // Check CW20 token overrides
    if (tokenNameOverrides[denom]) return tokenNameOverrides[denom];
    
    // Standard denoms
    if (denom === 'uluna') return 'LUNA';
    if (denom === 'uusd') return 'UST';
    
    return denom;
}

// Format token name from contract address or raw token string
function formatTokenName(token) {
    if (!token) return 'Unknown';
    
    // Check if it's a contract address in registry
    if (token.startsWith('terra') && contractRegistry[token]) {
        const name = contractRegistry[token].name;
        // Clean up "Token" suffix for cleaner display
        return name.replace(' Token', '').replace('Token', '').trim();
    }
    
    // Check token name overrides
    if (tokenNameOverrides[token]) return tokenNameOverrides[token];
    
    // Check if it contains "Token" and clean it up
    if (token.includes(' Token')) {
        return token.replace(' Token', '');
    }
    
    // Format IBC
    if (token.startsWith('IBC/') || token.startsWith('ibc/')) {
        return formatDenom(token.toLowerCase());
    }
    
    return token;
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

function copyText(text) {
    navigator.clipboard.writeText(text).then(() => {
        showToast('Copied!');
    });
}

function showToast(message) {
    // Simple toast notification
    const toast = document.createElement('div');
    toast.className = 'fixed bottom-4 right-4 bg-green-600 text-white px-4 py-2 rounded-lg shadow-lg z-50 animate-pulse';
    toast.textContent = message;
    document.body.appendChild(toast);
    setTimeout(() => toast.remove(), 1500);
}

// Show issues popup for a proposal
function showIssuesPopup(propId) {
    const prop = store.proposals[propId];
    if (!prop) return;
    
    const audit = auditProposal(prop);
    if (audit.issues.length === 0) {
        showToast('No issues found');
        return;
    }
    
    const errorCount = audit.issues.filter(i => i.severity === 'error').length;
    const warningCount = audit.issues.filter(i => i.severity === 'warning').length;
    
    const issuesHtml = audit.issues.map(issue => {
        const colors = {
            error: 'bg-red-500/20 border-red-500/50 text-red-300',
            warning: 'bg-yellow-500/20 border-yellow-500/50 text-yellow-300',
            info: 'bg-blue-500/20 border-blue-500/50 text-blue-300'
        };
        const icons = { error: '‚ùå', warning: '‚ö†Ô∏è', info: '‚ÑπÔ∏è' };
        const color = colors[issue.severity] || colors.warning;
        const icon = icons[issue.severity] || '‚ö†Ô∏è';
        
        return `
            <div class="p-3 rounded-lg border ${color}">
                <div class="flex items-start gap-2">
                    <span>${icon}</span>
                    <div>
                        <div class="font-medium">${issue.title}</div>
                        <div class="text-sm opacity-80 mt-1">${issue.detail}</div>
                    </div>
                </div>
            </div>
        `;
    }).join('');
    
    // Create modal
    const modal = document.createElement('div');
    modal.className = 'fixed inset-0 bg-black/70 flex items-center justify-center z-50';
    modal.onclick = (e) => { if (e.target === modal) modal.remove(); };
    
    modal.innerHTML = `
        <div class="bg-gray-900 rounded-xl p-6 max-w-lg w-full mx-4 max-h-[80vh] overflow-y-auto">
            <div class="flex items-center justify-between mb-4">
                <h3 class="text-xl font-bold text-white">${propId.toUpperCase()} Audit Issues</h3>
                <button onclick="this.closest('.fixed').remove()" class="text-gray-400 hover:text-white text-2xl">&times;</button>
            </div>
            <div class="flex gap-3 mb-4">
                <span class="text-red-400">${errorCount} Errors</span>
                <span class="text-yellow-400">${warningCount} Warnings</span>
            </div>
            <div class="space-y-3">
                ${issuesHtml}
            </div>
            <div class="mt-4 pt-4 border-t border-gray-700 text-sm text-gray-400">
                Click outside or ‚úï to close
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
}

function copyAllActions(propId) {
    const prop = store.proposals[propId];
    if (!prop) return;
    
    const data = {
        proposalId: propId,
        title: prop.title,
        actionCount: prop.decodedActions?.length || 0,
        actions: prop.decodedActions?.map((a, idx) => ({
            index: idx + 1,
            type: a.type,
            action: a.action,
            actionName: a.actionName,
            contract: a.contract,
            contractName: a.contractName,
            contractType: a.contractType,
            funds: a.funds,
            params: a.params
        })),
        rawMessages: prop.rawMsgs
    };
    
    copyText(JSON.stringify(data, null, 2));
}

function copyAction(propId, actionIdx) {
    const prop = store.proposals[propId];
    if (!prop) return;
    
    const action = prop.decodedActions?.[actionIdx];
    const rawMsg = prop.rawMsgs?.[actionIdx];
    
    const data = {
        proposalId: propId,
        actionIndex: actionIdx + 1,
        decoded: action,
        rawMessage: rawMsg
    };
    
    copyText(JSON.stringify(data, null, 2));
}

function copyDecodedAction(propId, actionIdx) {
    const prop = store.proposals[propId];
    if (!prop) return;
    
    const action = prop.decodedActions?.[actionIdx];
    copyText(JSON.stringify(action, null, 2));
}

function copyRawMessage(propId, actionIdx) {
    const prop = store.proposals[propId];
    if (!prop) return;
    
    const rawMsg = prop.rawMsgs?.[actionIdx];
    copyText(JSON.stringify(rawMsg, null, 2));
}

function copyAuditReport(propId) {
    const prop = store.proposals[propId];
    if (!prop) return;
    
    const audit = auditProposal(prop);
    
    const report = {
        proposalId: propId,
        title: prop.title,
        status: prop.status,
        auditDate: new Date().toISOString(),
        summary: {
            totalActions: prop.decodedActions?.length || 0,
            totalRawMessages: prop.rawMsgs?.length || 0,
            errors: audit.issues.filter(i => i.severity === 'error').length,
            warnings: audit.issues.filter(i => i.severity === 'warning').length,
            status: audit.issues.length === 0 ? 'PASSED' : 'ISSUES_FOUND'
        },
        issues: audit.issues,
        actions: prop.decodedActions?.map((a, idx) => ({
            index: idx + 1,
            action: a.actionName,
            contract: a.contract,
            contractName: a.contractName,
            contractType: a.contractType,
            verified: a.contractType !== 'unknown'
        }))
    };
    
    copyText(JSON.stringify(report, null, 2));
}

function copyTreasuryImpact(propId) {
    const prop = store.proposals[propId];
    if (!prop) return;
    
    const impact = calculateTreasuryImpact(prop);
    
    const report = {
        proposalId: propId,
        title: prop.title,
        status: prop.status,
        executedAt: prop.fetchedAt,
        treasuryImpact: {
            outflows: impact.outflows,
            inflows: impact.inflows,
            netByToken: impact.netByToken,
            summary: Object.entries(impact.netByToken).map(([token, amount]) => ({
                token,
                amount,
                direction: amount < 0 ? 'outflow' : 'inflow'
            }))
        }
    };
    
    copyText(JSON.stringify(report, null, 2));
}

function copyFullProposal(propId) {
    const prop = store.proposals[propId];
    if (!prop) return;
    
    copyText(JSON.stringify(prop, null, 2));
}

function copyExecutionResults(propId) {
    const prop = store.proposals[propId];
    if (!prop || !prop.executionTx) return;
    
    const execTx = prop.executionTx;
    
    // Receipt tokens to filter
    const receiptTokens = ['ZLUNA', 'ZLUN'];
    const filterReceipts = (items) => {
        if (!items) return [];
        return items.filter(t => {
            const name = formatTokenName(t.token).toUpperCase();
            return !receiptTokens.some(rt => name.includes(rt));
        });
    };
    
    // Check for VP locks only (not all staking)
    const isVPLock = (addr) => {
        const info = contractRegistry[addr];
        return info && info.isInternalLock === true;
    };
    
    // Check if destination is a staking/deposit contract
    const isStakingContract = (addr) => {
        const info = contractRegistry[addr];
        return info && (info.type === 'staking' || info.type === 'defi' || info.type === 'connector');
    };
    
    const received = filterReceipts(execTx.received);
    const allSent = filterReceipts(execTx.sent);
    const locked = allSent.filter(t => t.to && isVPLock(t.to));
    const staked = allSent.filter(t => t.to && !isVPLock(t.to) && isStakingContract(t.to));
    const sent = allSent.filter(t => !t.to || (!isVPLock(t.to) && !isStakingContract(t.to)));
    
    // Calculate net
    const netByToken = {};
    received.forEach(t => {
        const name = formatTokenName(t.token);
        netByToken[name] = (netByToken[name] || 0) + t.amount;
    });
    allSent.forEach(t => {
        const name = formatTokenName(t.token);
        netByToken[name] = (netByToken[name] || 0) - t.amount;
    });
    
    // Build text report
    let text = `EXECUTION RESULTS - ${propId.toUpperCase()}\n`;
    text += `Title: ${prop.title}\n`;
    text += `TX: ${execTx.hash || 'manual'}\n`;
    text += `Block: ${execTx.block || 'N/A'}\n`;
    text += `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n`;
    
    if (received.length > 0) {
        text += `üì• RECEIVED:\n`;
        received.forEach(t => {
            text += `  +${t.amount.toLocaleString(undefined, {maximumFractionDigits: 2})} ${formatTokenName(t.token)}\n`;
        });
        text += `\n`;
    }
    
    if (locked.length > 0) {
        text += `üîí LOCKED (VP):\n`;
        locked.forEach(t => {
            const lockName = contractRegistry[t.to]?.name || t.to?.slice(0, 20) + '...';
            text += `  ${t.amount.toLocaleString(undefined, {maximumFractionDigits: 2})} ${formatTokenName(t.token)} ‚Üí ${lockName}\n`;
        });
        text += `\n`;
    }
    
    if (staked.length > 0) {
        text += `üìä STAKED/DEPOSITED:\n`;
        staked.forEach(t => {
            const destName = contractRegistry[t.to]?.name || t.to?.slice(0, 20) + '...';
            text += `  ${t.amount.toLocaleString(undefined, {maximumFractionDigits: 2})} ${formatTokenName(t.token)} ‚Üí ${destName}\n`;
        });
        text += `\n`;
    }
    
    if (sent.length > 0) {
        text += `üì§ SENT OUT:\n`;
        sent.forEach(t => {
            const destName = contractRegistry[t.to]?.name || t.to?.slice(0, 20) + '...';
            text += `  -${t.amount.toLocaleString(undefined, {maximumFractionDigits: 2})} ${formatTokenName(t.token)} ‚Üí ${destName}\n`;
        });
        text += `\n`;
    }
    
    const netEntries = Object.entries(netByToken).filter(([k, v]) => Math.abs(v) > 0.01);
    if (netEntries.length > 0) {
        text += `üí∞ NET EFFECT:\n`;
        netEntries.forEach(([token, amount]) => {
            text += `  ${amount >= 0 ? '+' : ''}${amount.toLocaleString(undefined, {maximumFractionDigits: 2})} ${token}\n`;
        });
    }
    
    // Include raw logs if available
    if (execTx.rawLogs) {
        text += `\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n`;
        text += `RAW EVENT LOGS:\n`;
        text += `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n`;
        text += execTx.rawLogs;
    }
    
    copyText(text);
}

function copyRawLogs(propId) {
    const prop = store.proposals[propId];
    if (!prop || !prop.executionTx || !prop.executionTx.rawLogs) {
        showToast('No raw logs available');
        return;
    }
    
    let text = `RAW EVENT LOGS - ${propId.toUpperCase()}\n`;
    text += `TX: ${prop.executionTx.hash || 'manual'}\n`;
    text += `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n`;
    text += prop.executionTx.rawLogs;
    
    copyText(text);
}

// Open DAODAO proposal in new tab (direct link)
function openDaodaoPopup(propId) {
    const config = daoConfigs[currentDao];
    const daoAddress = config?.treasury || config?.core || '';
    const url = `https://daodao.zone/dao/${daoAddress}/proposals/${propId.toUpperCase()}`;
    window.open(url, '_blank');
}

// Open DAODAO for the currently fetched proposal
function openDaodaoForCurrentProp() {
    if (!store.currentFetched || !store.currentFetched.id) {
        showToast('No proposal loaded');
        return;
    }
    openDaodaoPopup(store.currentFetched.id);
}

function closeDaodaoPopup() {
    const modal = document.getElementById('daodao-modal');
    modal.classList.add('hidden');
    
    // Don't clear iframe.src - it can disrupt clipboard copied from within the iframe
    // The iframe will be replaced when user opens another proposal anyway
    
    // Focus the TX hash input after closing
    setTimeout(() => {
        const input = document.getElementById('result-tx-hash');
        if (input) input.focus();
    }, 100);
}

// Close modal on ESC key
document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
        const modal = document.getElementById('daodao-modal');
        if (modal && !modal.classList.contains('hidden')) {
            closeDaodaoPopup();
        }
    }
});

// Paste from clipboard using Clipboard API
async function pasteFromClipboard() {
    try {
        const text = await navigator.clipboard.readText();
        if (text) {
            document.getElementById('result-tx-hash').value = text.trim();
            showToast('Pasted from clipboard');
        } else {
            showToast('Clipboard is empty');
        }
    } catch (err) {
        console.error('Clipboard read failed:', err);
        showToast('Cannot read clipboard - try Ctrl+V manually');
    }
}

function unlinkExecutionTx(propId) {
    const prop = store.proposals[propId];
    if (!prop) return;
    
    if (!confirm('Remove linked execution data from this proposal?')) return;
    
    // Clear execution data
    delete prop.executionTx;
    delete prop.txHash;
    
    // Save and re-render
    saveToStorage();
    renderProposals();
    
    showToast('Execution data unlinked');
}

function updateCounts() {
    // Count proposals for current DAO only
    const daoProposals = Object.values(store.proposals).filter(p => !p.daoId || p.daoId === currentDao);
    const count = daoProposals.length;
    document.getElementById('nav-prop-count').textContent = count;
    document.getElementById('sidebar-prop-count').textContent = count;
}

// ========================================
// STORAGE
// ========================================
function saveToStorage() {
    // Sync current proposals back to proposalsByDao
    if (currentDao) {
        store.proposalsByDao[currentDao] = { ...store.proposals };
    }
    // Save all DAOs to localStorage as backup
    localStorage.setItem('adao_gov_v5_all', JSON.stringify(store.proposalsByDao));
}

function loadFromStorage() {
    try {
        const data = localStorage.getItem('adao_gov_v5_all');
        if (data) {
            store.proposalsByDao = JSON.parse(data);
            store.proposals = store.proposalsByDao[currentDao] || {};
            return true;
        }
    } catch (e) {
        console.error('Load error:', e);
    }
    return false;
}

function exportAll() {
    // Filter proposals by current DAO
    const daoProposals = {};
    for (const [id, p] of Object.entries(store.proposals)) {
        if (!p.daoId || p.daoId === currentDao) {
            daoProposals[id] = p;
        }
    }
    
    const config = daoConfigs[currentDao];
    const data = {
        exported_at: new Date().toISOString(),
        dao: currentDao,
        daoName: config?.name || currentDao,
        proposals: daoProposals
    };
    
    // Use DAO-specific filename
    const filenames = {
        'alliancedao': 'adao_props.json',
        'liondao': 'liondao_props.json',
        'pixelions': 'pixelions_props.json'
    };
    downloadJson(data, filenames[currentDao] || `${currentDao}_props.json`);
}

function clearAll() {
    if (!confirm(`Clear all ${daoConfigs[currentDao]?.name || 'DAO'} proposals and reload from GitHub?`)) return;
    store.proposals = {};
    store.proposalsByDao[currentDao] = {};
    saveToStorage();
    
    // Reload from GitHub
    loadProposalsFromGitHub();
    renderAutoFetchResults();
}

function downloadJson(data, filename) {
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();
    URL.revokeObjectURL(url);
}
</script>

<!-- DAODAO Popup Modal -->
<div id="daodao-modal" class="hidden fixed inset-0 z-50 flex items-center justify-center bg-black/70" onclick="if(event.target === this) closeDaodaoPopup()">
    <div class="bg-gray-900 rounded-xl border border-white/20 w-11/12 max-w-4xl h-4/5 flex flex-col">
        <!-- Modal Header -->
        <div class="flex items-center justify-between p-4 border-b border-white/10">
            <div class="flex items-center gap-4">
                <span class="text-white font-medium">DAODAO Proposal</span>
                <a id="daodao-direct-link" href="#" target="_blank" class="text-purple-400 hover:text-purple-300 text-sm">
                    Open in new tab ‚Üó
                </a>
            </div>
            <button onclick="closeDaodaoPopup()" class="text-gray-400 hover:text-white text-2xl">&times;</button>
        </div>
        <!-- Modal Body -->
        <div class="flex-1 overflow-hidden">
            <iframe id="daodao-iframe" src="" class="w-full h-full border-0"></iframe>
        </div>
        <!-- Modal Footer -->
        <div class="p-3 border-t border-white/10 text-center text-gray-500 text-sm">
            Copy the TX hash from DAODAO, then close this popup and paste into "Link Execution TX"
        </div>
    </div>
</div>

</body>
</html>
