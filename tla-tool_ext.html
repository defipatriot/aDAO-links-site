<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>TLA Admin (Extensions) | Alliance DAO</title>
<meta name="description" content="Internal admin tool for TLA extension data - Votion, PD Bribes, historical tracking. Not the public dashboard.">
<meta name="robots" content="noindex, nofollow">

<!-- Favicon -->
<link rel="icon" type="image/x-icon" href="https://raw.githubusercontent.com/defipatriot/aDAO-Image-Files/main/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://raw.githubusercontent.com/defipatriot/aDAO-Image-Files/main/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://raw.githubusercontent.com/defipatriot/aDAO-Image-Files/main/favicon-32x32.png">
<link rel="apple-touch-icon" sizes="180x180" href="https://raw.githubusercontent.com/defipatriot/aDAO-Image-Files/main/apple-touch-icon.png">

<!-- OG Meta -->
<meta property="og:title" content="TLA Admin Extensions | Alliance DAO">
<meta property="og:description" content="Internal admin tool for TLA extension data collection">
<meta property="og:image" content="https://raw.githubusercontent.com/defipatriot/aDAO-Image-Files/main/android-chrome-512x512.png">
<meta property="og:type" content="website">

<script src="https://cdn.tailwindcss.com"></script>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

<!-- Vercel Analytics -->
<script defer src="/_vercel/insights/script.js"></script>
<style>
    body { font-family: 'Inter', monospace; background: #0D0D0D; color: #EAEAEA; }
    .input-dark { background: #1A1A1A; border: 1px solid #333; color: white; padding: 8px; border-radius: 6px; width: 100%; font-family: monospace; font-size: 0.75rem; resize: vertical; }
    .input-dark:focus { border-color: #2dd4bf; outline: none; }
    .tab-btn { padding: 8px 16px; border-radius: 6px; font-weight: 600; cursor: pointer; background: #1f2937; border: 1px solid #374151; color: #9ca3af; font-size: 0.8rem; transition: all 0.2s; display: flex; align-items: center; gap: 6px; }
    .tab-btn:hover { background: #374151; color: white; }
    .tab-btn.active { background: #2dd4bf; color: #000; border-color: #2dd4bf; }
    .tab-btn.active .tab-status { color: #000; }
    
    /* Tab status indicators */
    .tab-status { font-size: 10px; }
    .tab-incomplete .tab-status { color: #ef4444; }
    .tab-complete .tab-status { color: #22c55e; }
    .tab-partial .tab-status { color: #eab308; }
    .tab-optional .tab-status { color: #6b7280; }
    .tab-optional { color: #6b7280 !important; }
    
    /* Complete tab styling */
    .tab-btn.tab-complete { background: #14532d; border-color: #22c55e; color: #86efac; }
    .tab-btn.tab-complete:hover { background: #166534; }
    .tab-btn.tab-complete.active { background: #22c55e; color: #000; }
    
    /* Incomplete tab styling */
    .tab-btn.tab-incomplete { background: #450a0a; border-color: #b91c1c; color: #fca5a5; }
    .tab-btn.tab-incomplete:hover { background: #7f1d1d; }
    .tab-btn.tab-incomplete.active { background: #ef4444; color: #000; border-color: #ef4444; }
    
    /* Partial tab styling */
    .tab-btn.tab-partial { background: #422006; border-color: #a16207; color: #fde047; }
    .tab-btn.tab-partial:hover { background: #713f12; }
    .tab-btn.tab-partial.active { background: #eab308; color: #000; border-color: #eab308; }
    
    .workspace { display: none !important; } .workspace.active { display: block !important; }
    .preview-card { background: #111; border: 1px solid #333; border-radius: 8px; padding: 16px; }
    .btn-action { background: #333; color: white; padding: 6px; border-radius: 6px; font-size: 0.75rem; width: 100%; margin-top: 8px; transition: 0.2s; font-weight: 600; }
    .btn-action:hover { background: #444; }
    .custom-scroll::-webkit-scrollbar { width: 6px; }
    .custom-scroll::-webkit-scrollbar-track { background: #0d0d0d; }
    .custom-scroll::-webkit-scrollbar-thumb { background: #333; border-radius: 3px; }
    .status-done { background: #065f46 !important; border-color: #10b981 !important; color: #6ee7b7 !important; }
</style>
</head>
<body class="p-4 w-full max-w-[1600px] mx-auto min-h-screen flex flex-col">

<!-- ADMIN TOOL NOTICE -->
<div class="bg-amber-900/30 border border-amber-600/50 rounded-lg px-4 py-2 mb-4 flex items-center gap-3">
    <i class="fas fa-tools text-amber-400"></i>
    <div class="flex-grow">
        <span class="text-amber-400 font-bold text-xs">INTERNAL ADMIN TOOL</span>
        <span class="text-amber-200/70 text-xs ml-2">Extension data (Votion, PD Bribes, Historical). Looking for the dashboard?</span>
    </div>
    <a href="https://www.thealliancedao.com/tla-stats.html" target="_blank" class="bg-cyan-600 hover:bg-cyan-500 text-white px-3 py-1 rounded text-xs font-bold transition-colors flex items-center gap-1">
        <i class="fas fa-chart-line"></i> View TLA Stats
    </a>
</div>

<!-- HEADER -->
<header class="flex flex-col gap-4 mb-4 pb-4 border-b border-gray-800">
    <div class="flex justify-between items-start">
        <div class="flex flex-col">
            <h1 class="text-xl font-bold text-teal-400 flex items-center gap-2">
                <i class="fas fa-puzzle-piece"></i> TLA Admin <span class="text-gray-500 text-sm">Extensions</span>
            </h1>
            <div class="flex gap-4 mt-1 text-[10px] font-mono text-gray-500">
                <span class="flex items-center gap-1"><i class="far fa-clock text-teal-600"></i> Target Epoch: <span id="target-epoch" class="text-white font-bold">...</span></span>
                <span class="text-gray-600">|</span>
                <span class="flex items-center gap-1">Phase: <span id="target-phase" class="text-yellow-400 font-bold">...</span></span>
                <span class="text-gray-600">|</span>
                <span class="flex items-center gap-1">Status: <span id="status-indicator" class="text-gray-400">Idle</span></span>
            </div>
        </div>
        
        <!-- Global Actions -->
        <div class="flex gap-2">
            <button onclick="clearAll()" class="bg-red-900/20 hover:bg-red-900/40 text-red-400 border border-red-900/50 px-3 py-1.5 rounded text-xs font-bold transition-colors">Clear All</button>
            <button onclick="downloadExtJson()" class="bg-teal-900/50 hover:bg-teal-800 text-teal-200 border border-teal-700 px-3 py-1.5 rounded text-xs font-bold transition-colors">Download JSON</button>
            <a href="https://github.com/defipatriot/tla-ext_json_storage" target="_blank" class="bg-gray-700 hover:bg-gray-600 text-white px-3 py-1.5 rounded text-xs font-bold transition-colors flex items-center gap-1">
                <i class="fab fa-github"></i> GitHub
            </a>
        </div>
    </div>
</header>

<!-- Upload Reminder Banner -->
<div class="bg-orange-900/20 border border-orange-700/50 rounded px-4 py-2 mb-4 flex items-center gap-3">
    <i class="fas fa-upload text-orange-400"></i>
    <div class="text-[10px] text-orange-300">
        <span class="font-bold">Remember:</span> Upload 2 files to GitHub ‚Üí 
        <span class="text-white">tla-ext-{epoch}-{phase}.json</span> + 
        <span class="text-white">Staking APR.csv</span> (if stale)
    </div>
</div>

<!-- CONFIG BAR -->
<div class="bg-[#161616] border border-gray-800 rounded-lg p-3 mb-4">
    <div class="flex items-center gap-4 mb-3">
        <div class="flex-shrink-0 text-teal-500 text-xl"><i class="fas fa-sliders-h"></i></div>
        <div class="flex-grow">
            <h3 class="text-xs font-bold text-gray-400 uppercase">Epoch Configuration</h3>
            <p class="text-[10px] text-gray-600">Auto-detected from TLA. Verify before exporting.</p>
        </div>
        
        <!-- Live Epoch Info -->
        <div class="flex items-center gap-3 bg-[#0D0D0D] rounded px-3 py-2 border border-gray-700">
            <div class="flex flex-col items-center">
                <span class="text-[8px] text-gray-500 uppercase">Live Epoch</span>
                <span id="live-epoch" class="text-sm font-mono font-bold text-teal-400">...</span>
            </div>
            <div class="flex flex-col items-center border-l border-gray-700 pl-3">
                <span class="text-[8px] text-gray-500 uppercase">Ends In</span>
                <span id="live-ends" class="text-sm font-mono font-bold text-yellow-400">...</span>
            </div>
            <div class="flex flex-col items-center border-l border-gray-700 pl-3">
                <span class="text-[8px] text-gray-500 uppercase">Auto Phase</span>
                <span id="live-phase" class="text-sm font-mono font-bold text-orange-400">...</span>
            </div>
            <button onclick="fetchLiveEpochInfo()" class="ml-2 text-teal-400 hover:text-teal-300 text-[10px]" title="Refresh live epoch info">
                <i class="fas fa-sync-alt"></i>
            </button>
        </div>
        
        <!-- Working Epoch Selection -->
        <div class="flex items-center gap-2 bg-[#0D0D0D] rounded px-3 py-2 border border-teal-900/50">
            <span class="text-[9px] text-gray-400 uppercase">Working:</span>
            <input type="number" id="extEpoch" placeholder="Ep" class="input-dark w-16 text-center font-mono text-sm" onchange="updateMeta()">
            <select id="extPhase" class="input-dark w-20 text-xs" onchange="updateMeta()">
                <option value="end">End</option>
                <option value="mid">Mid</option>
                <option value="start">Start</option>
            </select>
            <button onclick="syncToLive()" class="text-[9px] text-teal-400 hover:text-teal-300 border border-teal-900 rounded px-2 py-1" title="Sync to live epoch">
                ‚Üê Sync
            </button>
        </div>
        
        <!-- Mismatch Warning -->
        <div id="epoch-mismatch-warning" class="hidden bg-red-900/30 border border-red-700 rounded px-3 py-2 text-[10px] text-red-300">
            <i class="fas fa-exclamation-triangle mr-1"></i>
            <span id="mismatch-text">Working epoch doesn't match live!</span>
        </div>
        
        <!-- Mode Toggle -->
        <div class="border-l border-gray-700 pl-4 flex items-center gap-2">
            <span class="text-[9px] text-gray-500 uppercase">Mode:</span>
            <button id="mode-staging" onclick="setMode('staging')" class="px-2 py-1 text-[10px] rounded bg-yellow-900/50 text-yellow-400 border border-yellow-700">Staging</button>
            <button id="mode-normal" onclick="setMode('normal')" class="px-2 py-1 text-[10px] rounded bg-gray-800 text-gray-500 border border-gray-700">Normal</button>
        </div>
        
        <!-- Test Mode Toggle -->
        <div class="border-l border-gray-700 pl-4 flex items-center gap-2">
            <label class="flex items-center gap-2 cursor-pointer">
                <input type="checkbox" id="test-mode-toggle" onchange="toggleTestMode()" class="w-3 h-3 accent-yellow-500">
                <span class="text-[9px] text-gray-500 uppercase">Test Mode</span>
            </label>
            <span id="test-mode-indicator" class="hidden text-[9px] bg-yellow-900/50 text-yellow-400 px-2 py-0.5 rounded border border-yellow-700">üß™ TEST</span>
        </div>
    </div>
    
    <!-- Second Row: Load Previous + Fetch Status -->
    <div class="grid grid-cols-8 gap-2 text-[9px]">
        <!-- Load Previous Ext File -->
        <div class="col-span-2 bg-[#0D0D0D] rounded p-2 border border-purple-900/50">
            <div class="flex items-center justify-between mb-1">
                <span class="text-purple-400 font-bold uppercase text-[8px]">Load Previous Ext</span>
                <label class="text-purple-300 hover:text-purple-200 cursor-pointer">
                    <i class="fas fa-upload"></i>
                    <input type="file" accept=".json" class="hidden" onchange="loadPreviousExt(event)">
                </label>
            </div>
            <div id="prev-ext-status" class="text-gray-600 text-[9px] truncate">No file loaded</div>
        </div>
        
        <!-- Fetch Status Indicators -->
        <div class="bg-[#0D0D0D] rounded p-2 flex items-center justify-between">
            <span class="text-gray-500">LP Registry</span>
            <span id="fetch-lp" class="text-gray-600">-</span>
        </div>
        <div class="bg-[#0D0D0D] rounded p-2 flex items-center justify-between">
            <span class="text-gray-500">Staging</span>
            <span id="fetch-staging" class="text-gray-600">-</span>
        </div>
        <div class="bg-[#0D0D0D] rounded p-2 flex items-center justify-between">
            <span class="text-gray-500">Historical</span>
            <span id="fetch-historical" class="text-gray-600">-</span>
        </div>
        <div class="bg-[#0D0D0D] rounded p-2 flex items-center justify-between">
            <span class="text-gray-500">Current</span>
            <span id="fetch-current" class="text-gray-600">-</span>
        </div>
        <div class="bg-[#0D0D0D] rounded p-2 flex items-center justify-between">
            <span class="text-gray-500">PD Bribes</span>
            <span id="fetch-pd" class="text-gray-600">-</span>
        </div>
        <button onclick="fetchAllFromGithub()" class="bg-teal-900/30 text-teal-400 rounded p-2 hover:bg-teal-900/50 border border-teal-900/50">
            ‚ü≥ Fetch All
        </button>
    </div>
</div>

<!-- TABS -->
<div class="flex gap-2 mb-4 border-b border-gray-800 pb-1 overflow-x-auto">
    <div id="tab-lpreg" class="tab-btn active tab-incomplete" onclick="switchTab('lpreg')">
        <span class="tab-status">‚óè</span> 1. LP Registry
    </div>
    <div id="tab-ratios" class="tab-btn tab-incomplete" onclick="switchTab('ratios')">
        <span class="tab-status">‚óè</span> 2. Ratios
    </div>
    <div id="tab-prices" class="tab-btn tab-incomplete" onclick="switchTab('prices')">
        <span class="tab-status">‚óè</span> 3. Prices
    </div>
    <div id="tab-votion" class="tab-btn tab-incomplete" onclick="switchTab('votion')">
        <span class="tab-status">‚óè</span> 4. Votion
    </div>
    <div id="tab-pdbribes" class="tab-btn tab-incomplete" onclick="switchTab('pdbribes')">
        <span class="tab-status">‚óè</span> 5. PD Bribes
    </div>
    <div id="tab-astro" class="tab-btn tab-optional" onclick="switchTab('astro')">
        <span class="tab-status">‚óã</span> 6. Astroport
    </div>
    <div id="tab-ww" class="tab-btn tab-optional" onclick="switchTab('ww')">
        <span class="tab-status">‚óã</span> 7. Skeleton
    </div>
</div>

<!-- WS 0: LP REGISTRY -->
<div id="ws-lpreg" class="workspace active">
    <div class="grid grid-cols-12 gap-4 mb-4">
        <!-- Parse Vote Tab -->
        <div class="col-span-6 bg-[#161616] p-3 rounded border border-gray-800 flex flex-col gap-2">
            <div class="flex justify-between items-center">
                <h3 class="text-teal-400 font-bold text-xs">Paste TLA Vote Tab</h3>
                <button onclick="openPreviewModal('https://www.erisprotocol.com/terra/liquidity-hub?tab=vote', 'TLA Vote Tab')" class="text-[9px] text-cyan-400 hover:text-cyan-300 bg-cyan-900/30 px-2 py-0.5 rounded border border-cyan-900/50">
                    <i class="fas fa-external-link-alt mr-1"></i> TLA Vote Tab
                </button>
            </div>
            <textarea id="voteTabPaste" class="input-dark h-48 font-mono text-[9px]" placeholder="Copy entire Vote tab from TLA Core..."></textarea>
            <div class="flex gap-2">
                <button onclick="parseVoteTab()" class="btn-action flex-1 bg-teal-900/40 text-teal-200 border border-teal-900">Parse Vote Tab</button>
                <button onclick="clearPaste('voteTabPaste')" class="btn-action w-20 bg-red-900/30 text-red-300 border border-red-900/50 text-[9px]">Clear</button>
            </div>
        </div>
        
        <!-- Registry Summary -->
        <div class="col-span-6 bg-[#161616] p-3 rounded border border-gray-800">
            <div class="text-[9px] text-gray-500 uppercase font-bold mb-2">LP Registry Summary</div>
            <div class="grid grid-cols-2 gap-2 text-[10px] mb-3">
                <div class="flex justify-between"><span class="text-gray-500">Total LPs:</span><span id="lp-total" class="text-white font-mono">0</span></div>
                <div class="flex justify-between"><span class="text-gray-500">Active (>1%):</span><span id="lp-active" class="text-green-400 font-mono">0</span></div>
                <div class="flex justify-between"><span class="text-gray-500">Astroport:</span><span id="lp-astro" class="text-cyan-400 font-mono">0</span></div>
                <div class="flex justify-between"><span class="text-gray-500">Skeleton Swap:</span><span id="lp-ww" class="text-blue-400 font-mono">0</span></div>
            </div>
            <div class="border-t border-gray-700 pt-2 flex gap-2">
                <button onclick="exportLpRegistry()" class="btn-action flex-1 bg-green-900/30 text-green-300 border border-green-900/50 text-[10px]">Export Registry</button>
                <button onclick="loadLpRegistryPaste()" class="btn-action flex-1 bg-blue-900/30 text-blue-300 border border-blue-900/50 text-[10px]">Load from JSON</button>
            </div>
        </div>
    </div>
    
    <!-- LP List by Bucket -->
    <div class="preview-card">
        <div class="flex justify-between items-center mb-2 border-b border-gray-800 pb-2">
            <div class="flex items-center gap-3">
                <h3 class="text-xs font-bold text-white">LP Registry</h3>
                <span id="lp-scroll-hint" class="text-[9px] text-yellow-400 bg-yellow-900/30 px-2 py-0.5 rounded border border-yellow-700">‚ö† Scroll to bottom to verify & complete</span>
            </div>
            <div class="flex gap-4 text-[9px]">
                <label class="flex items-center gap-1 cursor-pointer">
                    <input type="checkbox" id="filter-active" onchange="renderLpRegistry()">
                    <span class="text-gray-400">Active Only</span>
                </label>
                <label class="flex items-center gap-1 cursor-pointer">
                    <input type="checkbox" id="filter-astro" checked onchange="renderLpRegistry()">
                    <span class="text-cyan-400">Astroport</span>
                </label>
                <label class="flex items-center gap-1 cursor-pointer">
                    <input type="checkbox" id="filter-ww" checked onchange="renderLpRegistry()">
                    <span class="text-blue-400">Skeleton Swap</span>
                </label>
            </div>
        </div>
        <div id="lp-registry-list" class="max-h-[500px] overflow-y-auto custom-scroll space-y-2" onscroll="checkLpRegistryScroll(this)"></div>
        <div id="lp-verify-section" class="hidden mt-3 p-3 bg-green-900/20 border border-green-700 rounded">
            <div class="flex items-center justify-between">
                <div class="flex items-center gap-2">
                    <span class="text-green-400 text-lg">‚úì</span>
                    <span class="text-green-300 text-[11px]">Scrolled to bottom - LP Registry verified!</span>
                </div>
                <button onclick="confirmLpRegistry()" class="bg-green-700 hover:bg-green-600 text-white px-3 py-1 rounded text-[10px] font-bold">Confirm & Complete Step ‚ë†</button>
            </div>
        </div>
    </div>
</div>

<!-- WS: LST RATIOS -->
<div id="ws-ratios" class="workspace">
    <!-- Header with status -->
    <div class="bg-[#161616] border border-teal-900/50 rounded-lg p-4 mb-4">
        <div class="flex justify-between items-center mb-3">
            <div class="flex items-center gap-3">
                <i class="fas fa-exchange-alt text-teal-400 text-xl"></i>
                <div>
                    <h2 class="text-teal-400 font-bold text-sm">LST Ratios & Chain Staking</h2>
                    <p class="text-gray-500 text-[10px]">Track liquid staking token ratios and APYs for snapshot export</p>
                </div>
            </div>
            <div class="flex items-center gap-3">
                <button id="lst-all-status" onclick="togglePricesOverride()" class="px-3 py-1 rounded text-[10px] font-bold bg-red-900/30 text-red-400 border border-red-700 cursor-pointer hover:opacity-80" title="Click to override and mark complete">
                    <i class="fas fa-exclamation-circle mr-1"></i> Incomplete
                </button>
                <button onclick="fetchAllLstRatiosFromChain()" class="bg-green-900/30 hover:bg-green-900/50 text-green-400 px-3 py-1.5 rounded text-[10px] border border-green-900/50 font-bold">
                    <i class="fas fa-bolt mr-1"></i> Auto-Fetch All Ratios
                </button>
                <button onclick="fetchChainStakingApr()" class="bg-teal-900/30 hover:bg-teal-900/50 text-teal-400 px-3 py-1.5 rounded text-[10px] border border-teal-900/50">
                    <i class="fas fa-sync-alt mr-1"></i> Fetch APR
                </button>
            </div>
        </div>
        
        <!-- Chain Staking APR -->
        <div class="grid grid-cols-3 gap-4 mb-4">
            <div id="chain-apr-card" class="bg-[#0D0D0D] rounded-lg p-3 border border-yellow-900/50">
                <div class="flex justify-between items-center mb-2">
                    <span id="chain-apr-title" class="text-yellow-400 text-[10px] font-bold uppercase">Chain Staking APR</span>
                    <div class="flex items-center gap-1">
                        <button onclick="fetchChainStakingApr()" class="text-[9px] text-yellow-400 hover:text-yellow-300 bg-yellow-900/30 px-2 py-0.5 rounded cursor-pointer" title="Refresh from GitHub">
                            <i class="fas fa-sync-alt"></i>
                        </button>
                        <button onclick="openPreviewModal('https://analytics.smartstake.io/terra/stats/staking', 'Smart Stake APR')" class="text-[9px] text-cyan-400 hover:text-cyan-300 bg-cyan-900/30 px-2 py-0.5 rounded cursor-pointer">
                            <i class="fas fa-external-link-alt mr-1"></i> Smart Stake
                        </button>
                    </div>
                </div>
                <div class="flex items-baseline gap-2">
                    <input type="number" id="lst-chain-apr" step="0.01" class="input-dark text-xl font-bold w-24 text-center text-yellow-400" placeholder="" onchange="updateLstRatio('chainStakingApr', this.value)">
                    <span id="chain-apr-pct" class="text-yellow-400 text-lg">%</span>
                </div>
                <div id="lst-chain-apr-date" class="text-[9px] text-gray-600 mt-1">Last: --</div>
            </div>
            <div class="col-span-2 bg-[#0D0D0D] rounded-lg p-3 border border-gray-800">
                <div class="text-[9px] text-gray-500 uppercase font-bold mb-2">Auto-Fetch Info</div>
                <div class="text-[10px] text-gray-400 space-y-1">
                    <p><span class="text-green-400">‚úì Auto-Fetch:</span> ampLUNA, arbLUNA, bLUNA, ampROAR, ampCAPA (from chain contracts)</p>
                    <p><span class="text-blue-400">Manual:</span> xASTRO ratio + all APYs (paste from Eris/Astroport)</p>
                    <p><span class="text-yellow-400">Staking APR:</span> Download CSV from Smart Stake ‚Üí Upload to GitHub</p>
                </div>
            </div>
        </div>
    </div>
    
    <!-- LST Ratio Cards -->
    <div class="grid grid-cols-3 gap-4 mb-4">
        <!-- ampLUNA - AUTO-FETCH -->
        <div id="lst-card-ampLUNA" class="bg-[#161616] rounded-lg p-3 border-2 border-gray-700">
            <div class="flex justify-between items-center mb-1">
                <div class="flex items-center gap-2">
                    <img src="https://raw.githubusercontent.com/defipatriot/aDAO-Image-Files/refs/heads/main/logos/ampLUNA.png" class="w-6 h-6 rounded-full" onerror="this.style.display='none'">
                    <span class="text-teal-400 font-bold text-sm">ampLUNA</span>
                </div>
                <button onclick="openPreviewModal('https://www.erisprotocol.com/terra/amplifier/LUNA', 'ampLUNA - Eris')" class="text-[9px] text-teal-400 hover:text-teal-300 bg-teal-900/30 px-2 py-0.5 rounded border border-teal-900/50 cursor-pointer">
                    <i class="fas fa-external-link-alt mr-1"></i> Eris
                </button>
            </div>
            <div class="flex items-center gap-2 mb-2">
                <span class="text-[8px] bg-green-900/50 text-green-400 px-1.5 py-0.5 rounded border border-green-700">‚ö° AUTO-FETCH</span>
                <div id="lst-status-ampLUNA" class="text-[9px] px-2 py-0.5 rounded bg-gray-800 text-gray-500 flex-1 text-center">pending</div>
            </div>
            <div class="flex items-center gap-2 mb-2">
                <span class="text-[10px] text-gray-500">1 ampLUNA =</span>
                <input type="number" id="lst-ratio-ampLUNA" step="0.0001" class="input-dark w-24 text-center font-mono" placeholder="" onchange="updateLstRatio('ampLUNA', this.value)">
                <span class="text-[10px] text-gray-400">LUNA</span>
            </div>
            <div class="flex items-center gap-2 mb-2">
                <span class="text-[8px] bg-red-900/50 text-red-400 px-1.5 py-0.5 rounded border border-red-700">‚úé MANUAL</span>
                <span class="text-[10px] text-gray-500">APY:</span>
                <input type="number" id="lst-apy-ampLUNA" step="0.01" class="input-dark w-20 text-center font-mono text-green-400" placeholder="" onchange="updateLstApy('ampLUNA', this.value)">
                <span class="text-[10px] text-gray-400">%</span>
            </div>
            <textarea id="lst-paste-ampLUNA" class="input-dark text-[9px] h-16 w-full" placeholder="Paste: Amplified APY 29.68% TVL... 1 ampLUNA = 1.9015 LUNA" onpaste="setTimeout(() => parseLstPaste('ampLUNA'), 100)"></textarea>
            <button onclick="parseLstPaste('ampLUNA')" class="btn-action text-[9px] bg-teal-900/30 text-teal-300">Parse</button>
        </div>
        
        <!-- arbLUNA - AUTO-FETCH -->
        <div id="lst-card-arbLUNA" class="bg-[#161616] rounded-lg p-3 border-2 border-gray-700">
            <div class="flex justify-between items-center mb-1">
                <div class="flex items-center gap-2">
                    <img src="https://raw.githubusercontent.com/defipatriot/aDAO-Image-Files/refs/heads/main/logos/arbLUNA.png" class="w-6 h-6 rounded-full" onerror="this.style.display='none'">
                    <span class="text-orange-400 font-bold text-sm">arbLUNA</span>
                </div>
                <button onclick="openPreviewModal('https://www.erisprotocol.com/terra/arb-vault', 'arbLUNA - Eris Arb')" class="text-[9px] text-orange-400 hover:text-orange-300 bg-orange-900/30 px-2 py-0.5 rounded border border-orange-900/50 cursor-pointer">
                    <i class="fas fa-external-link-alt mr-1"></i> Eris Arb
                </button>
            </div>
            <div class="flex items-center gap-2 mb-2">
                <span class="text-[8px] bg-green-900/50 text-green-400 px-1.5 py-0.5 rounded border border-green-700">‚ö° AUTO-FETCH</span>
                <div id="lst-status-arbLUNA" class="text-[9px] px-2 py-0.5 rounded bg-gray-800 text-gray-500 flex-1 text-center">pending</div>
            </div>
            <div class="flex items-center gap-2 mb-2">
                <span class="text-[10px] text-gray-500">1 arbLUNA =</span>
                <input type="number" id="lst-ratio-arbLUNA" step="0.0001" class="input-dark w-24 text-center font-mono" placeholder="" onchange="updateLstRatio('arbLUNA', this.value)">
                <span class="text-[10px] text-gray-400">LUNA</span>
            </div>
            <div class="flex items-center gap-2 mb-2">
                <span class="text-[8px] bg-red-900/50 text-red-400 px-1.5 py-0.5 rounded border border-red-700">‚úé MANUAL</span>
                <span class="text-[10px] text-gray-500">APY:</span>
                <input type="number" id="lst-apy-arbLUNA" step="0.01" class="input-dark w-20 text-center font-mono text-green-400" placeholder="" onchange="updateLstApy('arbLUNA', this.value)">
                <span class="text-[10px] text-gray-400">%</span>
            </div>
            <textarea id="lst-paste-arbLUNA" class="input-dark text-[9px] h-16 w-full" placeholder="Paste: Arbitrage APY 146.24% TVL... 1 arbLUNA = 2.6873 LUNA" onpaste="setTimeout(() => parseLstPaste('arbLUNA'), 100)"></textarea>
            <button onclick="parseLstPaste('arbLUNA')" class="btn-action text-[9px] bg-orange-900/30 text-orange-300">Parse</button>
        </div>
        
        <!-- bLUNA - AUTO-FETCH -->
        <div id="lst-card-bLUNA" class="bg-[#161616] rounded-lg p-3 border-2 border-gray-700">
            <div class="flex justify-between items-center mb-1">
                <div class="flex items-center gap-2">
                    <img src="https://raw.githubusercontent.com/defipatriot/aDAO-Image-Files/refs/heads/main/logos/bLUNA.png" class="w-6 h-6 rounded-full" onerror="this.style.display='none'">
                    <span class="text-cyan-400 font-bold text-sm">bLUNA</span>
                </div>
                <button onclick="openPreviewModal('https://app.backbonelabs.io/liquid-staking/gravedigger/phoenix-1', 'bLUNA - Backbone Labs')" class="text-[9px] text-cyan-400 hover:text-cyan-300 bg-cyan-900/30 px-2 py-0.5 rounded border border-cyan-900/50 cursor-pointer">
                    <i class="fas fa-external-link-alt mr-1"></i> Backbone
                </button>
            </div>
            <div class="flex items-center gap-2 mb-2">
                <span class="text-[8px] bg-green-900/50 text-green-400 px-1.5 py-0.5 rounded border border-green-700">‚ö° AUTO-FETCH</span>
                <div id="lst-status-bLUNA" class="text-[9px] px-2 py-0.5 rounded bg-gray-800 text-gray-500 flex-1 text-center">pending</div>
            </div>
            <div class="flex items-center gap-2 mb-2">
                <span class="text-[10px] text-gray-500">1 bLUNA =</span>
                <input type="number" id="lst-ratio-bLUNA" step="0.0001" class="input-dark w-24 text-center font-mono" placeholder="" onchange="updateLstRatio('bLUNA', this.value)">
                <span class="text-[10px] text-gray-400">LUNA</span>
            </div>
            <div class="flex items-center gap-2 mb-2">
                <span class="text-[8px] bg-gray-800 text-gray-500 px-1.5 py-0.5 rounded border border-gray-700">N/A</span>
                <span class="text-[10px] text-gray-500">APY:</span>
                <input type="number" id="lst-apy-bLUNA" step="0.01" class="input-dark w-20 text-center font-mono text-gray-500" placeholder="N/A" disabled>
                <span class="text-[10px] text-gray-600">% (BBL doesn't show)</span>
            </div>
            <textarea id="lst-paste-bLUNA" class="input-dark text-[9px] h-16 w-full" placeholder="Paste: Exchange rate 1 LUNA = 0.623302 bLUNA (will auto-convert)" onpaste="setTimeout(() => parseLstPaste('bLUNA'), 100)"></textarea>
            <button onclick="parseLstPaste('bLUNA')" class="btn-action text-[9px] bg-cyan-900/30 text-cyan-300">Parse</button>
        </div>
        
        <!-- ampCAPA - AUTO-FETCH -->
        <div id="lst-card-ampCAPA" class="bg-[#161616] rounded-lg p-3 border-2 border-gray-700">
            <div class="flex justify-between items-center mb-1">
                <div class="flex items-center gap-2">
                    <img src="https://raw.githubusercontent.com/defipatriot/aDAO-Image-Files/refs/heads/main/logos/ampCAPA.png" class="w-6 h-6 rounded-full" onerror="this.style.display='none'">
                    <span class="text-purple-400 font-bold text-sm">ampCAPA</span>
                </div>
                <button onclick="openPreviewModal('https://www.erisprotocol.com/terra/amplifier/CAPA', 'ampCAPA - Eris')" class="text-[9px] text-purple-400 hover:text-purple-300 bg-purple-900/30 px-2 py-0.5 rounded border border-purple-900/50 cursor-pointer">
                    <i class="fas fa-external-link-alt mr-1"></i> Eris
                </button>
            </div>
            <div class="flex items-center gap-2 mb-2">
                <span class="text-[8px] bg-green-900/50 text-green-400 px-1.5 py-0.5 rounded border border-green-700">‚ö° AUTO-FETCH</span>
                <div id="lst-status-ampCAPA" class="text-[9px] px-2 py-0.5 rounded bg-gray-800 text-gray-500 flex-1 text-center">pending</div>
            </div>
            <div class="flex items-center gap-2 mb-2">
                <span class="text-[10px] text-gray-500">1 ampCAPA =</span>
                <input type="number" id="lst-ratio-ampCAPA" step="0.0001" class="input-dark w-24 text-center font-mono" placeholder="" onchange="updateLstRatio('ampCAPA', this.value)">
                <span class="text-[10px] text-gray-400">CAPA</span>
            </div>
            <div class="flex items-center gap-2 mb-2">
                <span class="text-[8px] bg-red-900/50 text-red-400 px-1.5 py-0.5 rounded border border-red-700">‚úé MANUAL</span>
                <span class="text-[10px] text-gray-500">APY:</span>
                <input type="number" id="lst-apy-ampCAPA" step="0.01" class="input-dark w-20 text-center font-mono text-green-400" placeholder="" onchange="updateLstApy('ampCAPA', this.value)">
                <span class="text-[10px] text-gray-400">%</span>
            </div>
            <textarea id="lst-paste-ampCAPA" class="input-dark text-[9px] h-16 w-full" placeholder="Paste: Amplified APY 4.83% TVL... 1 ampCAPA = 1.1055 CAPA" onpaste="setTimeout(() => parseLstPaste('ampCAPA'), 100)"></textarea>
            <button onclick="parseLstPaste('ampCAPA')" class="btn-action text-[9px] bg-purple-900/30 text-purple-300">Parse</button>
        </div>
        
        <!-- ampROAR - AUTO-FETCH -->
        <div id="lst-card-ampROAR" class="bg-[#161616] rounded-lg p-3 border-2 border-gray-700">
            <div class="flex justify-between items-center mb-1">
                <div class="flex items-center gap-2">
                    <img src="https://raw.githubusercontent.com/defipatriot/aDAO-Image-Files/refs/heads/main/logos/ampROAR.png" class="w-6 h-6 rounded-full" onerror="this.style.display='none'">
                    <span class="text-yellow-400 font-bold text-sm">ampROAR</span>
                </div>
                <button onclick="openPreviewModal('https://www.erisprotocol.com/terra/amplifier/ROAR', 'ampROAR - Eris')" class="text-[9px] text-yellow-400 hover:text-yellow-300 bg-yellow-900/30 px-2 py-0.5 rounded border border-yellow-900/50 cursor-pointer">
                    <i class="fas fa-external-link-alt mr-1"></i> Eris
                </button>
            </div>
            <div class="flex items-center gap-2 mb-2">
                <span class="text-[8px] bg-green-900/50 text-green-400 px-1.5 py-0.5 rounded border border-green-700">‚ö° AUTO-FETCH</span>
                <div id="lst-status-ampROAR" class="text-[9px] px-2 py-0.5 rounded bg-gray-800 text-gray-500 flex-1 text-center">pending</div>
            </div>
            <div class="flex items-center gap-2 mb-2">
                <span class="text-[10px] text-gray-500">1 ampROAR =</span>
                <input type="number" id="lst-ratio-ampROAR" step="0.0001" class="input-dark w-24 text-center font-mono" placeholder="" onchange="updateLstRatio('ampROAR', this.value)">
                <span class="text-[10px] text-gray-400">ROAR</span>
            </div>
            <div class="flex items-center gap-2 mb-2">
                <span class="text-[8px] bg-red-900/50 text-red-400 px-1.5 py-0.5 rounded border border-red-700">‚úé MANUAL</span>
                <span class="text-[10px] text-gray-500">APY:</span>
                <input type="number" id="lst-apy-ampROAR" step="0.01" class="input-dark w-20 text-center font-mono text-green-400" placeholder="" onchange="updateLstApy('ampROAR', this.value)">
                <span class="text-[10px] text-gray-400">%</span>
            </div>
            <textarea id="lst-paste-ampROAR" class="input-dark text-[9px] h-16 w-full" placeholder="Paste: Amplified APY 9.92% TVL... 1 ampROAR = 1.1087 ROAR" onpaste="setTimeout(() => parseLstPaste('ampROAR'), 100)"></textarea>
            <button onclick="parseLstPaste('ampROAR')" class="btn-action text-[9px] bg-yellow-900/30 text-yellow-300">Parse</button>
        </div>
        
        <!-- xASTRO - MANUAL ONLY -->
        <div id="lst-card-xASTRO" class="bg-[#161616] rounded-lg p-3 border-2 border-red-900/50">
            <div class="flex justify-between items-center mb-1">
                <div class="flex items-center gap-2">
                    <img src="https://raw.githubusercontent.com/defipatriot/aDAO-Image-Files/refs/heads/main/logos/xASTRO.png" class="w-6 h-6 rounded-full" onerror="this.style.display='none'">
                    <span class="text-blue-400 font-bold text-sm">xASTRO</span>
                </div>
                <button onclick="openPreviewModal('https://app.astroport.fi/governance', 'xASTRO - Astroport')" class="text-[9px] text-blue-400 hover:text-blue-300 bg-blue-900/30 px-2 py-0.5 rounded border border-blue-900/50 cursor-pointer">
                    <i class="fas fa-external-link-alt mr-1"></i> Astroport
                </button>
            </div>
            <div class="flex items-center gap-2 mb-2">
                <span class="text-[8px] bg-red-900/50 text-red-400 px-1.5 py-0.5 rounded border border-red-700">‚úé ALL MANUAL</span>
                <div id="lst-status-xASTRO" class="text-[9px] px-2 py-0.5 rounded bg-gray-800 text-gray-500 flex-1 text-center">pending</div>
            </div>
            <div class="flex items-center gap-2 mb-2">
                <span class="text-[10px] text-gray-500">1 xASTRO =</span>
                <input type="number" id="lst-ratio-xASTRO" step="0.0001" class="input-dark w-24 text-center font-mono" placeholder="" onchange="updateLstRatio('xASTRO', this.value)">
                <span class="text-[10px] text-gray-400">ASTRO</span>
            </div>
            <div class="flex items-center gap-2 mb-2">
                <span class="text-[10px] text-gray-500">APY:</span>
                <input type="number" id="lst-apy-xASTRO" step="0.01" class="input-dark w-20 text-center font-mono text-green-400" placeholder="" onchange="updateLstApy('xASTRO', this.value)">
                <span class="text-[10px] text-gray-400">%</span>
            </div>
            <textarea id="lst-paste-xASTRO" class="input-dark text-[9px] h-16 w-full" placeholder="Paste: 22.49% APY 1:1.22 xASTRO:ASTRO" onpaste="setTimeout(() => parseLstPaste('xASTRO'), 100)"></textarea>
            <button onclick="parseLstPaste('xASTRO')" class="btn-action text-[9px] bg-blue-900/30 text-blue-300">Parse</button>
        </div>
    </div>
</div>

<!-- WS: TOKEN PRICES -->
<div id="ws-prices" class="workspace">
    <!-- Header -->
    <div class="bg-[#161616] border border-green-900/50 rounded-lg p-4 mb-4">
        <div class="flex justify-between items-center mb-3">
            <div class="flex items-center gap-3">
                <i class="fas fa-coins text-green-400 text-xl"></i>
                <div>
                    <h2 class="text-green-400 font-bold text-sm">Token Prices</h2>
                    <p class="text-gray-500 text-[10px]">Fetch unique token prices from CoinGecko + calculate LST prices from ratios</p>
                </div>
            </div>
            <div class="flex items-center gap-3">
                <button onclick="openPricePreview('https://app.astroport.fi/swap?chain=terra&to=ibc%2F4B44179AC2F0BEE50C16A673B3B886398988692885B2848A1C8AEF27148B3961&from=uluna')" class="text-[9px] text-cyan-400 hover:text-cyan-300 bg-cyan-900/30 px-2 py-0.5 rounded border border-cyan-900/50" title="Check FUEL price on Astroport">
                    <i class="fas fa-external-link-alt mr-1"></i> FUEL Price
                </button>
                <button onclick="openPricePreview('https://app.astroport.fi/swap?chain=terra')" class="text-[9px] text-blue-400 hover:text-blue-300 bg-blue-900/30 px-2 py-0.5 rounded border border-blue-900/50" title="Astroport Swap">
                    <i class="fas fa-exchange-alt mr-1"></i> Astroport
                </button>
                <button id="prices-all-status" onclick="togglePricesTabOverride()" class="px-3 py-1 rounded text-[10px] font-bold bg-red-900/30 text-red-400 border border-red-700 cursor-pointer hover:opacity-80" title="Click to override">
                    <i class="fas fa-exclamation-circle mr-1"></i> 0 Tokens
                </button>
                <button onclick="fetchAllTokenPrices()" class="bg-green-900/30 hover:bg-green-900/50 text-green-400 px-3 py-1.5 rounded text-[10px] border border-green-900/50 font-bold">
                    <i class="fas fa-sync-alt mr-1"></i> Fetch All Prices
                </button>
            </div>
        </div>
        
        <!-- Price Summary -->
        <div class="grid grid-cols-5 gap-3 text-[10px]">
            <div class="bg-[#0D0D0D] rounded p-2 text-center">
                <div class="text-gray-500">LUNA</div>
                <div id="price-luna" class="text-green-400 font-mono font-bold text-lg">$--</div>
            </div>
            <div class="bg-[#0D0D0D] rounded p-2 text-center">
                <div class="text-gray-500">Unique Tokens</div>
                <div id="price-found-count" class="text-white font-mono font-bold text-lg">0</div>
            </div>
            <div class="bg-[#0D0D0D] rounded p-2 text-center">
                <div class="text-gray-500">Auto (CoinGecko)</div>
                <div id="price-cg-count" class="text-green-400 font-mono font-bold text-lg">0</div>
            </div>
            <div class="bg-[#0D0D0D] rounded p-2 text-center">
                <div class="text-gray-500">Calculated</div>
                <div id="price-calc-count" class="text-yellow-400 font-mono font-bold text-lg">0</div>
            </div>
            <div class="bg-[#0D0D0D] rounded p-2 text-center">
                <div class="text-gray-500">Manual/Skipped</div>
                <div id="price-manual-count" class="text-orange-400 font-mono font-bold text-lg">0</div>
            </div>
        </div>
    </div>
    
    <!-- Token Price Lists -->
    <div class="grid grid-cols-2 gap-4">
        <!-- Auto-Fetched Prices (CoinGecko + Calculated) -->
        <div class="preview-card">
            <div class="flex justify-between items-center mb-3 border-b border-gray-800 pb-2">
                <h3 class="text-xs font-bold text-white flex items-center gap-2">
                    <span class="text-green-400">‚úì</span> Auto-Fetched Prices
                </h3>
                <div class="text-[9px] text-gray-500">
                    <span class="text-green-400">‚óè</span> CoinGecko 
                    <span class="text-yellow-400 ml-2">‚óè</span> Calculated
                </div>
            </div>
            <div id="token-price-auto" class="space-y-1 max-h-[350px] overflow-y-auto custom-scroll">
                <div class="text-gray-500 text-[10px] text-center p-4">Click "Fetch All Prices" to load</div>
            </div>
        </div>
        
        <!-- Manual Entry / Not Found -->
        <div class="preview-card">
            <div class="flex justify-between items-center mb-3 border-b border-gray-800 pb-2">
                <h3 class="text-xs font-bold text-white flex items-center gap-2">
                    <span class="text-red-400">‚úó</span> Manual Entry Required
                </h3>
                <div class="text-[9px] text-gray-500">Enter price or check to skip</div>
            </div>
            
            <!-- Add Custom Token -->
            <div class="flex items-center gap-2 mb-3 p-2 bg-[#0D0D0D] rounded border border-gray-700">
                <span class="text-[10px] text-gray-400">Add Token:</span>
                <input type="text" id="custom-token-name" class="input-dark w-24 text-[10px] py-1 uppercase" placeholder="TOKEN" maxlength="12">
                <span class="text-gray-500 text-[10px]">$</span>
                <input type="number" id="custom-token-price" step="any" class="input-dark w-24 text-[10px] text-right py-1" placeholder="0.00">
                <button onclick="addCustomToken()" class="bg-green-900/30 hover:bg-green-900/50 text-green-400 px-2 py-1 rounded text-[9px] border border-green-900/50">
                    <i class="fas fa-plus mr-1"></i>Add
                </button>
            </div>
            
            <div id="token-price-manual" class="space-y-1 max-h-[300px] overflow-y-auto custom-scroll">
                <div class="text-gray-500 text-[10px] text-center p-4">Tokens not found on CoinGecko will appear here</div>
            </div>
        </div>
    </div>
</div>

<!-- Price Preview Modal -->
<div id="price-preview-modal" class="fixed inset-0 bg-black/80 z-50 hidden flex items-center justify-center p-4">
    <div class="bg-[#1a1a1a] rounded-lg border border-gray-700 w-full max-w-4xl max-h-[80vh] flex flex-col">
        <div class="flex justify-between items-center p-3 border-b border-gray-700">
            <div class="flex items-center gap-2">
                <i class="fas fa-chart-line text-cyan-400"></i>
                <span class="text-white font-bold text-sm">Price Lookup</span>
                <a id="price-preview-link" href="#" target="_blank" class="text-[9px] text-gray-400 hover:text-gray-300">
                    <i class="fas fa-external-link-alt mr-1"></i> Open in new tab
                </a>
            </div>
            <button onclick="closePricePreview()" class="text-gray-400 hover:text-white text-xl px-2">√ó</button>
        </div>
        <div class="flex-1 overflow-hidden">
            <iframe id="price-preview-iframe" class="w-full h-full min-h-[500px]" src="" frameborder="0"></iframe>
        </div>
    </div>
</div>

<!-- WS: VOTION -->
<div id="ws-votion" class="workspace">
    <!-- Ratios Status + Votion Summary -->
    <div class="grid grid-cols-12 gap-4 mb-4">
        <!-- Ratios & APY Status Card -->
        <div id="votion-ratios-card" class="col-span-4 bg-[#161616] p-3 rounded border-2 border-red-700 flex flex-col gap-2">
            <div class="flex justify-between items-center">
                <span class="text-[10px] text-gray-400 font-bold">Ratios Tab Status</span>
                <button onclick="switchTab('prices')" class="text-[9px] text-teal-400 hover:text-teal-300 flex items-center gap-1 bg-teal-900/30 px-2 py-1 rounded border border-teal-900/50">
                    <i class="fas fa-cog"></i> Prices Tab
                </button>
            </div>
            <div id="votion-ratios-status" class="text-center py-1">
                <div class="text-2xl mb-1">‚ö†Ô∏è</div>
                <div class="text-red-400 font-bold text-[11px]">NOT READY</div>
                <div class="text-gray-500 text-[9px]">Complete Prices/Ratios tab first</div>
            </div>
            <div class="grid grid-cols-2 gap-1 text-[9px] border-t border-gray-800 pt-2">
                <div class="text-gray-500 font-bold">Ratios:</div>
                <div class="text-gray-500 font-bold">APYs:</div>
                <div class="flex items-center gap-1">
                    <span id="votion-arb-ratio-status" class="text-red-400">‚úó</span>
                    <span class="text-orange-400">arb:</span>
                    <span id="ratioArb" class="text-white font-mono">--</span>
                </div>
                <div class="flex items-center gap-1">
                    <span id="votion-arb-apy-status" class="text-red-400">‚úó</span>
                    <span class="text-orange-400">arb:</span>
                    <span id="apyArb" class="text-white font-mono">--</span>
                </div>
                <div class="flex items-center gap-1">
                    <span id="votion-amp-ratio-status" class="text-red-400">‚úó</span>
                    <span class="text-cyan-400">amp:</span>
                    <span id="ratioAmp" class="text-white font-mono">--</span>
                </div>
                <div class="flex items-center gap-1">
                    <span id="votion-amp-apy-status" class="text-red-400">‚úó</span>
                    <span class="text-cyan-400">amp:</span>
                    <span id="apyAmp" class="text-white font-mono">--</span>
                </div>
            </div>
        </div>
        
        <!-- Votion Summary -->
        <div class="col-span-4 bg-[#161616] p-3 rounded border border-gray-800 flex flex-col gap-2">
            <div class="text-[9px] text-gray-500 uppercase font-bold">Votion Summary</div>
            <div class="grid grid-cols-2 gap-2 text-[10px]">
                <div><span class="text-gray-500">Lockups:</span> <span id="votion-lock-count" class="text-white font-mono">0</span></div>
                <div><span class="text-gray-500">VP:</span> <span id="votion-total-vp" class="text-teal-400 font-mono font-bold">0</span></div>
                <div><span class="text-gray-500">USD:</span> <span id="votion-total-usd" class="text-green-400 font-mono">$0</span></div>
                <div><span class="text-gray-500">Rew:</span> <span id="votion-total-rew" class="text-green-400 font-mono">$0</span></div>
            </div>
            <div class="text-[8px] text-gray-500 mt-1 border-t border-gray-700 pt-2">
                VP = LUNA √ó 10 (Max) | √ó 2 (3mo) | √ó 1 (1wk)
            </div>
        </div>
        
        <!-- Lockup Checklist -->
        <div class="col-span-4 bg-[#161616] p-3 rounded border border-gray-800 flex flex-col gap-2">
            <div class="flex justify-between items-center">
                <div class="text-[9px] text-gray-500 uppercase font-bold">Lockup Checklist (6 total)</div>
                <span id="votion-checklist-count" class="text-[9px] text-red-400">0/6</span>
            </div>
            <div class="grid grid-cols-2 gap-1 text-[9px]">
                <div id="votion-chk-arbmax" class="flex items-center gap-1 text-gray-600">
                    <input type="checkbox" id="votion-skip-arbmax" class="w-3 h-3" onchange="updateVotionChecklist(); updateWorkflowStatus();" title="Skip this lockup">
                    <span class="lock-status">‚òê</span> arbLUNA Max
                </div>
                <div id="votion-chk-ampmax" class="flex items-center gap-1 text-gray-600">
                    <input type="checkbox" id="votion-skip-ampmax" class="w-3 h-3" onchange="updateVotionChecklist(); updateWorkflowStatus();" title="Skip this lockup">
                    <span class="lock-status">‚òê</span> ampLUNA Max
                </div>
                <div id="votion-chk-arb3mo" class="flex items-center gap-1 text-gray-600">
                    <input type="checkbox" id="votion-skip-arb3mo" class="w-3 h-3" onchange="updateVotionChecklist(); updateWorkflowStatus();" title="Skip this lockup">
                    <span class="lock-status">‚òê</span> arbLUNA 3mo
                </div>
                <div id="votion-chk-amp3mo" class="flex items-center gap-1 text-gray-600">
                    <input type="checkbox" id="votion-skip-amp3mo" class="w-3 h-3" onchange="updateVotionChecklist(); updateWorkflowStatus();" title="Skip this lockup">
                    <span class="lock-status">‚òê</span> ampLUNA 3mo
                </div>
                <div id="votion-chk-arb1wk" class="flex items-center gap-1 text-gray-600">
                    <input type="checkbox" id="votion-skip-arb1wk" class="w-3 h-3" onchange="updateVotionChecklist(); updateWorkflowStatus();" title="Skip this lockup">
                    <span class="lock-status">‚òê</span> arbLUNA 1wk
                </div>
                <div id="votion-chk-amp1wk" class="flex items-center gap-1 text-gray-600">
                    <input type="checkbox" id="votion-skip-amp1wk" class="w-3 h-3" onchange="updateVotionChecklist(); updateWorkflowStatus();" title="Skip this lockup">
                    <span class="lock-status">‚òê</span> ampLUNA 1wk
                </div>
            </div>
            <div id="votion-confirm-section" class="hidden border-t border-gray-800 pt-2 mt-1">
                <button onclick="confirmVotionComplete()" class="w-full bg-green-900/30 hover:bg-green-900/50 text-green-400 py-2 rounded text-[10px] font-bold border border-green-700">
                    <i class="fas fa-check-circle mr-1"></i> Confirm & Complete Step ‚ë£
                </button>
            </div>
            <div class="text-[8px] text-gray-600 border-t border-gray-800 pt-1 mt-1">
                ‚òë Check to skip a lockup if not enough funds
            </div>
        </div>
    </div>
    
    <!-- Votion Lockups -->
    <div class="grid grid-cols-12 gap-4 mb-4">
        <div class="col-span-12 bg-[#161616] p-3 rounded border border-teal-900/30 flex flex-col gap-2">
            <div class="flex justify-between items-center">
                <div class="flex items-center gap-2">
                    <span class="text-[10px] text-gray-400 font-bold">Votion Lockups</span>
                    <span class="text-gray-500 font-normal text-[9px]">(paste each lockup page separately)</span>
                </div>
                <div class="flex items-center gap-2">
                    <a href="https://votion.io" target="_blank" class="text-[9px] text-purple-400 hover:text-purple-300 bg-purple-900/30 px-2 py-0.5 rounded border border-purple-900/50">
                        <i class="fas fa-external-link-alt mr-1"></i> Votion.io
                    </a>
                    <button onclick="clearPaste('votionPaste')" class="text-[9px] text-red-400 hover:text-red-300">Clear</button>
                </div>
            </div>
            <textarea id="votionPaste" class="input-dark h-24 font-mono text-[10px]" placeholder="Ctrl+A / Ctrl+C on a Votion lockup page... each lockup has its own optimization"></textarea>
            <div class="flex gap-2 items-center">
                <button onclick="parseVotion()" class="btn-action flex-1 bg-teal-900/40 text-teal-200 border border-teal-900">Add Lockup (Paste)</button>
                <button onclick="fetchAllVotion()" class="btn-action flex-1 bg-purple-900/40 text-purple-200 border border-purple-900">
                    <i class="fas fa-download mr-1"></i> Fetch All from API
                </button>
                <button onclick="clearVotionLocks()" class="btn-action w-28 bg-red-900/30 text-red-300 border border-red-900/50">Clear All</button>
            </div>
            <div id="votion-fetch-status" class="text-[9px] text-gray-500 mt-1"></div>
        </div>
    </div>
    
    <!-- Lockups Grid - Each lockup as its own card with vote allocations -->
    <div id="votion-lockups" class="grid grid-cols-1 xl:grid-cols-2 gap-4">
        <div class="text-gray-600 text-[10px] italic text-center py-8 col-span-full border border-dashed border-gray-800 rounded">
            No lockups loaded. Click "Fetch All from API" to auto-load, or paste each Votion page manually.
        </div>
    </div>
</div>

<!-- WS 2: PD BRIBES -->
<div id="ws-pdbribes" class="workspace">
    <!-- Top: Status + Fetch -->
    <div class="grid grid-cols-12 gap-4 mb-4">
        <!-- Coverage Status -->
        <div class="col-span-4 bg-[#161616] p-3 rounded border border-gray-800">
            <div class="flex justify-between items-center mb-2">
                <div class="text-[9px] text-gray-500 uppercase font-bold">Epoch Coverage</div>
                <button onclick="fetchPdBribesFromGithub()" class="text-[9px] text-teal-400 hover:text-teal-300 flex items-center gap-1">
                    <span id="pd-fetch-status">‚ü≥</span> Fetch from GitHub
                </button>
            </div>
            <div class="flex items-center gap-3 mb-2">
                <div id="pd-coverage-light" class="w-4 h-4 rounded-full bg-gray-700 border-2 border-gray-600"></div>
                <div class="text-[10px]">
                    <span class="text-gray-500">Target Epoch:</span>
                    <span id="pd-current-epoch" class="text-white font-mono ml-1">-</span>
                </div>
            </div>
            <div class="text-[9px] text-gray-500">
                Covered: <span id="pd-covered-range" class="text-green-400 font-mono">-</span>
            </div>
            <div class="text-[9px] text-gray-500 mt-1">
                Missing: <span id="pd-missing-epochs" class="text-red-400 font-mono">-</span>
            </div>
        </div>
        
        <!-- Alert Box - shows when epoch not covered -->
        <div id="pd-alert-box" class="col-span-4 bg-red-900/30 border border-red-700 rounded p-3 hidden">
            <div class="flex items-center gap-2 mb-2">
                <div class="text-red-400 text-lg animate-pulse">‚ö†</div>
                <div class="text-red-300 font-bold text-[11px]">Epoch <span id="pd-alert-epoch">-</span> NOT COVERED!</div>
            </div>
            <p class="text-red-200/70 text-[9px] mb-2">Paste the new PD bribes proposal below to add coverage for this epoch.</p>
            <div class="text-[8px] text-red-400/60">
                Expected: Range covering epoch <span id="pd-alert-epoch2">-</span> (e.g., [<span id="pd-alert-range">160-163</span>])
            </div>
        </div>
        
        <!-- Success Box - shows when epoch is covered -->
        <div id="pd-success-box" class="col-span-4 bg-green-900/20 border border-green-700 rounded p-3 hidden">
            <div class="flex items-center gap-2 mb-2">
                <div class="text-green-400 text-lg">‚úì</div>
                <div class="text-green-300 font-bold text-[11px]">Epoch <span id="pd-success-epoch">-</span> Covered</div>
            </div>
            <p class="text-green-200/70 text-[9px]">
                Range: <span id="pd-success-range" class="font-mono">-</span>
            </p>
            <p class="text-green-200/50 text-[8px] mt-1">
                Bribes: <span id="pd-success-bribes" class="font-mono">-</span>/epoch
            </p>
            <button onclick="confirmPdBribesComplete()" class="w-full mt-2 bg-green-900/30 hover:bg-green-900/50 text-green-400 py-1 rounded text-[9px] font-bold border border-green-700">
                <i class="fas fa-check-circle mr-1"></i> Confirm & Complete Step ‚ë§
            </button>
        </div>
        
        <!-- Summary Stats -->
        <div class="col-span-4 bg-[#161616] p-3 rounded border border-gray-800">
            <div class="text-[9px] text-gray-500 uppercase font-bold mb-2">Master File Summary</div>
            <div class="grid grid-cols-2 gap-1 text-[10px]">
                <span class="text-gray-500">Ranges Loaded:</span>
                <span id="pd-props-count" class="text-white font-mono text-right">0</span>
                <span class="text-gray-500">Total Epochs:</span>
                <span id="pd-total-epochs" class="text-white font-mono text-right">0</span>
                <span class="text-gray-500">Avg Bribes:</span>
                <span id="pd-total-bribes" class="text-green-400 font-mono text-right">$0</span>
            </div>
            <div class="mt-2 flex gap-1">
                <button onclick="exportPdBribesJson()" class="btn-action flex-1 bg-green-900/40 text-green-200 border border-green-900 text-[9px] mt-0">Download</button>
                <button onclick="copyPdBribesJson()" class="btn-action flex-1 bg-blue-900/40 text-blue-200 border border-blue-900 text-[9px] mt-0">Copy</button>
            </div>
        </div>
    </div>
    
    <!-- Current Epoch Bribes Preview -->
    <div id="pd-current-bribes-section" class="preview-card mb-4 hidden">
        <div class="flex justify-between items-center mb-3 border-b border-gray-800 pb-2">
            <h3 class="text-xs font-bold text-white">
                <i class="fas fa-coins text-yellow-400 mr-2"></i>
                Current Epoch Bribes - <span id="pd-preview-epoch" class="text-yellow-400">-</span>
            </h3>
            <div class="text-[9px] text-gray-500">
                LUNA Price: <span id="pd-preview-luna-price" class="text-green-400 font-mono">$--</span>
            </div>
        </div>
        <div id="pd-current-bribes-grid" class="space-y-3">
            <!-- Will be populated with bribe data -->
        </div>
    </div>
    
    <!-- Add New Prop -->
    <div class="grid grid-cols-12 gap-4 mb-4">
        <div class="col-span-8 bg-[#161616] p-3 rounded border border-gray-800 flex flex-col gap-2">
            <div class="flex justify-between items-center">
                <h3 class="text-orange-400 font-bold text-xs">Add New Bribe Range <span class="text-gray-500 font-normal text-[10px]">(paste proposal text)</span></h3>
                <div class="flex items-center gap-2">
                    <a href="https://station.terra.money/proposal/alliance/terra1j5zqhemayf6kz3c6hzlh9u0yqg72g7eg3falhgre9xf90afnhvuqa8zyz5" target="_blank" class="text-[9px] text-orange-400 hover:text-orange-300 bg-orange-900/30 px-2 py-0.5 rounded border border-orange-900/50">
                        <i class="fas fa-external-link-alt mr-1"></i> PD DAO Proposals
                    </a>
                    <button onclick="clearPaste('pdPaste')" class="text-[9px] text-red-400 hover:text-red-300">Clear</button>
                </div>
            </div>
            <textarea id="pdPaste" class="input-dark h-32 font-mono text-[10px]" placeholder="Bribes for [160-163]:
Gauge: project
AMPLUNA-LUNA (55.44%): $ 150 = 1973.01 LUNA per epoch
..."></textarea>
            <button onclick="parsePdBribes()" class="btn-action bg-orange-900/40 text-orange-200 border border-orange-900">Parse & Add Range</button>
        </div>
        
        <!-- New Prop Preview -->
        <div class="col-span-4 bg-[#161616] p-3 rounded border border-gray-800">
            <div class="text-[9px] text-gray-500 uppercase font-bold mb-2">New Range Preview</div>
            <div class="space-y-1 text-[10px]">
                <div class="flex justify-between">
                    <span class="text-gray-500">Epoch Range:</span>
                    <span id="pd-new-range" class="text-white font-mono">-</span>
                </div>
                <div class="flex justify-between">
                    <span class="text-gray-500">Epochs:</span>
                    <span id="pd-new-count" class="text-white font-mono">0</span>
                </div>
                <div class="flex justify-between">
                    <span class="text-gray-500">$/Epoch:</span>
                    <span id="pd-new-per-epoch" class="text-green-400 font-mono">$0</span>
                </div>
                <div class="flex justify-between">
                    <span class="text-gray-500">Total:</span>
                    <span id="pd-new-total" class="text-green-400 font-mono font-bold">$0</span>
                </div>
                <div class="flex justify-between">
                    <span class="text-gray-500">Pools:</span>
                    <span id="pd-new-pools" class="text-white font-mono">0</span>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Props History -->
    <div class="preview-card">
        <div class="flex justify-between items-center mb-2 border-b border-gray-800 pb-2">
            <h3 class="text-xs font-bold text-white">All Bribe Ranges (for tla_pd_bribes.json)</h3>
            <button onclick="clearAllPdBribes()" class="text-[9px] text-red-400 hover:text-red-300">Clear All</button>
        </div>
        <div id="pd-history" class="max-h-[400px] overflow-y-auto text-xs custom-scroll space-y-2"></div>
    </div>
</div>

<!-- WS 3: ASTROPORT -->
<div id="ws-astro" class="workspace">
    <!-- Mode-specific content will be rendered here -->
    <div id="astro-staging-mode">
        <!-- STAGING MODE: 4-day 180d capture -->
        <div class="bg-yellow-900/20 border border-yellow-700 rounded-lg p-4 mb-4">
            <div class="flex items-center gap-3 mb-3">
                <div class="text-yellow-400 text-xl">‚ö†</div>
                <div class="flex-grow">
                    <h3 class="text-yellow-400 font-bold text-sm">Staging Mode - 4-Day 180d Capture</h3>
                    <p class="text-yellow-200/70 text-[10px]">180d requires 4 days of captures (Astroport returns ~45 points at 4-day intervals). Each day adds new data points.</p>
                </div>
                <div class="text-right">
                    <div class="text-[9px] text-gray-500">Current Working Day</div>
                    <select id="staging-current-day" class="input-dark text-sm font-bold w-24" onchange="onStagingDayChange()">
                        <option value="day1">Day 1</option>
                        <option value="day2">Day 2</option>
                        <option value="day3">Day 3</option>
                        <option value="day4">Day 4</option>
                    </select>
                </div>
            </div>
            
            <!-- 4-Day Progress Tracker -->
            <div class="grid grid-cols-4 gap-2 mb-4">
                <div id="staging-day1-card" class="bg-[#0D0D0D] rounded p-3 border-2 border-gray-800 cursor-pointer hover:border-gray-600" onclick="selectStagingDay('day1')">
                    <div class="flex justify-between items-center mb-1">
                        <span class="text-[10px] font-bold text-gray-400">Day 1</span>
                        <span id="staging-day1-status" class="text-[9px] text-gray-600">Not loaded</span>
                    </div>
                    <div id="staging-day1-lps" class="text-lg font-bold text-gray-600">0 LPs</div>
                    <div id="staging-day1-date" class="text-[8px] text-gray-600">-</div>
                </div>
                <div id="staging-day2-card" class="bg-[#0D0D0D] rounded p-3 border-2 border-gray-800 cursor-pointer hover:border-gray-600" onclick="selectStagingDay('day2')">
                    <div class="flex justify-between items-center mb-1">
                        <span class="text-[10px] font-bold text-gray-400">Day 2</span>
                        <span id="staging-day2-status" class="text-[9px] text-gray-600">Not loaded</span>
                    </div>
                    <div id="staging-day2-lps" class="text-lg font-bold text-gray-600">0 LPs</div>
                    <div id="staging-day2-date" class="text-[8px] text-gray-600">-</div>
                </div>
                <div id="staging-day3-card" class="bg-[#0D0D0D] rounded p-3 border-2 border-gray-800 cursor-pointer hover:border-gray-600" onclick="selectStagingDay('day3')">
                    <div class="flex justify-between items-center mb-1">
                        <span class="text-[10px] font-bold text-gray-400">Day 3</span>
                        <span id="staging-day3-status" class="text-[9px] text-gray-600">Not loaded</span>
                    </div>
                    <div id="staging-day3-lps" class="text-lg font-bold text-gray-600">0 LPs</div>
                    <div id="staging-day3-date" class="text-[8px] text-gray-600">-</div>
                </div>
                <div id="staging-day4-card" class="bg-[#0D0D0D] rounded p-3 border-2 border-gray-800 cursor-pointer hover:border-gray-600" onclick="selectStagingDay('day4')">
                    <div class="flex justify-between items-center mb-1">
                        <span class="text-[10px] font-bold text-gray-400">Day 4</span>
                        <span id="staging-day4-status" class="text-[9px] text-gray-600">Not loaded</span>
                    </div>
                    <div id="staging-day4-lps" class="text-lg font-bold text-gray-600">0 LPs</div>
                    <div id="staging-day4-date" class="text-[8px] text-gray-600">-</div>
                </div>
            </div>
            
            <!-- File Management -->
            <div class="flex items-center gap-2 flex-wrap text-[10px]">
                <button onclick="fetchAllStagingDays()" class="btn-action bg-blue-900/40 text-blue-300 border border-blue-700 px-3">üîÑ Fetch All Days from GitHub</button>
                <button onclick="loadStagingFile()" class="btn-action bg-gray-800 text-gray-300 border border-gray-700 px-3">üìÇ Load Day File</button>
                <button onclick="exportCurrentDay()" class="btn-action bg-yellow-900/40 text-yellow-300 border border-yellow-700 px-3">üíæ Export Current Day</button>
                <input type="file" id="staging-file-input" class="hidden" accept=".json" onchange="handleStagingFileLoad(event)">
                <div class="flex-grow"></div>
                <span id="staging-fetch-status" class="text-gray-500">-</span>
            </div>
        </div>
        
        <!-- LP Progress Overview for Current Day -->
        <div class="bg-[#161616] rounded border border-gray-800 p-3 mb-4">
            <div class="flex items-center justify-between mb-2">
                <h3 class="text-sm font-bold text-white">Current Day Progress: <span id="staging-day-label" class="text-yellow-400">Day 1</span></h3>
                <div class="text-[9px] text-gray-500">
                    <span id="staging-day-complete" class="text-green-400">0</span> / <span id="staging-day-total" class="text-white">0</span> LPs captured
                </div>
            </div>
            <div id="staging-lp-grid" class="grid grid-cols-6 gap-1 max-h-[120px] overflow-y-auto custom-scroll"></div>
        </div>
        
        <!-- Main Capture Interface -->
        <div class="grid grid-cols-12 gap-4 mb-4">
            <!-- LP Selection Panel -->
            <div class="col-span-3 bg-[#161616] p-3 rounded border border-gray-800">
                <div class="text-[9px] text-gray-500 uppercase font-bold mb-2">1. Select LP</div>
                <select id="staging-lp-select" class="input-dark w-full text-[11px] mb-3" onchange="onStagingLpSelect()">
                    <option value="">-- Select LP --</option>
                </select>
                
                <div class="text-[9px] text-gray-500 uppercase font-bold mb-2">LP Status (All Days)</div>
                <div class="space-y-1 text-[9px]">
                    <div class="flex justify-between">
                        <span class="text-gray-500">Days Captured:</span>
                        <span id="staging-lp-days" class="text-gray-600">0/4</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-500">Total Liq Points:</span>
                        <span id="staging-lp-liq-points" class="text-cyan-400">0</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-500">Total Vol Points:</span>
                        <span id="staging-lp-vol-points" class="text-purple-400">0</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-500">This Day:</span>
                        <span id="staging-lp-thisday" class="text-gray-600">Not captured</span>
                    </div>
                </div>
                
                <div class="border-t border-gray-800 mt-3 pt-3">
                    <label class="flex items-center gap-2 text-[9px] text-red-400 cursor-pointer p-1 rounded hover:bg-red-900/20">
                        <input type="checkbox" id="staging-liq-unavailable" onchange="onStagingUnavailableChange('liq')" class="accent-red-500">
                        <span>‚ö† Liq Data Unavailable</span>
                    </label>
                    <label class="flex items-center gap-2 text-[9px] text-red-400 cursor-pointer p-1 rounded hover:bg-red-900/20 mt-1">
                        <input type="checkbox" id="staging-vol-unavailable" onchange="onStagingUnavailableChange('vol')" class="accent-red-500">
                        <span>‚ö† Vol Data Unavailable</span>
                    </label>
                </div>
            </div>
            
            <!-- Liquidity Paste -->
            <div class="col-span-4 bg-[#161616] p-3 rounded border border-gray-800 flex flex-col">
                <div class="flex justify-between items-center mb-2">
                    <h3 class="text-cyan-400 font-bold text-[10px]">2. Paste Liquidity (180d)</h3>
                    <span id="staging-liq-paste-status" class="text-[8px] text-gray-600">Empty</span>
                </div>
                <textarea id="stagingLiqPaste" class="input-dark flex-1 font-mono text-[8px] min-h-[80px]" placeholder='Paste Astroport 180d liquidity JSON...' oninput="validateStagingLiqPaste()"></textarea>
                <div id="staging-liq-preview" class="text-[8px] text-gray-500 mt-1 min-h-[20px]">-</div>
            </div>
            
            <!-- Volume Paste -->
            <div class="col-span-4 bg-[#161616] p-3 rounded border border-gray-800 flex flex-col">
                <div class="flex justify-between items-center mb-2">
                    <h3 class="text-purple-400 font-bold text-[10px]">3. Paste Volume (180d)</h3>
                    <span id="staging-vol-paste-status" class="text-[8px] text-gray-600">Empty</span>
                </div>
                <textarea id="stagingVolPaste" class="input-dark flex-1 font-mono text-[8px] min-h-[80px]" placeholder='Paste Astroport 180d volume JSON...' oninput="validateStagingVolPaste()"></textarea>
                <div id="staging-vol-preview" class="text-[8px] text-gray-500 mt-1 min-h-[20px]">-</div>
            </div>
            
            <!-- Capture Button -->
            <div class="col-span-1 flex flex-col justify-center">
                <button onclick="captureStagingData()" id="staging-capture-btn" class="btn-action h-full bg-green-900/50 text-green-300 border border-green-700 text-[10px] flex flex-col items-center justify-center gap-1 hover:bg-green-800/50 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                    <span class="text-lg">‚úì</span>
                    <span>Capture</span>
                </button>
            </div>
        </div>
        
        <!-- Verification Panel (shows after capture) -->
        <div id="staging-verification-panel" class="hidden mb-4">
            <div class="bg-[#161616] rounded border border-cyan-800 p-4">
                <div class="flex items-center justify-between mb-3">
                    <h3 class="text-cyan-400 font-bold text-sm">üìä Verification: <span id="verify-lp-name" class="text-white">-</span></h3>
                    <div class="flex gap-2">
                        <button onclick="rejectStagingCapture()" class="btn-action bg-red-900/40 text-red-300 border border-red-700 text-[9px] px-3">‚úï Re-capture</button>
                        <button onclick="confirmStagingCapture()" class="btn-action bg-green-900/40 text-green-300 border border-green-700 text-[9px] px-3">‚úì Confirm & Save</button>
                    </div>
                </div>
                
                <div class="grid grid-cols-2 gap-4">
                    <!-- Liquidity Verification -->
                    <div class="bg-[#0D0D0D] rounded p-3 border border-gray-800">
                        <h4 class="text-cyan-400 font-bold text-[10px] mb-2">Liquidity Summary</h4>
                        <div class="grid grid-cols-2 gap-2 text-[9px] mb-2">
                            <div><span class="text-gray-500">Date Range:</span> <span id="verify-liq-dates" class="text-white">-</span></div>
                            <div><span class="text-gray-500">Data Points:</span> <span id="verify-liq-points" class="text-white">-</span></div>
                            <div><span class="text-gray-500">Epochs:</span> <span id="verify-liq-epochs" class="text-white">-</span></div>
                            <div><span class="text-gray-500">Avg Coverage:</span> <span id="verify-liq-coverage" class="text-white">-</span></div>
                        </div>
                        <div id="verify-liq-epoch-table" class="max-h-[150px] overflow-y-auto custom-scroll text-[8px]"></div>
                    </div>
                    
                    <!-- Volume Verification -->
                    <div class="bg-[#0D0D0D] rounded p-3 border border-gray-800">
                        <h4 class="text-purple-400 font-bold text-[10px] mb-2">Volume Summary <span class="text-gray-500 font-normal">(missing days = $0)</span></h4>
                        <div class="grid grid-cols-2 gap-2 text-[9px] mb-2">
                            <div><span class="text-gray-500">Date Range:</span> <span id="verify-vol-dates" class="text-white">-</span></div>
                            <div><span class="text-gray-500">Data Points:</span> <span id="verify-vol-points" class="text-white">-</span></div>
                            <div><span class="text-gray-500">Epochs:</span> <span id="verify-vol-epochs" class="text-white">-</span></div>
                            <div><span class="text-gray-500">Zero-Day %:</span> <span id="verify-vol-zeros" class="text-yellow-400">-</span></div>
                        </div>
                        <div id="verify-vol-epoch-table" class="max-h-[150px] overflow-y-auto custom-scroll text-[8px]"></div>
                    </div>
                </div>
                
                <!-- Warnings -->
                <div id="verify-warnings" class="hidden mt-3 p-2 bg-yellow-900/30 border border-yellow-700 rounded">
                    <div class="text-yellow-400 font-bold text-[9px] mb-1">‚ö† Warnings</div>
                    <div id="verify-warnings-list" class="text-yellow-200 text-[9px]"></div>
                </div>
            </div>
        </div>
        
        <!-- LP Progress Grid -->
        <div class="preview-card">
            <div class="flex justify-between items-center mb-2 border-b border-gray-800 pb-2">
                <h3 class="text-xs font-bold text-white">LP Capture Progress</h3>
                <div class="text-[9px] text-gray-500">
                    <span class="text-green-400">‚óè</span> Verified
                    <span class="text-cyan-400 ml-2">‚óè</span> Captured
                    <span class="text-yellow-400 ml-2">‚óè</span> Sparse
                    <span class="text-red-400 ml-2">‚óè</span> Issues
                    <span class="text-gray-600 ml-2">‚óè</span> Pending
                </div>
            </div>
            <div id="staging-lp-grid" class="grid grid-cols-4 gap-2 max-h-[300px] overflow-y-auto custom-scroll"></div>
        </div>
        
        <!-- Finalize Section -->
        <div id="staging-finalize-section" class="mt-4 bg-green-900/20 border border-green-700 rounded-lg p-4 hidden">
            <div class="flex items-center justify-between">
                <div>
                    <h3 class="text-green-400 font-bold text-sm">Ready to Generate Historical File</h3>
                    <p class="text-green-200/70 text-[10px]">All LPs verified. Click to generate the historical JSON file with correct epoch averages.</p>
                    <div class="text-[9px] text-green-300 mt-1">
                        <span id="finalize-lp-count">0</span> LPs ready ‚Ä¢ 
                        Volume: sum√∑7 (zeros filled) ‚Ä¢ 
                        Liquidity: sum√∑recorded days
                    </div>
                </div>
                <button onclick="generateHistoricalFile()" class="btn-action bg-green-700 text-white border border-green-600 px-6 py-3 text-sm font-bold hover:bg-green-600">
                    üöÄ Generate Historical File
                </button>
            </div>
        </div>
    </div>
    
    <div id="astro-normal-mode" class="hidden">
        <!-- NORMAL MODE: Weekly updates with 14d/30d data -->
        <div class="bg-green-900/20 border border-green-700 rounded-lg p-3 mb-4">
            <div class="flex items-center gap-3">
                <div class="text-green-400 text-lg">‚úì</div>
                <div>
                    <h3 class="text-green-400 font-bold text-xs">Normal Mode - Weekly Updates</h3>
                    <p class="text-green-200/70 text-[10px]">Select LP ‚Üí Paste Liq & Vol ‚Üí Merge Both ‚Üí Repeat for next LP</p>
                </div>
            </div>
        </div>
        
        <!-- Status Row -->
        <div class="grid grid-cols-12 gap-4 mb-4">
            <div class="col-span-4 bg-[#161616] p-3 rounded border border-gray-800">
                <div class="flex justify-between items-center mb-2">
                    <div class="text-[9px] text-gray-500 uppercase font-bold">Historical File</div>
                    <button onclick="loadHistoricalFile()" class="text-[9px] text-teal-400 hover:text-teal-300">üìÇ Load File</button>
                </div>
                <div class="space-y-1 text-[10px]">
                    <div class="flex justify-between"><span class="text-gray-500">Epochs:</span><span id="hist-epochs" class="text-white font-mono">-</span></div>
                    <div class="flex justify-between"><span class="text-gray-500">LPs:</span><span id="hist-lps" class="text-white font-mono">0</span></div>
                    <div class="flex justify-between"><span class="text-gray-500">Last Updated:</span><span id="hist-updated" class="text-gray-400 font-mono">-</span></div>
                </div>
                <input type="file" id="hist-file-input" class="hidden" accept=".json" onchange="handleHistoricalFileLoad(event)">
            </div>
            <div class="col-span-4 bg-[#161616] p-3 rounded border border-gray-800">
                <div class="text-[9px] text-gray-500 uppercase font-bold mb-2">Session Progress</div>
                <div class="space-y-1 text-[10px]">
                    <div class="flex justify-between"><span class="text-gray-500">LPs Updated:</span><span id="session-lps-updated" class="text-green-400 font-mono">0</span></div>
                    <div class="flex justify-between"><span class="text-gray-500">Epochs Added:</span><span id="session-epochs-added" class="text-cyan-400 font-mono">-</span></div>
                    <div class="flex justify-between"><span class="text-gray-500">Pending Save:</span><span id="session-pending" class="text-yellow-400 font-mono">No</span></div>
                </div>
            </div>
            <div class="col-span-4 bg-[#161616] p-3 rounded border border-gray-800">
                <div class="text-[9px] text-gray-500 uppercase font-bold mb-2">Export</div>
                <div class="space-y-1">
                    <button onclick="exportUpdatedHistorical()" class="btn-action w-full bg-green-900/30 text-green-300 border border-green-900/50 text-[9px]">üíæ Download Updated Historical</button>
                </div>
            </div>
        </div>
        
        <!-- LP Selection & Data Input (Normal) -->
        <div class="grid grid-cols-12 gap-4 mb-4">
            <!-- LP Dropdown + Status -->
            <div class="col-span-3 bg-[#161616] p-3 rounded border border-gray-800">
                <div class="text-[9px] text-gray-500 uppercase font-bold mb-2">1. Select LP</div>
                <select id="astro-lp-select-normal" class="input-dark w-full text-[11px] mb-2">
                    <option value="">-- Select LP --</option>
                </select>
                <div class="text-[9px] space-y-1 mt-2 border-t border-gray-800 pt-2">
                    <div class="text-gray-500 font-bold mb-1">Current Status:</div>
                    <div class="flex justify-between"><span class="text-gray-500">Liq Epochs:</span><span id="normal-lp-liq-epochs" class="text-cyan-400 font-mono text-[8px]">-</span></div>
                    <div class="flex justify-between"><span class="text-gray-500">Vol Epochs:</span><span id="normal-lp-vol-epochs" class="text-purple-400 font-mono text-[8px]">-</span></div>
                    <div class="flex justify-between"><span class="text-gray-500">Partial Data:</span><span id="normal-lp-partial" class="text-yellow-400 font-mono text-[8px]">-</span></div>
                    <div class="flex justify-between"><span class="text-gray-500">Unavailable:</span><span id="normal-lp-unavailable" class="text-red-400 font-mono text-[8px]">-</span></div>
                </div>
            </div>
            
            <!-- Liquidity Paste -->
            <div class="col-span-3 bg-[#161616] p-3 rounded border border-gray-800 flex flex-col gap-2">
                <div class="flex justify-between items-center">
                    <h3 class="text-cyan-400 font-bold text-[10px]">2. Paste Liquidity</h3>
                    <span id="normal-liq-status" class="text-[8px] text-gray-600">Empty</span>
                </div>
                <textarea id="normalLiqPaste" class="input-dark h-16 font-mono text-[8px]" placeholder='Paste Astroport liquidity JSON...' onchange="validateNormalLiqPaste()"></textarea>
                <div id="normal-liq-preview" class="text-[8px] text-gray-500">-</div>
                <label class="flex items-center gap-2 text-[9px] text-red-400 cursor-pointer mt-1 p-1 rounded hover:bg-red-900/20">
                    <input type="checkbox" id="normal-liq-unavailable" onchange="onLiqUnavailableChange()" class="accent-red-500">
                    <span>‚ö† Data Unavailable</span>
                </label>
            </div>
            
            <!-- Volume Paste -->
            <div class="col-span-3 bg-[#161616] p-3 rounded border border-gray-800 flex flex-col gap-2">
                <div class="flex justify-between items-center">
                    <h3 class="text-purple-400 font-bold text-[10px]">3. Paste Volume</h3>
                    <span id="normal-vol-status" class="text-[8px] text-gray-600">Empty</span>
                </div>
                <textarea id="normalVolPaste" class="input-dark h-16 font-mono text-[8px]" placeholder='Paste Astroport volume JSON...' onchange="validateNormalVolPaste()"></textarea>
                <div id="normal-vol-preview" class="text-[8px] text-gray-500">-</div>
                <label class="flex items-center gap-2 text-[9px] text-red-400 cursor-pointer mt-1 p-1 rounded hover:bg-red-900/20">
                    <input type="checkbox" id="normal-vol-unavailable" onchange="onVolUnavailableChange()" class="accent-red-500">
                    <span>‚ö† Data Unavailable</span>
                </label>
            </div>
            
            <!-- Merge Button -->
            <div class="col-span-3 bg-[#161616] p-3 rounded border border-gray-800 flex flex-col justify-center items-center gap-2">
                <div class="text-[9px] text-gray-500 uppercase font-bold">4. Merge</div>
                <button onclick="mergeNormalLpData()" id="normal-merge-btn" class="btn-action w-full h-16 bg-green-900/40 text-green-200 border border-green-700 text-sm font-bold disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                    üîÄ Merge LP Data
                </button>
                <div id="normal-merge-status" class="text-[8px] text-gray-500 text-center">Select LP and paste both Liq & Vol</div>
            </div>
        </div>
        
        <!-- LP Status Grid -->
        <div class="preview-card">
            <div class="flex justify-between items-center mb-2 border-b border-gray-800 pb-2">
                <h3 class="text-xs font-bold text-white">LP Update Status</h3>
                <div class="text-[9px] text-gray-500">
                    <span class="text-green-400">‚óè</span> Updated
                    <span class="text-yellow-400 ml-2">‚óè</span> Partial
                    <span class="text-red-400 ml-2">‚óè</span> Unavailable
                    <span class="text-gray-600 ml-2">‚óè</span> Pending
                </div>
            </div>
            <div id="astro-normal-lp-grid" class="grid grid-cols-4 gap-2 max-h-[300px] overflow-y-auto custom-scroll"></div>
        </div>
    </div>
</div>

<!-- WS 4: WHITEWHALE -->
<div id="ws-ww" class="workspace">
    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
        <div class="bg-[#161616] p-3 rounded border border-gray-800 flex flex-col gap-2">
            <div class="flex justify-between items-center">
                <h3 class="text-green-400 font-bold text-xs">Skeleton Swap Data</h3>
                <button onclick="clearPaste('wwPaste')" class="text-[9px] text-red-400 hover:text-red-300">Clear</button>
            </div>
            <textarea id="wwPaste" class="input-dark h-64 font-mono text-[10px]" placeholder="Paste Skeleton Swap dashboard text..."></textarea>
            <button onclick="parseWW()" class="btn-action bg-green-900/40 text-green-200 border border-green-900">Parse Skeleton Swap</button>
        </div>
        <div class="preview-card flex flex-col">
            <div class="flex justify-between items-center mb-2 border-b border-gray-800 pb-2">
                <h3 class="text-xs font-bold text-white">Parsed Skeleton Swap</h3>
                <div class="text-[10px] text-gray-500">Items: <span id="ww-count" class="text-white font-mono">0</span></div>
            </div>
            <div class="grid grid-cols-12 gap-1 text-[9px] text-gray-500 uppercase font-bold px-2 py-1 bg-gray-900 rounded-t">
                <div class="col-span-5">Pool</div>
                <div class="col-span-2 text-right">Volume</div>
                <div class="col-span-2 text-right">Fees</div>
                <div class="col-span-3 text-right">APR</div>
            </div>
            <div id="ww-list" class="max-h-[500px] overflow-y-auto text-xs bg-[#0D0D0D] p-2 border border-gray-800 rounded-b custom-scroll space-y-0"></div>
        </div>
    </div>
</div>
<script>
const $ = id => document.getElementById(id);
const setTxt = (id, v) => { const e = $(id); if(e) e.innerText = v; };
const setHtml = (id, v) => { const e = $(id); if(e) e.innerHTML = v; };
const clean = s => { if(!s)return 0; let m=1; if(/[\d\.]\s*[Kk]($|[\s\W])/.test(s))m=1e3; if(/[\d\.]\s*[Mm]($|[\s\W])/.test(s))m=1e6; return parseFloat(s.replace(/[^0-9\.]/g,''))*m||0; };
const fmt$ = n => '$'+n.toLocaleString(undefined,{maximumFractionDigits:0});

let store = {
    meta: { ep: 0, ph: 'end' },
    mode: 'staging', // 'staging' or 'normal'
    lpRegistry: {},  // { "LUNA-USDC": { bucket, sources: { Astroport: { vote_pct } }, active } }
    votion: { lockups: [], ratioArb: null, ratioAmp: null },
    // Comprehensive LST ratios and APYs - all start empty
    lstRatios: {
        ampLUNA: { ratio: null, base: 'LUNA', apy: null, updated: null },
        arbLUNA: { ratio: null, base: 'LUNA', apy: null, updated: null },
        bLUNA: { ratio: null, base: 'LUNA', apy: null, updated: null }, // bLUNA doesn't show APY on BBL
        ampCAPA: { ratio: null, base: 'CAPA', apy: null, updated: null },
        ampROAR: { ratio: null, base: 'ROAR', apy: null, updated: null },
        xASTRO: { ratio: null, base: 'ASTRO', apy: null, updated: null },
        chainStakingApr: null,
        chainStakingAprDate: null,
        allUpdated: false
    },
    pdBribesHistory: [],
    pdNewProp: null,
    staging: {
        // 4-day capture system
        day1: null,  // { captureDate, lps: { "LUNA-USDC|Astroport": { liquidity: [], volume: [] } } }
        day2: null,
        day3: null,
        day4: null,
        currentDay: 'day1',
        pendingCapture: null  // Temporary storage before verification
    },
    historical: { lps: {}, meta: {} },
    current: { lps: {}, meta: {} },
    ww: [],
    liveEpoch: null, // { epoch, end_time, phase, daysRemaining }
    prevExt: null,    // Loaded previous ext file for reference
    testMode: false,  // If true, export saves with _test suffix
    // Token prices from CoinGecko and calculated
    tokenPrices: {},  // { LUNA: { price, source: 'coingecko'|'calculated'|'manual' }, ... }
    skippedTokens: {}, // { TOKEN: true } for tokens user wants to skip
    // Verification flags for workflow steps
    lpRegistryVerified: false,
    ratiosVerified: false,
    pricesVerified: false,
    tokenPricesVerified: false,
    votionVerified: false,
    pdBribesVerified: false,
    dashboardVerified: false,
    nftVerified: false,
    newsVerified: false,
    daoVerified: false
};

// GitHub URLs
const GITHUB_BASE = 'https://raw.githubusercontent.com/defipatriot/tla-ext_json_storage/main/';
const STAGING_URLS = {
    day1: GITHUB_BASE + 'tla_ext_staging_day1.json',
    day2: GITHUB_BASE + 'tla_ext_staging_day2.json',
    day3: GITHUB_BASE + 'tla_ext_staging_day3.json',
    day4: GITHUB_BASE + 'tla_ext_staging_day4.json'
};
const HISTORICAL_URL = GITHUB_BASE + 'tla_ext_historical_2026.json';
const CURRENT_URL = GITHUB_BASE + 'tla_ext_current.json';
const PD_BRIBES_GITHUB_URL = GITHUB_BASE + 'tla_pd_bribes.json';
const STAKING_APR_CSV_URL = 'https://raw.githubusercontent.com/defipatriot/tla-ext_json_storage/main/Staking%20APR.csv';

// LST Hub Contracts for auto-fetching ratios - WORKING CONFIG
const lstContracts = {
    ampLUNA: {
        hub: 'terra10788fkzah89xrdm27zkj5yvhj9x3494lxawzm5qq3vvxcqz2yzaqyd3enk',
        query: 'exchange_rates',
        parse: (data) => parseFloat(data?.data?.exchange_rates?.[0]?.[1] || 0)
    },
    arbLUNA: {
        hub: 'terra1r9gls56glvuc4jedsvc3uwh6vj95mqm9efc7hnweqxa2nlme5cyqxygy5m',
        query: 'state',
        parse: (data) => parseFloat(data?.data?.exchange_rate || 0)
    },
    ampROAR: {
        hub: 'terra1vklefn7n6cchn0u962w3gaszr4vf52wjvd4y95t2sydwpmpdtszsqvk9wy',
        query: 'state',
        parse: (data) => parseFloat(data?.data?.exchange_rate || 0)
    },
    ampCAPA: {
        hub: 'terra186rpfczl7l2kugdsqqedegl4es4hp624phfc7ddy8my02a4e8lgq5rlx7y',
        query: 'state',
        parse: (data) => parseFloat(data?.data?.exchange_rate || 0)
    },
    bLUNA: {
        hub: 'terra1l2nd99yze5fszmhl5svyh5fky9wm4nz4etlgnztfu4e8809gd52q04n3ea',
        query: 'state',
        parse: (data) => parseFloat(data?.data?.exchange_rate || 0)
    }
};

// Epoch calculation constants
const EPOCH_ANCHOR_DATE = new Date(Date.UTC(2025, 10, 17, 0, 0, 0)); // Nov 17, 2025 = Epoch 160
const EPOCH_ANCHOR_NUM = 160;
const SECONDS_PER_WEEK = 604800;

// CoinGecko ID mapping for tokens
const COINGECKO_IDS = {
    'LUNA': 'terra-luna-2',
    'USDC': 'usd-coin',
    'USDT': 'tether',
    'WBTC': 'wrapped-bitcoin',
    'ATOM': 'cosmos',
    'ETH': 'ethereum',
    'WETH': 'ethereum',
    'PAXG': 'pax-gold',
    'EURE': 'euroe-stablecoin',
    'INJ': 'injective-protocol',
    'ASTRO': 'astroport-fi',
    'SOLID': 'solid-2',
    'FUEL': null, // Not on CoinGecko
    'SWTH': 'switcheo',
    'ROAR': 'lion-dao',
    'CAPA': 'capapult',
    'STLUNA': 'stride-staked-luna',
    'WSTETH': 'wrapped-steth',
    'OSMO': 'osmosis',
    'WBNB': 'wbnb',
    'BNB': 'binancecoin',
    'STATOM': 'stride-staked-atom'
};

// Canonical display names - maps uppercase to proper casing
// Used for display, storage, and matching
const CANONICAL_NAMES = {
    'AMPLUNA': 'ampLUNA',
    'ARBLUNA': 'arbLUNA',
    'BLUNA': 'bLUNA',
    'BONELUNA': 'boneLUNA',
    'AMPCAPA': 'ampCAPA',
    'AMPROAR': 'ampROAR',
    'XASTRO': 'xASTRO',
    'STLUNA': 'stLUNA',
    'STATOM': 'stATOM',
    'WSTETH': 'wstETH',
    'EURE': 'EURe',
    'WBTC': 'wBTC',
    'WETH': 'wETH',
    'WBNB': 'wBNB'
};

// Get canonical name for a token (proper casing)
function getCanonicalName(token) {
    if (!token) return '';
    const upper = token.toUpperCase();
    
    // Check for bridged tokens first (wBTC.axl -> wBTC.axl with proper base casing)
    const bridgeMatch = token.match(/^(.+)\.(axl|atom|osmo|wh|noble)$/i);
    if (bridgeMatch) {
        const base = bridgeMatch[1].toUpperCase();
        const suffix = bridgeMatch[2].toLowerCase();
        const canonicalBase = CANONICAL_NAMES[base] || bridgeMatch[1];
        return `${canonicalBase}.${suffix}`;
    }
    
    // Check canonical names
    if (CANONICAL_NAMES[upper]) return CANONICAL_NAMES[upper];
    
    // Return original if no mapping (LUNA, USDC, etc stay as-is)
    return token;
}

// Tokens that need calculation from ratio: price = base_price * ratio
// Keys are uppercase for lookup, display uses canonical names
const CALCULATED_TOKENS = {
    'AMPLUNA': { base: 'LUNA', ratioKey: 'ampLUNA', display: 'ampLUNA' },
    'ARBLUNA': { base: 'LUNA', ratioKey: 'arbLUNA', display: 'arbLUNA' },
    'BLUNA': { base: 'LUNA', ratioKey: 'bLUNA', display: 'bLUNA' },
    'BONELUNA': { base: 'LUNA', ratioKey: 'bLUNA', display: 'boneLUNA' },
    'AMPCAPA': { base: 'CAPA', ratioKey: 'ampCAPA', display: 'ampCAPA' },
    'AMPROAR': { base: 'ROAR', ratioKey: 'ampROAR', display: 'ampROAR' },
    'XASTRO': { base: 'ASTRO', ratioKey: 'xASTRO', display: 'xASTRO' }
};

// Quick lookup URLs for tokens not on CoinGecko (opens in preview modal)
const TOKEN_LOOKUP_URLS = {
    'FUEL': 'https://app.astroport.fi/swap?chain=terra&to=ibc%2F4B44179AC2F0BEE50C16A673B3B886398988692885B2848A1C8AEF27148B3961&from=uluna'
};

async function fetchAllTokenPrices() {
    // Get unique tokens from LP registry - normalize to canonical names
    const uniqueTokens = new Set();
    const bridgedToBase = {};  // Map bridged tokens to their base for price lookup
    
    Object.values(store.lpRegistry).forEach(lpData => {
        // Use the lp property which has clean pair name like "LUNA-USDC" or single "ampCAPA"
        const lpName = lpData.lp || '';
        
        // For single-sided pools, lpName IS the token (no dash)
        // For LP pairs, split by dash
        const parts = lpName.includes('-') ? lpName.split('-') : [lpName];
        
        parts.forEach(t => {
            if (!t) return;
            
            // Normalize to canonical name (ampLUNA not AMPLUNA, wBTC.axl not WBTC.axl)
            const canonical = getCanonicalName(t);
            uniqueTokens.add(canonical);
            
            // Check if it's a bridged token - map to base for CoinGecko lookup
            const bridgeMatch = canonical.match(/^(.+)\.(axl|atom|osmo|wh|noble)$/i);
            if (bridgeMatch) {
                const base = bridgeMatch[1].toUpperCase();
                bridgedToBase[canonical] = base;
            }
        });
    });
    
    // Add core tokens we always need
    ['LUNA', 'ASTRO', 'ROAR', 'CAPA'].forEach(t => uniqueTokens.add(t));
    
    const tokenList = Array.from(uniqueTokens).sort();
    setTxt('price-found-count', tokenList.length);
    
    // Build CoinGecko query - need base tokens for bridged ones
    const geckoIds = new Set();  // Use Set to avoid duplicates
    const geckoToCanonical = {};  // Map gecko ID back to canonical name
    const baseTokensNeeded = new Set();
    
    // First pass: identify what tokens we need from CoinGecko
    tokenList.forEach(token => {
        const upperToken = token.toUpperCase();
        
        // Check if this token has a direct CoinGecko ID
        const geckoId = COINGECKO_IDS[upperToken];
        if (geckoId) {
            geckoIds.add(geckoId);
            geckoToCanonical[geckoId] = token;  // Map back to canonical name
        }
        
        // Check if it's a calculated token (ampLUNA, etc.) - need base price
        if (CALCULATED_TOKENS[upperToken]) {
            const baseToken = CALCULATED_TOKENS[upperToken].base;
            if (COINGECKO_IDS[baseToken]) {
                baseTokensNeeded.add(baseToken);
            }
        }
        
        // If it's a bridged token, we need its base token price
        if (bridgedToBase[token]) {
            baseTokensNeeded.add(bridgedToBase[token]);
        }
    });
    
    // Add base tokens for calculated and bridged variants
    baseTokensNeeded.forEach(base => {
        const geckoId = COINGECKO_IDS[base];
        if (geckoId && !geckoToCanonical[geckoId]) {
            geckoIds.add(geckoId);
            geckoToCanonical[geckoId] = base;  // Keep as base for price lookup
        }
    });
    
    // Fetch from CoinGecko
    let cgCount = 0;
    const basePrices = {};  // Store base token prices for calculated/bridged lookups
    
    if (geckoIds.size > 0) {
        try {
            const url = `https://api.coingecko.com/api/v3/simple/price?ids=${Array.from(geckoIds).join(',')}&vs_currencies=usd`;
            const resp = await fetch(url);
            const data = await resp.json();
            
            Object.entries(data).forEach(([geckoId, priceData]) => {
                const token = geckoToCanonical[geckoId];
                if (token && priceData.usd) {
                    // Store base price for calculated/bridged lookups
                    basePrices[token.toUpperCase()] = priceData.usd;
                    
                    // Only add to store.tokenPrices if it's actually in our token list
                    if (uniqueTokens.has(token)) {
                        store.tokenPrices[token] = {
                            price: priceData.usd,
                            source: 'coingecko'
                        };
                        cgCount++;
                    }
                }
            });
        } catch (e) {
            console.error('CoinGecko fetch error:', e);
        }
    }
    setTxt('price-cg-count', cgCount);
    
    // Apply prices to bridged tokens (wBTC.axl gets WBTC price, etc.)
    let bridgedCount = 0;
    Object.entries(bridgedToBase).forEach(([bridgedToken, base]) => {
        if (basePrices[base] && !store.tokenPrices[bridgedToken]) {
            store.tokenPrices[bridgedToken] = {
                price: basePrices[base],
                source: 'bridged',
                baseToken: CANONICAL_NAMES[base] || base
            };
            bridgedCount++;
        }
    });
    
    // Calculate derived LST prices (ampLUNA, arbLUNA, etc.)
    // These should ALWAYS be calculated if we have the ratio - they're essential tokens
    let calcCount = 0;
    
    // Special handling: bLUNA and boneLUNA are the same asset
    // If either is in the token list, add both with same price
    const hasBLuna = uniqueTokens.has('bLUNA');
    const hasBoneLuna = uniqueTokens.has('boneLUNA');
    
    Object.entries(CALCULATED_TOKENS).forEach(([upperToken, config]) => {
        const displayName = config.display;
        const basePrice = basePrices[config.base] || store.tokenPrices[config.base]?.price;
        const ratio = store.lstRatios[config.ratioKey]?.ratio;
        
        // Skip if we don't have base price or ratio
        if (!basePrice || !ratio) return;
        
        // Special case: bLUNA/boneLUNA - add both if either exists in LP registry
        if (displayName === 'bLUNA' || displayName === 'boneLUNA') {
            if (hasBLuna || hasBoneLuna) {
                store.tokenPrices[displayName] = {
                    price: basePrice * ratio,
                    source: 'calculated',
                    formula: `${config.base} √ó ${ratio.toFixed(4)}`
                };
                if (!tokenList.includes(displayName)) tokenList.push(displayName);
                calcCount++;
            }
        }
        // For all other LSTs (ampLUNA, arbLUNA, ampCAPA, ampROAR, xASTRO):
        // ALWAYS calculate if we have ratio - these are core tokens even for single-sided pools
        else {
            store.tokenPrices[displayName] = {
                price: basePrice * ratio,
                source: 'calculated',
                formula: `${config.base} √ó ${ratio.toFixed(4)}`
            };
            if (!tokenList.includes(displayName)) tokenList.push(displayName);
            calcCount++;
        }
    });
    setTxt('price-calc-count', calcCount);
    
    // Update LUNA display
    if (store.tokenPrices.LUNA) {
        setTxt('price-luna', '$' + store.tokenPrices.LUNA.price.toFixed(4));
    }
    
    // Render the two lists - include calculated tokens
    renderTokenPriceLists(tokenList.sort());
    updatePricesStatus();
    updateWorkflowStatus();
}

function renderTokenPriceLists(tokens) {
    const autoContainer = $('token-price-auto');
    const manualContainer = $('token-price-manual');
    if (!autoContainer || !manualContainer) return;
    
    let autoHtml = '';
    let manualHtml = '';
    let manualCount = 0;
    
    // Sort tokens alphabetically
    const sorted = [...tokens].sort();
    
    sorted.forEach(token => {
        const priceData = store.tokenPrices[token];
        const isSkipped = store.skippedTokens?.[token];
        
        if (priceData) {
            // Auto-fetched (CoinGecko, Calculated, Manual, Bridged, or Custom) - all show in left list
            const priceStr = formatPrice(priceData.price);
            const isCalc = priceData.source === 'calculated';
            const isBridged = priceData.source === 'bridged';
            const isCustom = priceData.source === 'custom' || priceData.source === 'manual';
            // All are "auto" now - show green
            const dotColor = 'text-green-400';
            const bgColor = 'bg-green-900/10 border-green-900/30';
            let sourceLabel = '';
            if (isCalc) {
                sourceLabel = `<span class="text-yellow-400 text-[8px] ml-2">(${priceData.formula})</span>`;
            } else if (isBridged) {
                sourceLabel = `<span class="text-purple-400 text-[8px] ml-2">(=${priceData.baseToken})</span>`;
            } else if (isCustom) {
                sourceLabel = `<span class="text-cyan-400 text-[8px] ml-2">(manual)</span>`;
            }
            
            autoHtml += `
                <div class="flex items-center justify-between p-2 rounded border ${bgColor}">
                    <div class="flex items-center gap-2">
                        <span class="${dotColor} text-[10px]">‚óè</span>
                        <span class="text-white font-bold text-[11px]">${token}</span>
                        ${sourceLabel}
                    </div>
                    <span class="text-white font-mono text-[11px]">${priceStr}</span>
                </div>
            `;
        } else {
            // Manual entry needed
            manualCount++;
            const skipChecked = isSkipped ? 'checked' : '';
            const rowClass = isSkipped ? 'opacity-50' : '';
            const hasLookup = TOKEN_LOOKUP_URLS[token];
            const lookupBtn = hasLookup ? `
                <button onclick="openTokenLookup('${token}')" class="text-[9px] text-cyan-400 hover:text-cyan-300 bg-cyan-900/30 px-1.5 py-0.5 rounded border border-cyan-900/50" title="Look up price">
                    <i class="fas fa-search"></i>
                </button>
            ` : '';
            
            manualHtml += `
                <div class="flex items-center justify-between p-2 rounded border bg-red-900/10 border-red-900/30 ${rowClass}" id="price-row-${token}">
                    <div class="flex items-center gap-2">
                        <input type="checkbox" ${skipChecked} onchange="toggleSkipToken('${token}')" class="w-3 h-3" title="Skip this token">
                        <span class="text-red-400 text-[10px]">‚óè</span>
                        <span class="text-white font-bold text-[11px]">${token}</span>
                        ${lookupBtn}
                    </div>
                    <div class="flex items-center gap-2">
                        <span class="text-gray-500 text-[10px]">$</span>
                        <input type="number" step="any" class="input-dark w-24 text-[10px] text-right py-1" 
                               placeholder="0.00" id="manual-price-${token}"
                               onchange="setManualPrice('${token}', this.value)"
                               ${isSkipped ? 'disabled' : ''}>
                    </div>
                </div>
            `;
        }
    });
    
    autoContainer.innerHTML = autoHtml || '<div class="text-gray-500 text-[10px] text-center p-4">No prices fetched yet</div>';
    manualContainer.innerHTML = manualHtml || '<div class="text-green-400 text-[10px] text-center p-4">‚úì All tokens have prices!</div>';
    
    setTxt('price-manual-count', manualCount);
}

// Smart price formatting - show all zeros, no scientific notation
function formatPrice(price) {
    if (price === 0) return '$0.00';
    if (price >= 1000) return '$' + price.toLocaleString(undefined, { maximumFractionDigits: 2 });
    if (price >= 1) return '$' + price.toFixed(4);
    if (price >= 0.01) return '$' + price.toFixed(6);
    if (price >= 0.0001) return '$' + price.toFixed(8);
    if (price >= 0.000001) return '$' + price.toFixed(10);
    // For extremely small, show up to 12 decimals
    return '$' + price.toFixed(12);
}

function toggleSkipToken(token) {
    if (!store.skippedTokens) store.skippedTokens = {};
    store.skippedTokens[token] = !store.skippedTokens[token];
    
    const row = $(`price-row-${token}`);
    const input = $(`manual-price-${token}`);
    
    if (store.skippedTokens[token]) {
        row?.classList.add('opacity-50');
        if (input) input.disabled = true;
    } else {
        row?.classList.remove('opacity-50');
        if (input) input.disabled = false;
    }
    
    updatePricesStatus();
    updateWorkflowStatus();
}

function setManualPrice(token, value) {
    const price = parseFloat(value);
    if (price > 0) {
        store.tokenPrices[token] = {
            price: price,
            source: 'manual'
        };
        
        // Move from manual to auto list by re-rendering
        const tokens = Object.keys(store.tokenPrices).concat(
            Object.keys(store.skippedTokens || {})
        );
        renderTokenPriceLists([...new Set(tokens)]);
    }
    updatePricesStatus();
    updateWorkflowStatus();
}

function addCustomToken() {
    const nameInput = $('custom-token-name');
    const priceInput = $('custom-token-price');
    
    const name = nameInput?.value?.trim().toUpperCase();
    const price = parseFloat(priceInput?.value);
    
    if (!name) {
        alert('Enter a token name');
        return;
    }
    
    if (!price || price <= 0) {
        alert('Enter a valid price');
        return;
    }
    
    // Add to store
    store.tokenPrices[name] = {
        price: price,
        source: 'custom'
    };
    
    // Clear inputs
    nameInput.value = '';
    priceInput.value = '';
    
    // Re-render lists
    const tokens = Object.keys(store.tokenPrices).concat(
        Object.keys(store.skippedTokens || {})
    );
    renderTokenPriceLists([...new Set(tokens)]);
    updatePricesStatus();
    updateWorkflowStatus();
}

function updatePricesStatus() {
    const totalTokens = Object.keys(store.tokenPrices).length;
    const skippedCount = Object.values(store.skippedTokens || {}).filter(Boolean).length;
    
    const statusEl = $('prices-all-status');
    if (statusEl) {
        if (store.tokenPricesVerified || totalTokens >= 10) {
            statusEl.innerHTML = `<i class="fas fa-check-circle mr-1"></i> ${totalTokens} Tokens`;
            statusEl.className = 'px-3 py-1 rounded text-[10px] font-bold bg-green-900/30 text-green-400 border border-green-700 cursor-pointer hover:opacity-80';
        } else if (totalTokens > 0) {
            statusEl.innerHTML = `<i class="fas fa-exclamation-circle mr-1"></i> ${totalTokens} Tokens (click to override)`;
            statusEl.className = 'px-3 py-1 rounded text-[10px] font-bold bg-yellow-900/30 text-yellow-400 border border-yellow-700 cursor-pointer hover:opacity-80';
        } else {
            statusEl.innerHTML = '<i class="fas fa-exclamation-circle mr-1"></i> 0 Tokens';
            statusEl.className = 'px-3 py-1 rounded text-[10px] font-bold bg-red-900/30 text-red-400 border border-red-700 cursor-pointer hover:opacity-80';
        }
    }
}

let pasteStatus = { votion: false, pd: false, astro: false, ww: false };

function updatePasteStatus(id, done) {
    const el = $(id);
    if (el) {
        if (done) el.classList.add('status-done');
        else el.classList.remove('status-done');
    }
}

function clearPaste(id) {
    const el = $(id);
    if (el) el.value = '';
}

function parseRatioPaste() {
    let txt = $('ratioPaste').value;
    // Parse "1 ampLUNA = 1.8707 LUNA" or "1 arbLUNA = 2.4362 LUNA"
    let match = txt.match(/1\s*(amp|arb)LUNA\s*=\s*([\d\.]+)\s*LUNA/i);
    if (match) {
        let type = match[1].toLowerCase();
        let ratio = parseFloat(match[2]);
        if (type === 'amp') {
            $('ratioAmp').value = ratio;
            store.votion.ratioAmp = ratio;
            store.votion.ratioAmpUpdated = new Date().toISOString();
        } else if (type === 'arb') {
            $('ratioArb').value = ratio;
            store.votion.ratioArb = ratio;
            store.votion.ratioArbUpdated = new Date().toISOString();
        }
        $('ratioPaste').value = ''; // Clear after parse
        updateRatios();
        recalcVotion();
    }
}

function updateRatios() {
    // Check if ratios and APYs are set in store
    const arbRatioSet = store.votion.ratioArb !== null && store.votion.ratioArb > 0;
    const ampRatioSet = store.votion.ratioAmp !== null && store.votion.ratioAmp > 0;
    const arbApySet = store.lstRatios.arbLUNA?.apy !== null && store.lstRatios.arbLUNA?.apy > 0;
    const ampApySet = store.lstRatios.ampLUNA?.apy !== null && store.lstRatios.ampLUNA?.apy > 0;
    
    // Update display spans for ratios
    const ratioArbEl = $('ratioArb');
    const ratioAmpEl = $('ratioAmp');
    if (ratioArbEl) ratioArbEl.textContent = arbRatioSet ? store.votion.ratioArb.toFixed(4) : '--';
    if (ratioAmpEl) ratioAmpEl.textContent = ampRatioSet ? store.votion.ratioAmp.toFixed(4) : '--';
    
    // Update display spans for APYs
    const apyArbEl = $('apyArb');
    const apyAmpEl = $('apyAmp');
    if (apyArbEl) apyArbEl.textContent = arbApySet ? store.lstRatios.arbLUNA.apy.toFixed(2) + '%' : '--';
    if (apyAmpEl) apyAmpEl.textContent = ampApySet ? store.lstRatios.ampLUNA.apy.toFixed(2) + '%' : '--';
    
    // Update individual status indicators for ratios
    const arbRatioStatus = $('votion-arb-ratio-status');
    const ampRatioStatus = $('votion-amp-ratio-status');
    if (arbRatioStatus) {
        arbRatioStatus.textContent = arbRatioSet ? '‚úì' : '‚úó';
        arbRatioStatus.className = arbRatioSet ? 'text-green-400' : 'text-red-400';
    }
    if (ampRatioStatus) {
        ampRatioStatus.textContent = ampRatioSet ? '‚úì' : '‚úó';
        ampRatioStatus.className = ampRatioSet ? 'text-green-400' : 'text-red-400';
    }
    
    // Update individual status indicators for APYs
    const arbApyStatus = $('votion-arb-apy-status');
    const ampApyStatus = $('votion-amp-apy-status');
    if (arbApyStatus) {
        arbApyStatus.textContent = arbApySet ? '‚úì' : '‚úó';
        arbApyStatus.className = arbApySet ? 'text-green-400' : 'text-red-400';
    }
    if (ampApyStatus) {
        ampApyStatus.textContent = ampApySet ? '‚úì' : '‚úó';
        ampApyStatus.className = ampApySet ? 'text-green-400' : 'text-red-400';
    }
    
    // Update main status card - need ALL 4 to be ready
    const allReady = arbRatioSet && ampRatioSet && arbApySet && ampApySet;
    const ratiosReady = arbRatioSet && ampRatioSet;
    const apysReady = arbApySet && ampApySet;
    
    const card = $('votion-ratios-card');
    const statusDiv = $('votion-ratios-status');
    
    if (card && statusDiv) {
        if (allReady) {
            card.className = 'col-span-4 bg-green-900/20 p-3 rounded border-2 border-green-700 flex flex-col gap-2';
            statusDiv.innerHTML = `
                <div class="text-2xl mb-1">‚úÖ</div>
                <div class="text-green-400 font-bold text-[11px]">ALL READY</div>
                <div class="text-gray-400 text-[9px]">VP & APY calculations accurate</div>
            `;
        } else if (ratiosReady && !apysReady) {
            card.className = 'col-span-4 bg-yellow-900/20 p-3 rounded border-2 border-yellow-700 flex flex-col gap-2';
            statusDiv.innerHTML = `
                <div class="text-2xl mb-1">‚ö†Ô∏è</div>
                <div class="text-yellow-400 font-bold text-[11px]">APYs MISSING</div>
                <div class="text-gray-400 text-[9px]">Ratios OK, enter APYs manually</div>
            `;
        } else if (!ratiosReady && apysReady) {
            card.className = 'col-span-4 bg-yellow-900/20 p-3 rounded border-2 border-yellow-700 flex flex-col gap-2';
            statusDiv.innerHTML = `
                <div class="text-2xl mb-1">‚ö†Ô∏è</div>
                <div class="text-yellow-400 font-bold text-[11px]">RATIOS MISSING</div>
                <div class="text-gray-400 text-[9px]">APYs OK, fetch ratios</div>
            `;
        } else {
            card.className = 'col-span-4 bg-[#161616] p-3 rounded border-2 border-red-700 flex flex-col gap-2';
            statusDiv.innerHTML = `
                <div class="text-2xl mb-1">‚ö†Ô∏è</div>
                <div class="text-red-400 font-bold text-[11px]">NOT READY</div>
                <div class="text-gray-500 text-[9px]">Complete Prices/Ratios tab first</div>
            `;
        }
    }
    
    // Also sync to LST ratios store
    if (store.votion.ratioArb) store.lstRatios.arbLUNA.ratio = store.votion.ratioArb;
    if (store.votion.ratioAmp) store.lstRatios.ampLUNA.ratio = store.votion.ratioAmp;
    
    updateWorkflowStatus();
    recalcVotion();
}

// ============ LST RATIO FUNCTIONS ============

function updateLstRatio(token, value) {
    const ratio = parseFloat(value) || 0;
    if (token === 'chainStakingApr') {
        store.lstRatios.chainStakingApr = ratio;
        store.lstRatios.chainStakingAprDate = new Date().toISOString();
    } else if (store.lstRatios[token]) {
        store.lstRatios[token].ratio = ratio;
        store.lstRatios[token].updated = new Date().toISOString();
        
        // Sync ampLUNA/arbLUNA to votion ratios for VP calculation
        if (token === 'ampLUNA') {
            store.votion.ratioAmp = ratio;
            $('ratioAmp').value = ratio;
        } else if (token === 'arbLUNA') {
            store.votion.ratioArb = ratio;
            $('ratioArb').value = ratio;
        }
    }
    updateLstCardStatus(token);
    updateLstOverallStatus();
    updateWorkflowStatus();
}

function updateLstApy(token, value) {
    const apy = parseFloat(value) || null;
    if (store.lstRatios[token]) {
        store.lstRatios[token].apy = apy;
        store.lstRatios[token].updated = new Date().toISOString();
    }
    updateLstCardStatus(token);
    updateLstOverallStatus();
    updateRatios(); // Sync to Votion tab
    updateWorkflowStatus();
}

function togglePricesOverride() {
    store.ratiosVerified = !store.ratiosVerified;
    updateLstOverallStatus();
    updateWorkflowStatus();
}

function parseLstPaste(token) {
    const pasteEl = $(`lst-paste-${token}`);
    if (!pasteEl) return;
    
    const txt = pasteEl.value;
    if (!txt.trim()) return;
    
    let ratio = null;
    let apy = null;
    
    // Parse based on token type
    if (token === 'ampLUNA' || token === 'arbLUNA') {
        // Eris format: "1 ampLUNA = 1.9015 LUNA" or "1 arbLUNA = 2.6873 LUNA"
        const ratioMatch = txt.match(/1\s*(amp|arb)LUNA\s*=\s*([\d\.]+)\s*LUNA/i);
        if (ratioMatch) ratio = parseFloat(ratioMatch[2]);
        
        // APY: "Amplified APY 29.68%" or "Arbitrage APY 146.24%"
        const apyMatch = txt.match(/(Amplified|Arbitrage)\s*APY[:\s]*([\d\.]+)\s*%/i);
        if (apyMatch) apy = parseFloat(apyMatch[2]);
    }
    else if (token === 'bLUNA') {
        // Backbone format: "1 LUNA = 0.623302 bLUNA" - need to invert
        const bbMatch = txt.match(/1\s*LUNA\s*=\s*([\d\.]+)\s*bLUNA/i);
        if (bbMatch) {
            const inverse = parseFloat(bbMatch[1]);
            if (inverse > 0) ratio = 1 / inverse;
        }
        // Also try direct format "1 bLUNA = X LUNA"
        const directMatch = txt.match(/1\s*bLUNA\s*=\s*([\d\.]+)\s*LUNA/i);
        if (directMatch) ratio = parseFloat(directMatch[1]);
        
        // APY from Backbone (if present)
        const apyMatch = txt.match(/APY[:\s]*([\d\.]+)\s*%/i);
        if (apyMatch) apy = parseFloat(apyMatch[1]);
    }
    else if (token === 'ampCAPA' || token === 'ampROAR') {
        // Eris format: "1 ampCAPA = 1.1055 CAPA" or "1 ampROAR = 1.1087 ROAR"
        const base = token === 'ampCAPA' ? 'CAPA' : 'ROAR';
        const ratioRegex = new RegExp(`1\\s*${token}\\s*=\\s*([\\d\\.]+)\\s*${base}`, 'i');
        const ratioMatch = txt.match(ratioRegex);
        if (ratioMatch) ratio = parseFloat(ratioMatch[1]);
        
        // APY
        const apyMatch = txt.match(/Amplified\s*APY[:\s]*([\d\.]+)\s*%/i);
        if (apyMatch) apy = parseFloat(apyMatch[1]);
    }
    else if (token === 'xASTRO') {
        // Astroport format variations:
        // "13.78%\nAPY\n1:1.22\nxASTRO:ASTRO"
        // "1:1.22 xASTRO:ASTRO"
        // "22.49% APY 1:1.22 xASTRO:ASTRO"
        
        // Try to find ratio - multiline: "1:1.22\nxASTRO:ASTRO" 
        const multilineMatch = txt.match(/1:([\d\.]+)\s*[\n\r]+\s*xASTRO:ASTRO/i);
        if (multilineMatch) ratio = parseFloat(multilineMatch[1]);
        
        // Try inline format: "1:1.22 xASTRO:ASTRO"
        if (!ratio) {
            const inlineMatch = txt.match(/1:([\d\.]+)\s+xASTRO:ASTRO/i);
            if (inlineMatch) ratio = parseFloat(inlineMatch[1]);
        }
        
        // Try any "1:X.XX" pattern followed by xASTRO
        if (!ratio) {
            const generalMatch = txt.match(/1:([\d\.]+)[\s\S]*?xASTRO/i);
            if (generalMatch) ratio = parseFloat(generalMatch[1]);
        }
        
        // APY for xASTRO: "13.78%\nAPY" or "22.49% APY"
        const apyMatch = txt.match(/([\d\.]+)\s*%\s*[\n\r]?\s*APY/i);
        if (apyMatch) apy = parseFloat(apyMatch[1]);
        
        // Also try "APY: 22.49%" format
        if (!apy) {
            const altApyMatch = txt.match(/APY\s*:?\s*([\d\.]+)\s*%/i);
            if (altApyMatch) apy = parseFloat(altApyMatch[1]);
        }
    }
    
    // Update values if found
    if (ratio !== null && ratio > 0) {
        $(`lst-ratio-${token}`).value = ratio.toFixed(4);
        updateLstRatio(token, ratio);
    }
    if (apy !== null) {
        $(`lst-apy-${token}`).value = apy.toFixed(2);
        updateLstApy(token, apy);
    }
    
    // Clear paste box and update status
    if (ratio !== null || apy !== null) {
        pasteEl.value = '';
        updateLstCardStatus(token);
    }
}

function updateLstCardStatus(token) {
    const statusEl = $(`lst-status-${token}`);
    const cardEl = $(`lst-card-${token}`);
    if (!statusEl || !cardEl) return;
    
    const data = store.lstRatios[token];
    if (!data) return;
    
    const isUpdated = data.updated !== null;
    
    if (isUpdated) {
        statusEl.textContent = '‚úì updated';
        statusEl.className = 'text-[9px] px-2 py-0.5 rounded bg-green-900/50 text-green-400 text-center mb-2';
        cardEl.className = 'bg-[#161616] rounded-lg p-3 border-2 border-green-700';
    } else {
        statusEl.textContent = 'pending';
        statusEl.className = 'text-[9px] px-2 py-0.5 rounded bg-gray-800 text-gray-500 text-center mb-2';
        cardEl.className = 'bg-[#161616] rounded-lg p-3 border-2 border-gray-700';
    }
}

function updateLstOverallStatus() {
    const ratioTokens = ['ampLUNA', 'arbLUNA', 'bLUNA', 'ampCAPA', 'ampROAR', 'xASTRO'];
    const apyTokens = ['ampLUNA', 'arbLUNA', 'ampCAPA', 'ampROAR', 'xASTRO']; // bLUNA excluded - no APY available
    let ratioCount = 0;
    let apyCount = 0;
    
    ratioTokens.forEach(token => {
        if (store.lstRatios[token]?.ratio > 0) ratioCount++;
    });
    apyTokens.forEach(token => {
        if (store.lstRatios[token]?.apy > 0) apyCount++;
    });
    
    // Also check chain staking APR
    const hasChainApr = store.lstRatios.chainStakingApr > 0;
    
    const allRatios = ratioCount === ratioTokens.length;
    const allApys = apyCount === apyTokens.length;
    const allComplete = allRatios && allApys && hasChainApr;
    
    store.lstRatios.allUpdated = allComplete;
    
    const statusEl = $('lst-all-status');
    if (statusEl) {
        // Check for manual override
        if (store.ratiosVerified) {
            statusEl.innerHTML = '<i class="fas fa-check-circle mr-1"></i> Override ‚úì';
            statusEl.className = 'px-3 py-1 rounded text-[10px] font-bold bg-green-900/30 text-green-400 border border-green-700 cursor-pointer hover:opacity-80';
        } else if (allComplete) {
            statusEl.innerHTML = '<i class="fas fa-check-circle mr-1"></i> All Complete';
            statusEl.className = 'px-3 py-1 rounded text-[10px] font-bold bg-green-900/30 text-green-400 border border-green-700 cursor-pointer hover:opacity-80';
        } else {
            // Show what's missing
            let missing = [];
            if (!allRatios) missing.push(`Ratios: ${ratioCount}/6`);
            if (!allApys) missing.push(`APYs: ${apyCount}/5`);
            if (!hasChainApr) missing.push('Chain APR');
            statusEl.innerHTML = `<i class="fas fa-exclamation-circle mr-1"></i> ${missing.join(', ')} (click to override)`;
            statusEl.className = 'px-3 py-1 rounded text-[10px] font-bold bg-red-900/30 text-red-400 border border-red-700 cursor-pointer hover:opacity-80';
        }
    }
}

async function fetchChainStakingApr() {
    try {
        const resp = await fetch(STAKING_APR_CSV_URL);
        if (!resp.ok) throw new Error('Failed to fetch');
        
        const text = await resp.text();
        const lines = text.trim().split('\n');
        
        // Get last non-empty line (most recent APR)
        let lastLine = null;
        for (let i = lines.length - 1; i >= 0; i--) {
            if (lines[i].trim() && !lines[i].toLowerCase().includes('title')) {
                lastLine = lines[i];
                break;
            }
        }
        
        if (lastLine) {
            // Parse CSV: "12/19/2025,22.0373" or 12/19/2025,22.0373
            const parts = lastLine.split(',');
            if (parts.length >= 2) {
                const date = parts[0].replace(/"/g, '').trim();
                const apr = parseFloat(parts[1].replace(/"/g, '').trim());
                
                if (apr > 0) {
                    $('lst-chain-apr').value = apr.toFixed(2);
                    $('lst-chain-apr-date').textContent = `Last: ${date}`;
                    
                    store.lstRatios.chainStakingApr = apr;
                    store.lstRatios.chainStakingAprDate = date;
                    
                    // Check if data is stale (more than 2 days old)
                    checkStaleAprData(date);
                    return;
                }
            }
        }
        throw new Error('Could not parse APR');
    } catch (e) {
        console.error('Failed to fetch staking APR:', e);
        $('lst-chain-apr-date').textContent = 'Fetch failed - enter manually';
    }
}

function checkStaleAprData(dateStr) {
    // Parse date string - handle both YYYY-MM-DD and MM/DD/YYYY formats
    let dataDate;
    
    if (dateStr.includes('-')) {
        // YYYY-MM-DD format (ISO)
        dataDate = new Date(dateStr);
    } else if (dateStr.includes('/')) {
        // MM/DD/YYYY format
        const parts = dateStr.split('/');
        if (parts.length === 3) {
            dataDate = new Date(parts[2], parts[0] - 1, parts[1]);
        }
    }
    
    if (!dataDate || isNaN(dataDate)) return;
    
    const today = new Date();
    const diffDays = Math.floor((today - dataDate) / (1000 * 60 * 60 * 24));
    
    const dateEl = $('lst-chain-apr-date');
    const aprInput = $('lst-chain-apr');
    const aprCard = $('chain-apr-card');
    const aprTitle = $('chain-apr-title');
    const aprPct = $('chain-apr-pct');
    
    // Color coding:
    // Green (0 days) = today
    // Yellow (1-6 days) = this epoch/week
    // Red (7+ days) = older than this epoch
    
    if (diffDays === 0) {
        // Today - Green
        if (dateEl) {
            dateEl.textContent = `‚úì Updated today (${dateStr})`;
            dateEl.className = 'text-[9px] text-green-400 font-bold';
        }
        if (aprInput) {
            aprInput.className = 'input-dark text-xl font-bold w-24 text-center text-green-400';
        }
        if (aprTitle) {
            aprTitle.className = 'text-green-400 text-[10px] font-bold uppercase';
        }
        if (aprPct) {
            aprPct.className = 'text-green-400 text-lg';
        }
        if (aprCard) {
            aprCard.className = 'bg-[#0D0D0D] rounded-lg p-3 border-2 border-green-700';
        }
    } else if (diffDays <= 6) {
        // This week/epoch - Yellow
        if (dateEl) {
            dateEl.textContent = `Last: ${dateStr} (${diffDays}d ago)`;
            dateEl.className = 'text-[9px] text-yellow-400';
        }
        if (aprInput) {
            aprInput.className = 'input-dark text-xl font-bold w-24 text-center text-yellow-400';
        }
        if (aprTitle) {
            aprTitle.className = 'text-yellow-400 text-[10px] font-bold uppercase';
        }
        if (aprPct) {
            aprPct.className = 'text-yellow-400 text-lg';
        }
        if (aprCard) {
            aprCard.className = 'bg-[#0D0D0D] rounded-lg p-3 border-2 border-yellow-700';
        }
    } else {
        // More than a week old - Red
        if (dateEl) {
            dateEl.textContent = `‚ö†Ô∏è ${diffDays} days old (${dateStr}) - Update from Smart Stake!`;
            dateEl.className = 'text-[9px] text-red-400 font-bold';
        }
        if (aprInput) {
            aprInput.className = 'input-dark text-xl font-bold w-24 text-center text-red-400';
        }
        if (aprTitle) {
            aprTitle.className = 'text-red-400 text-[10px] font-bold uppercase';
        }
        if (aprPct) {
            aprPct.className = 'text-red-400 text-lg';
        }
        if (aprCard) {
            aprCard.className = 'bg-[#0D0D0D] rounded-lg p-3 border-2 border-red-700';
        }
    }
    
    updateWorkflowStatus();
}

// Fetch all LST ratios from chain - WORKING VERSION
async function fetchAllLstRatiosFromChain() {
    const tokens = ['ampLUNA', 'arbLUNA', 'bLUNA', 'ampROAR', 'ampCAPA'];
    
    // Set all to fetching
    tokens.forEach(token => {
        const statusEl = $(`lst-status-${token}`);
        if (statusEl) {
            statusEl.textContent = '‚è≥ fetching...';
            statusEl.className = 'text-[9px] px-2 py-0.5 rounded bg-yellow-900/50 text-yellow-400 flex-1 text-center';
        }
    });
    
    let successCount = 0;
    
    for (const [token, config] of Object.entries(lstContracts)) {
        try {
            const queryObj = config.query === 'exchange_rates' ? { exchange_rates: {} } : { state: {} };
            const query = btoa(JSON.stringify(queryObj));
            const url = `https://terra.publicnode.com/cosmwasm/wasm/v1/contract/${config.hub}/smart/${query}`;
            
            const res = await fetch(url);
            if (!res.ok) throw new Error('Query failed');
            
            const data = await res.json();
            const rate = config.parse(data);
            
            if (rate > 0) {
                // Update store
                store.lstRatios[token].ratio = rate;
                store.lstRatios[token].updated = new Date().toISOString();
                
                // Update UI
                const inputEl = $(`lst-ratio-${token}`);
                const statusEl = $(`lst-status-${token}`);
                const cardEl = $(`lst-card-${token}`);
                
                if (inputEl) inputEl.value = rate.toFixed(4);
                if (statusEl) {
                    statusEl.textContent = '‚úì fetched';
                    statusEl.className = 'text-[9px] px-2 py-0.5 rounded bg-green-900/50 text-green-400 flex-1 text-center';
                }
                if (cardEl) cardEl.className = 'bg-[#161616] rounded-lg p-3 border-2 border-green-700';
                
                // Sync to votion ratios
                if (token === 'ampLUNA') {
                    store.votion.ratioAmp = rate;
                    if ($('ratioAmp')) $('ratioAmp').value = rate.toFixed(4);
                } else if (token === 'arbLUNA') {
                    store.votion.ratioArb = rate;
                    if ($('ratioArb')) $('ratioArb').value = rate.toFixed(4);
                }
                
                successCount++;
                console.log(`‚úÖ ${token}: ${rate.toFixed(4)}`);
            } else {
                throw new Error('Invalid rate');
            }
        } catch (e) {
            console.warn(`‚ùå ${token} fetch failed:`, e.message);
            
            const statusEl = $(`lst-status-${token}`);
            const cardEl = $(`lst-card-${token}`);
            
            if (statusEl) {
                statusEl.textContent = '‚ùå failed';
                statusEl.className = 'text-[9px] px-2 py-0.5 rounded bg-red-900/50 text-red-400 flex-1 text-center';
            }
            if (cardEl) cardEl.className = 'bg-[#161616] rounded-lg p-3 border-2 border-red-700';
        }
    }
    
    updateLstOverallStatus();
    updateWorkflowStatus();
    updateRatios();
    
    console.log(`LST auto-fetch complete: ${successCount}/${tokens.length} successful`);
    return successCount;
}

function initLstRatiosTab() {
    // Initialize values from store
    const tokens = ['ampLUNA', 'arbLUNA', 'bLUNA', 'ampCAPA', 'ampROAR', 'xASTRO'];
    tokens.forEach(token => {
        const data = store.lstRatios[token];
        if (data) {
            const ratioEl = $(`lst-ratio-${token}`);
            const apyEl = $(`lst-apy-${token}`);
            if (ratioEl) ratioEl.value = data.ratio;
            if (apyEl && data.apy !== null) apyEl.value = data.apy;
            updateLstCardStatus(token);
        }
    });
    
    // Sync ampLUNA/arbLUNA to Votion tab display
    $('ratioArb').value = store.lstRatios.arbLUNA.ratio;
    $('ratioAmp').value = store.lstRatios.ampLUNA.ratio;
    store.votion.ratioArb = store.lstRatios.arbLUNA.ratio;
    store.votion.ratioAmp = store.lstRatios.ampLUNA.ratio;
    
    $('lst-chain-apr').value = store.lstRatios.chainStakingApr;
    updateLstOverallStatus();
}

function updateWorkflowStatus() {
    // Helper to set tab status
    function setTabStatus(tabId, status) {
        const tab = $(`tab-${tabId}`);
        if (!tab) return;
        
        // Remove all status classes
        tab.classList.remove('tab-incomplete', 'tab-complete', 'tab-partial', 'tab-optional');
        
        // Add new status class
        tab.classList.add(`tab-${status}`);
        
        // Update status indicator
        const statusEl = tab.querySelector('.tab-status');
        if (statusEl) {
            if (status === 'complete') statusEl.textContent = '‚úì';
            else if (status === 'partial') statusEl.textContent = '‚óê';
            else if (status === 'optional') statusEl.textContent = '‚óã';
            else statusEl.textContent = '‚óè';
        }
    }
    
    // Step 1: LP Registry
    let lpCount = Object.keys(store.lpRegistry).length;
    if (store.lpRegistryVerified) {
        setTabStatus('lpreg', 'complete');
    } else if (lpCount > 0) {
        setTabStatus('lpreg', 'partial');
    } else {
        setTabStatus('lpreg', 'incomplete');
    }
    
    // Step 2: Ratios - check ratios AND APYs (bLUNA APY excluded - can't get it)
    const ratioTokens = ['ampLUNA', 'arbLUNA', 'bLUNA', 'ampCAPA', 'ampROAR'];
    const apyTokens = ['ampLUNA', 'arbLUNA', 'ampCAPA', 'ampROAR', 'xASTRO']; // bLUNA excluded
    let ratioCount = 0, apyCount = 0;
    ratioTokens.forEach(t => { if (store.lstRatios[t]?.ratio > 0) ratioCount++; });
    apyTokens.forEach(t => { if (store.lstRatios[t]?.apy > 0) apyCount++; });
    
    // Check chain staking APR staleness - handle both date formats
    let chainAprStale = true;
    let chainAprSet = store.lstRatios.chainStakingApr > 0;
    if (store.lstRatios.chainStakingAprDate && chainAprSet) {
        let dateStr = store.lstRatios.chainStakingAprDate;
        let aprDate;
        
        if (dateStr.includes('-')) {
            // YYYY-MM-DD format (ISO)
            aprDate = new Date(dateStr);
        } else if (dateStr.includes('/')) {
            // MM/DD/YYYY format
            const parts = dateStr.split('/');
            if (parts.length === 3) {
                aprDate = new Date(parts[2], parts[0] - 1, parts[1]);
            }
        }
        
        if (aprDate && !isNaN(aprDate)) {
            const daysSince = (new Date() - aprDate) / 86400000;
            chainAprStale = daysSince > 2;
        }
    }
    
    // Check for manual override
    const ratiosOverride = store.ratiosVerified;
    const ratiosComplete = ratiosOverride || (ratioCount >= 5 && apyCount >= 5 && chainAprSet && !chainAprStale);
    
    if (ratiosComplete) {
        setTabStatus('ratios', 'complete');
    } else if (ratioCount > 0 || apyCount > 0) {
        setTabStatus('ratios', 'partial');
    } else {
        setTabStatus('ratios', 'incomplete');
    }
    
    // Step 3: Prices - check token prices
    const tokenCount = Object.keys(store.tokenPrices).length;
    const pricesOverride = store.tokenPricesVerified;
    
    if (pricesOverride || tokenCount >= 10) {
        setTabStatus('prices', 'complete');
    } else if (tokenCount > 0) {
        setTabStatus('prices', 'partial');
    } else {
        setTabStatus('prices', 'incomplete');
    }
    
    // Step 4: Votion - check all 6 lockups or skipped
    updateVotionChecklist();
    let lockCount = store.votion.lockups?.length || 0;
    let skipCount = 0;
    ['arbmax', 'ampmax', 'arb3mo', 'amp3mo', 'arb1wk', 'amp1wk'].forEach(id => {
        if ($(`votion-skip-${id}`)?.checked) skipCount++;
    });
    let votionComplete = (lockCount + skipCount) >= 6 && store.votionVerified;
    
    if (votionComplete) {
        setTabStatus('votion', 'complete');
    } else if (lockCount > 0) {
        setTabStatus('votion', 'partial');
    } else {
        setTabStatus('votion', 'incomplete');
    }
    
    // Step 5: PD Bribes
    let epoch = store.meta.ep;
    let pdCovered = false;
    for (let b of store.pdBribesHistory || []) {
        if (epoch >= b.start_epoch && epoch <= b.end_epoch) {
            pdCovered = true;
            break;
        }
    }
    
    if (pdCovered && store.pdBribesVerified) {
        setTabStatus('pdbribes', 'complete');
    } else if (pdCovered) {
        setTabStatus('pdbribes', 'partial');
    } else {
        setTabStatus('pdbribes', 'incomplete');
    }
    
    // Steps 6-7: Astroport and Skeleton are optional
    setTabStatus('astro', 'optional');
    setTabStatus('ww', 'optional');
}

// LP Registry scroll detection
function checkLpRegistryScroll(el) {
    const isAtBottom = el.scrollHeight - el.scrollTop <= el.clientHeight + 50;
    const lpCount = Object.keys(store.lpRegistry).length;
    
    if (isAtBottom && lpCount > 0) {
        $('lp-scroll-hint')?.classList.add('hidden');
        $('lp-verify-section')?.classList.remove('hidden');
    }
}

function confirmLpRegistry() {
    store.lpRegistryVerified = true;
    $('lp-verify-section').innerHTML = '<div class="flex items-center gap-2"><span class="text-green-400 text-lg">‚úì</span><span class="text-green-300 text-[11px]">LP Registry confirmed!</span></div>';
    updateWorkflowStatus();
}

function updateVotionChecklist() {
    // Map lockups to checklist items
    const lockupMap = {
        'arbLUNA-Max': 'arbmax',
        'arbLUNA-3mo': 'arb3mo',
        'arbLUNA-1wk': 'arb1wk',
        'ampLUNA-Max': 'ampmax',
        'ampLUNA-3mo': 'amp3mo',
        'ampLUNA-1wk': 'amp1wk'
    };
    
    // Reset all to unchecked
    Object.values(lockupMap).forEach(id => {
        const el = $(`votion-chk-${id}`);
        const skipEl = $(`votion-skip-${id}`);
        if (el) {
            const isSkipped = skipEl?.checked;
            if (isSkipped) {
                el.querySelector('.lock-status').textContent = '‚äò';
                el.className = 'flex items-center gap-1 text-gray-500 line-through';
            } else {
                el.querySelector('.lock-status').textContent = '‚òê';
                el.className = 'flex items-center gap-1 text-gray-600';
            }
        }
    });
    
    // Mark captured lockups
    let capturedCount = 0;
    let skippedCount = 0;
    
    for (let lock of store.votion.lockups || []) {
        const key = `${lock.type}-${lock.duration}`;
        const id = lockupMap[key];
        if (id) {
            const el = $(`votion-chk-${id}`);
            if (el) {
                el.querySelector('.lock-status').textContent = '‚úì';
                el.className = 'flex items-center gap-1 text-green-400';
                capturedCount++;
            }
        }
    }
    
    // Count skipped
    Object.values(lockupMap).forEach(id => {
        if ($(`votion-skip-${id}`)?.checked) skippedCount++;
    });
    
    // Update counter
    const total = capturedCount + skippedCount;
    const countEl = $('votion-checklist-count');
    if (countEl) {
        countEl.textContent = `${total}/6`;
        countEl.className = total >= 6 ? 'text-[9px] text-green-400' : 'text-[9px] text-red-400';
    }
    
    // Show/hide confirm button based on completion
    const confirmSection = $('votion-confirm-section');
    if (confirmSection) {
        if (total >= 6 && !store.votionVerified) {
            confirmSection.classList.remove('hidden');
        } else {
            confirmSection.classList.add('hidden');
        }
    }
    
    // Update votion summary counts
    let totalVp = 0, totalUsd = 0, totalRew = 0;
    for (let lock of store.votion.lockups || []) {
        totalVp += lock.vp || 0;
        totalUsd += lock.usd || 0;
        totalRew += lock.expectedRewards || 0;
    }
    
    setTxt('votion-lock-count', store.votion.lockups?.length || 0);
    setTxt('votion-total-vp', totalVp.toLocaleString(undefined, {maximumFractionDigits: 0}));
    setTxt('votion-total-usd', fmt$(totalUsd));
    setTxt('votion-total-rew', fmt$(totalRew));
    
    // Note: Don't call updateWorkflowStatus() here - it calls us and would cause infinite loop
}

function confirmVotionComplete() {
    store.votionVerified = true;
    const confirmSection = $('votion-confirm-section');
    if (confirmSection) {
        confirmSection.innerHTML = `
            <div class="text-green-400 text-[10px] text-center py-2">
                <i class="fas fa-check-circle mr-1"></i> Step ‚ë£ Complete!
            </div>
        `;
    }
    updateWorkflowStatus();
}

window.onload = async function() {
    // Fetch live epoch info first
    await fetchLiveEpochInfo();
    
    // Set initial working epoch from live data or calculate fallback
    if (store.liveEpoch) {
        $('extEpoch').value = store.liveEpoch.epoch;
        $('extPhase').value = store.liveEpoch.phase;
    } else {
        // Fallback calculation
        const anchorDate = new Date(Date.UTC(2025, 10, 17, 0, 0, 0)); 
        const now = new Date();
        const msPerWeek = 604800000;
        let diffTime = now.getTime() - anchorDate.getTime();
        let weeksPassed = Math.floor(diffTime / msPerWeek);
        let currentEp = 160 + weeksPassed;
        $('extEpoch').value = currentEp;
        $('extPhase').value = 'end';
    }
    updateMeta();
    
    // Initialize mode and Astro tab
    setMode('staging');
    renderLpRegistry();
    updateAstroTab();
    
    // Initialize LST Ratios tab
    initLstRatiosTab();
    
    // Auto-fetch data from GitHub (including PD Bribes)
    await fetchAllFromGithub();
    
    // Now render PD Bribes after data is loaded
    renderPdBribesHistory();
    updatePdCoverage();
    
    // Auto-fetch LST ratios from chain and staking APR
    fetchAllLstRatiosFromChain();
    fetchChainStakingApr();
    
    // Initialize workflow status
    updateWorkflowStatus();
    
    // Start timer to update countdown every minute
    setInterval(updateLiveCountdown, 60000);
};

function updateLiveCountdown() {
    if (!store.liveEpoch || !store.liveEpoch.end_time) return;
    
    const now = new Date();
    const endTime = new Date(store.liveEpoch.end_time);
    const msRemaining = endTime - now;
    const daysRemaining = msRemaining / 86400000;
    
    if (daysRemaining < 0) {
        // Epoch ended, refresh data
        fetchLiveEpochInfo();
        return;
    }
    
    // Update days remaining
    store.liveEpoch.daysRemaining = daysRemaining;
    
    // Update phase if changed
    // Phase based on days REMAINING:
    // 5-7 remaining = START (0-2 days into epoch)
    // 2-5 remaining = MID (2-5 days into epoch)
    // 0-2 remaining = END (5-7 days into epoch)
    let newPhase = 'end';
    if (daysRemaining >= 5) newPhase = 'start';
    else if (daysRemaining > 2) newPhase = 'mid';
    
    if (newPhase !== store.liveEpoch.phase) {
        store.liveEpoch.phase = newPhase;
        let phaseEl = $('live-phase');
        setTxt('live-phase', newPhase.charAt(0).toUpperCase() + newPhase.slice(1));
        phaseEl.className = 'text-sm font-mono font-bold ' + 
            (newPhase === 'start' ? 'text-green-400' : newPhase === 'mid' ? 'text-yellow-400' : 'text-red-400');
        checkEpochMismatch();
    }
    
    // Update countdown display
    let days = Math.floor(daysRemaining);
    let hours = Math.floor((daysRemaining - days) * 24);
    let mins = Math.floor(((daysRemaining - days) * 24 - hours) * 60);
    setTxt('live-ends', `${days}d ${hours}h ${mins}m`);
}

function switchTab(t) {
    // Remove active from all tabs
    document.querySelectorAll('.tab-btn').forEach(b => {
        b.classList.remove('active');
    });
    
    // Add active to clicked tab
    const activeTab = $(`tab-${t}`);
    if (activeTab) activeTab.classList.add('active');
    
    // Switch workspace
    document.querySelectorAll('.workspace').forEach(w => w.classList.remove('active'));
    let ws = $('ws-' + t);
    if (ws) ws.classList.add('active');
    
    // Auto-fetch ratios when switching to Ratios tab (if not already fetched)
    if (t === 'ratios') {
        // Check if ratios have been fetched already
        const hasRatios = Object.values(store.lstRatios).some(r => r?.ratio > 0);
        if (!hasRatios) {
            fetchAllLstRatiosFromChain();
            fetchChainStakingApr();
        }
    }
    
    // Auto-fetch prices when switching to Prices tab (always fetch to get latest)
    if (t === 'prices' && Object.keys(store.lpRegistry).length > 0) {
        fetchAllTokenPrices();
    }
    
    // Auto-fetch PD bribes and refresh preview when switching to that tab
    if (t === 'pdbribes') {
        // Fetch from GitHub if not loaded
        if (store.pdBribesHistory.length === 0) {
            fetchPdBribesFromGithub();
        } else {
            updatePdCoverage();
        }
    }
    
    // Update Astroport staging/normal display when switching to that tab
    if (t === 'astro') {
        updateAstroTab();
    }
}

function updateMeta() {
    store.meta.ep = parseInt($('extEpoch').value) || 0;
    store.meta.ph = $('extPhase').value;
    setTxt('target-epoch', store.meta.ep);
    setTxt('target-phase', store.meta.ph.charAt(0).toUpperCase() + store.meta.ph.slice(1));
    // Update coverage when epoch changes
    updatePdCoverage();
    updateAstroStatus();
    updateWorkflowStatus();
    checkEpochMismatch();
}

// ============ LIVE EPOCH FUNCTIONS ============

const EPOCH_DATA_URL = 'https://raw.githubusercontent.com/defipatriot/tla_json_storage/main/epoch_1-300_date.json';
let epochData = [];

async function fetchLiveEpochInfo() {
    try {
        setTxt('live-epoch', '...');
        setTxt('live-ends', '...');
        setTxt('live-phase', '...');
        
        // Fetch epoch data from GitHub (same source as Core tool)
        let resp = await fetch(EPOCH_DATA_URL);
        if (!resp.ok) throw new Error('Failed to fetch epoch data');
        
        epochData = await resp.json();
        console.log('Loaded epoch data:', epochData.length, 'epochs');
        
        // Find current epoch
        const now = new Date();
        let currentEpoch = null;
        
        for (let ep of epochData) {
            let start = new Date(ep.start_time);
            let end = new Date(ep.end_time);
            
            if (now >= start && now < end) {
                currentEpoch = ep;
                break;
            }
        }
        
        // If we're past all epochs, use the last one
        if (!currentEpoch && epochData.length > 0) {
            currentEpoch = epochData[epochData.length - 1];
        }
        
        if (!currentEpoch) throw new Error('No epoch data found');
        
        // Calculate time remaining
        let endTime = new Date(currentEpoch.end_time);
        let msRemaining = endTime - now;
        let daysRemaining = msRemaining / 86400000;
        
        // Phase based on days REMAINING:
        // 5-7 remaining = START (0-2 days into epoch)
        // 2-5 remaining = MID (2-5 days into epoch)
        // 0-2 remaining = END (5-7 days into epoch)
        let phase = 'end';
        if (daysRemaining >= 5) phase = 'start';
        else if (daysRemaining > 2) phase = 'mid';
        
        // Store live info
        store.liveEpoch = {
            epoch: currentEpoch.epoch,
            end_time: endTime.toISOString(),
            daysRemaining: daysRemaining,
            phase: phase
        };
        
        // Update display
        setTxt('live-epoch', currentEpoch.epoch);
        
        // Format time remaining
        let days = Math.floor(daysRemaining);
        let hours = Math.floor((daysRemaining - days) * 24);
        let mins = Math.floor(((daysRemaining - days) * 24 - hours) * 60);
        setTxt('live-ends', `${days}d ${hours}h ${mins}m`);
        
        // Phase with color
        let phaseEl = $('live-phase');
        setTxt('live-phase', phase.charAt(0).toUpperCase() + phase.slice(1));
        phaseEl.className = 'text-sm font-mono font-bold ' + 
            (phase === 'start' ? 'text-green-400' : phase === 'mid' ? 'text-yellow-400' : 'text-red-400');
        
        checkEpochMismatch();
        console.log('Live epoch info:', store.liveEpoch);
        
    } catch (e) {
        console.error('Failed to fetch live epoch:', e);
        setTxt('live-epoch', 'ERR');
        setTxt('live-ends', '-');
        setTxt('live-phase', '-');
        
        // Fallback to calculated epoch
        const anchorDate = new Date(Date.UTC(2025, 10, 17, 0, 0, 0)); 
        const now = new Date();
        const msPerWeek = 604800000;
        let diffTime = now.getTime() - anchorDate.getTime();
        let weeksPassed = Math.floor(diffTime / msPerWeek);
        let currentEp = 160 + weeksPassed;
        
        // Calculate approximate days remaining in epoch
        let msIntoEpoch = diffTime % msPerWeek;
        let msRemaining = msPerWeek - msIntoEpoch;
        let daysRemaining = msRemaining / 86400000;
        
        // Phase based on days REMAINING
        let phase = 'end';
        if (daysRemaining >= 5) phase = 'start';
        else if (daysRemaining > 2) phase = 'mid';
        
        store.liveEpoch = {
            epoch: currentEp,
            daysRemaining: daysRemaining,
            phase: phase,
            isFallback: true
        };
        
        setTxt('live-epoch', currentEp + '*');
        let days = Math.floor(daysRemaining);
        let hours = Math.floor((daysRemaining - days) * 24);
        setTxt('live-ends', `~${days}d ${hours}h`);
        setTxt('live-phase', phase.charAt(0).toUpperCase() + phase.slice(1));
        $('live-phase').className = 'text-sm font-mono font-bold ' + 
            (phase === 'start' ? 'text-green-400' : phase === 'mid' ? 'text-yellow-400' : 'text-red-400');
    }
}

function syncToLive() {
    if (!store.liveEpoch) {
        alert('No live epoch data. Click refresh first.');
        return;
    }
    
    $('extEpoch').value = store.liveEpoch.epoch;
    $('extPhase').value = store.liveEpoch.phase;
    updateMeta();
    
    console.log('Synced to live:', store.liveEpoch.epoch, store.liveEpoch.phase);
}

function checkEpochMismatch() {
    let warningEl = $('epoch-mismatch-warning');
    if (!warningEl || !store.liveEpoch) {
        if (warningEl) warningEl.classList.add('hidden');
        return;
    }
    
    let workingEp = store.meta.ep;
    let workingPh = store.meta.ph;
    let liveEp = store.liveEpoch.epoch;
    let livePh = store.liveEpoch.phase;
    
    let warnings = [];
    
    // Check epoch mismatch
    if (workingEp !== liveEp) {
        warnings.push(`Epoch ${workingEp} ‚â† live ${liveEp}`);
    }
    
    // Check phase mismatch
    if (workingPh !== livePh) {
        warnings.push(`Phase "${workingPh}" ‚â† live "${livePh}"`);
    }
    
    if (warnings.length > 0) {
        setTxt('mismatch-text', warnings.join(' | '));
        warningEl.classList.remove('hidden');
    } else {
        warningEl.classList.add('hidden');
    }
}

// ============ LOAD PREVIOUS EXT ============

function loadPreviousExt(event) {
    let file = event.target.files[0];
    if (!file) return;
    
    let reader = new FileReader();
    reader.onload = function(e) {
        try {
            let data = JSON.parse(e.target.result);
            store.prevExt = data;
            
            // Display info
            let meta = data.meta || {};
            let votionPools = Object.keys(data.votion?.pools || {}).length;
            let info = `Ep ${meta.epoch || '?'} ${meta.phase || '?'} | ${votionPools} pools`;
            setTxt('prev-ext-status', info);
            $('prev-ext-status').className = 'text-purple-300 text-[9px] truncate';
            
            console.log('Loaded previous ext:', data);
            
            // Optionally pre-fill data from previous ext
            if (confirm(`Loaded Ep ${meta.epoch} ${meta.phase}.\n\nPre-fill Votion ratios from this file?`)) {
                if (data.votion?.ratios) {
                    if (data.votion.ratios.arbLUNA) {
                        $('ratioArb').value = data.votion.ratios.arbLUNA;
                        store.votion.ratioArb = data.votion.ratios.arbLUNA;
                    }
                    if (data.votion.ratios.ampLUNA) {
                        $('ratioAmp').value = data.votion.ratios.ampLUNA;
                        store.votion.ratioAmp = data.votion.ratios.ampLUNA;
                    }
                    updateRatios();
                }
            }
            
        } catch (err) {
            console.error('Failed to parse previous ext:', err);
            setTxt('prev-ext-status', 'Parse error');
            $('prev-ext-status').className = 'text-red-400 text-[9px] truncate';
        }
    };
    reader.readAsText(file);
}

// ============ EXPORT VALIDATION ============

function validateExport() {
    let issues = [];
    let warnings = [];
    
    // Check epoch is set
    if (!store.meta.ep || store.meta.ep === 0) {
        issues.push('Epoch not set');
    }
    
    // Check epoch matches live
    if (store.liveEpoch && store.meta.ep !== store.liveEpoch.epoch) {
        warnings.push(`Working epoch ${store.meta.ep} differs from live ${store.liveEpoch.epoch}`);
    }
    
    // Check phase matches live
    if (store.liveEpoch && store.meta.ph !== store.liveEpoch.phase) {
        warnings.push(`Working phase "${store.meta.ph}" differs from live "${store.liveEpoch.phase}"`);
    }
    
    // Check Votion data
    if (store.votion.lockups.length === 0) {
        issues.push('No Votion lockups captured');
    } else {
        // Check for major lockups
        let hasArbMax = store.votion.lockups.some(l => l.type === 'arbLUNA' && l.duration === 'Max');
        let hasAmpMax = store.votion.lockups.some(l => l.type === 'ampLUNA' && l.duration === 'Max');
        if (!hasArbMax) warnings.push('Missing arbLUNA Max lockup');
        if (!hasAmpMax) warnings.push('Missing ampLUNA Max lockup');
    }
    
    // Check PD Bribes coverage
    let pdCovered = store.pdBribesHistory.some(prop => 
        store.meta.ep >= prop.start_epoch && store.meta.ep <= prop.end_epoch
    );
    if (!pdCovered) {
        warnings.push(`PD Bribes don't cover epoch ${store.meta.ep}`);
    }
    
    // Check ratios are reasonable
    if (store.votion.ratioArb < 2 || store.votion.ratioArb > 3) {
        warnings.push(`arbLUNA ratio ${store.votion.ratioArb} seems unusual (expected 2.0-3.0)`);
    }
    if (store.votion.ratioAmp < 1.5 || store.votion.ratioAmp > 2.5) {
        warnings.push(`ampLUNA ratio ${store.votion.ratioAmp} seems unusual (expected 1.5-2.5)`);
    }
    
    return { issues, warnings, canExport: issues.length === 0 };
}

function downloadExtJson() {
    // Run validation
    let validation = validateExport();
    
    // Show issues/warnings
    if (validation.issues.length > 0) {
        alert('‚ùå Cannot export - critical issues:\n\n‚Ä¢ ' + validation.issues.join('\n‚Ä¢ '));
        return;
    }
    
    if (validation.warnings.length > 0) {
        let proceed = confirm(
            '‚ö†Ô∏è Export warnings:\n\n‚Ä¢ ' + validation.warnings.join('\n‚Ä¢ ') + 
            '\n\nProceed with export anyway?'
        );
        if (!proceed) return;
    }
    
    // Generate and download
    let data = getExportData();
    let jsonStr = JSON.stringify(data, null, 2);
    let blob = new Blob([jsonStr], { type: "application/json" });
    let url = URL.createObjectURL(blob);
    let a = document.createElement('a');
    a.href = url;
    
    // Add _test suffix if in test mode
    const testSuffix = store.testMode ? '_test' : '';
    a.download = `tla-ext-epoch-${store.meta.ep}-${store.meta.ph}${testSuffix}.json`; 
    
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    // Update workflow status
    const statusText = store.testMode ? '‚úì saved (TEST)' : '‚úì saved';
    setTxt('step-export-val', statusText);
    $('step-export').classList.add('status-done');
    
    // Show alert with filename
    if (store.testMode) {
        alert(`üß™ TEST MODE\n\nFile saved as: tla-ext-epoch-${store.meta.ep}-${store.meta.ph}${testSuffix}.json\n\nThis file will NOT update the live TLA Stats page.`);
    }
}

// ============ MODE FUNCTIONS ============

function setMode(mode) {
    store.mode = mode;
    $('mode-staging').className = mode === 'staging' 
        ? 'px-2 py-1 text-[10px] rounded bg-yellow-900/50 text-yellow-400 border border-yellow-700'
        : 'px-2 py-1 text-[10px] rounded bg-gray-800 text-gray-500 border border-gray-700';
    $('mode-normal').className = mode === 'normal'
        ? 'px-2 py-1 text-[10px] rounded bg-green-900/50 text-green-400 border border-green-700'
        : 'px-2 py-1 text-[10px] rounded bg-gray-800 text-gray-500 border border-gray-700';
    updateAstroTab();
}

function toggleTestMode() {
    store.testMode = $('test-mode-toggle')?.checked || false;
    const indicator = $('test-mode-indicator');
    if (indicator) {
        if (store.testMode) {
            indicator.classList.remove('hidden');
        } else {
            indicator.classList.add('hidden');
        }
    }
}

// ============ FETCH FUNCTIONS ============

async function fetchAllFromGithub() {
    await fetchStagingData();
    await fetchHistoricalData();
    await fetchCurrentData();
    await fetchPdBribesFromGithub();
}

async function fetchStagingData() {
    for (let day of ['day1', 'day2', 'day3', 'day4']) {
        try {
            console.log(`Fetching staging ${day}: ${STAGING_URLS[day]}`);
            let resp = await fetch(STAGING_URLS[day]);
            console.log(`Staging ${day} response: ${resp.status}`);
            if (resp.ok) {
                let data = await resp.json();
                console.log(`Staging ${day} loaded:`, data);
                store.staging[day] = data;
            } else {
                console.log(`Staging ${day} not OK: ${resp.status}`);
            }
        } catch (e) {
            console.log(`Staging ${day} error:`, e);
        }
    }
    updateStagingStatus();
}

async function fetchHistoricalData() {
    try {
        let resp = await fetch(HISTORICAL_URL);
        if (resp.ok) {
            store.historical = await resp.json();
            setTxt('fetch-historical', '‚úì');
        } else {
            setTxt('fetch-historical', '-');
        }
    } catch (e) {
        setTxt('fetch-historical', '‚úó');
    }
}

async function fetchCurrentData() {
    try {
        let resp = await fetch(CURRENT_URL);
        if (resp.ok) {
            store.current = await resp.json();
            setTxt('fetch-current', '‚úì');
        } else {
            setTxt('fetch-current', '-');
        }
    } catch (e) {
        setTxt('fetch-current', '‚úó');
    }
}

function updateStagingStatus() {
    let days = ['day1', 'day2', 'day3', 'day4'];
    let completed = days.filter(d => store.staging[d] !== null).length;
    setTxt('fetch-staging', `${completed}/4`);
    
    // Update individual day boxes
    days.forEach(day => {
        let data = store.staging[day];
        let statusEl = $(`staging-${day}-status`);
        let lpsEl = $(`staging-${day}-lps`);
        
        if (data && data.lps) {
            let lpCount = Object.keys(data.lps).length;
            if (statusEl) {
                statusEl.innerText = data.captureDate || 'Loaded';
                statusEl.className = 'text-[10px] text-green-400';
            }
            if (lpsEl) {
                lpsEl.innerText = `${lpCount} LPs`;
            }
        } else if (data) {
            // Data exists but no lps object
            if (statusEl) {
                statusEl.innerText = 'Loaded (no LPs)';
                statusEl.className = 'text-[10px] text-yellow-400';
            }
        } else {
            // No data
            if (statusEl) {
                statusEl.innerText = 'Not found';
                statusEl.className = 'text-[10px] text-gray-600';
            }
            if (lpsEl) {
                lpsEl.innerText = '0 LPs';
            }
        }
    });
}

// ============ LP REGISTRY FUNCTIONS ============

function parseVoteTab() {
    let txt = $('voteTabPaste').value;
    let lines = txt.split('\n').map(l => l.trim()).filter(l => l);
    
    store.lpRegistry = {};
    
    const BUCKETS = ['stable', 'project', 'bluechip', 'single'];
    // Known single-sided pool tokens (no LP pair)
    const SINGLE_TOKENS = ['ampCAPA', 'xASTRO', 'AMPCAPA', 'XASTRO'];
    
    let currentBucket = null;
    let i = 0;
    
    while (i < lines.length) {
        let line = lines[i];
        let lineLower = line.toLowerCase();
        
        // Check for bucket header
        if (BUCKETS.includes(lineLower)) {
            currentBucket = lineLower;
            i++;
            continue;
        }
        
        // Look for LP pattern: "LUNA-USDC LP" or similar
        // Or single-sided: check if next line is "Single" or if it's a known single token
        let isSingle = false;
        let lpName = null;
        
        // Skip common non-LP lines
        if (line === 'icon' || line === 'Icon' || line === 'iconicon' || line === '') {
            i++;
            continue;
        }
        
        if (line.includes(' LP')) {
            lpName = line.replace(' LP', '').trim();
        } else if (line.endsWith('Single')) {
            // Line itself ends with Single (e.g., "ampCAPA Single")
            lpName = line.replace('Single', '').trim();
            isSingle = true;
        } else if (SINGLE_TOKENS.map(s => s.toUpperCase()).includes(line.toUpperCase())) {
            // Known single token (case insensitive)
            lpName = getCanonicalName(line);
            isSingle = true;
        } else if (i + 1 < lines.length && lines[i + 1].toLowerCase() === 'single') {
            // Next line is "Single" - this line is the token name (e.g., "ampCAPA" followed by "Single")
            lpName = getCanonicalName(line);
            isSingle = true;
            console.log('Detected single pool pattern:', line, '-> Single');
        }
        
        // Debug: log what we found
        if (lpName && isSingle) {
            console.log('Found single-sided pool:', lpName, 'from line:', line);
        }
        
        if (lpName) {
            // Look ahead for dex and vote %
            let dex = null;
            let votePct = 0;
            
            // For single-sided pools, default to Astroport if no DEX found
            let defaultDex = isSingle ? 'Astroport' : null;
            
            for (let k = 1; k <= 8 && i + k < lines.length; k++) {
                let next = lines[i + k];
                let nextLower = next.toLowerCase();
                
                // Skip "Single" marker line
                if (nextLower === 'single') continue;
                
                // Detect DEX - both names used, handle SkeletonSwap (no space) variant
                if (next === 'Astroport') {
                    dex = 'Astroport';
                } else if (next === 'WhiteWhale' || next === 'Skeleton Swap' || next === 'SkeletonSwap') {
                    dex = 'Skeleton Swap'; // Normalize to Skeleton Swap
                }
                
                // VP line: "VP 15.85M  76.9 %" or "VP 1.29M  5.8 %"
                if (next.startsWith('VP ') && next.includes('%')) {
                    let pctMatch = next.match(/([\d\.]+)\s*%/);
                    if (pctMatch) {
                        votePct = parseFloat(pctMatch[1]);
                    }
                    
                    // Use detected dex or default (for singles)
                    let finalDex = dex || defaultDex;
                    
                    // We found the VP for this dex, create the entry
                    if (finalDex && lpName) {
                        // Use composite key: "LUNA-USDC|Astroport" or "ampCAPA|Astroport"
                        let key = `${lpName}|${finalDex}`;
                        
                        store.lpRegistry[key] = {
                            lp: lpName,
                            dex: finalDex,
                            bucket: currentBucket || 'unknown',
                            vote_pct: votePct,
                            active: votePct >= 1,
                            single: isSingle  // Mark as single-sided pool
                        };
                        
                        if (isSingle) {
                            console.log('Created single pool entry:', key, votePct + '%');
                        }
                    }
                    
                    // For singles without explicit DEX, we're done after first VP
                    if (isSingle && !dex) {
                        break;
                    }
                    
                    // Reset for next potential dex entry for same LP
                    dex = null;
                    votePct = 0;
                }
                
                // Stop at next LP or bucket or single token
                let isNextLp = next.includes(' LP');
                let isNextSingle = SINGLE_TOKENS.includes(next) || (i + k + 1 < lines.length && lines[i + k + 1].toLowerCase() === 'single');
                let isNextBucket = BUCKETS.includes(nextLower);
                
                if (k > 2 && (isNextLp || isNextSingle || isNextBucket)) {
                    break;
                }
            }
        }
        i++;
    }
    
    $('voteTabPaste').value = '';
    renderLpRegistry();
    updateLpSummary();
    setTxt('fetch-lp', '‚úì');
    
    // Update Astroport dropdown
    updateAstroLpDropdown();
    
    // Update staging display if in staging mode
    if (store.mode === 'staging') {
        updateStagingDisplay();
    }
}

function renderLpRegistry() {
    let showActive = $('filter-active').checked;
    let showAstro = $('filter-astro').checked;
    let showWW = $('filter-ww').checked;
    
    let html = '';
    const BUCKETS = ['stable', 'project', 'bluechip', 'single'];
    
    BUCKETS.forEach(bucket => {
        let bucketLps = Object.entries(store.lpRegistry)
            .filter(([key, lp]) => lp.bucket === bucket)
            .filter(([key, lp]) => !showActive || lp.active)
            .filter(([key, lp]) => {
                if (lp.dex === 'Astroport' && !showAstro) return false;
                if (lp.dex === 'Skeleton Swap' && !showWW) return false;
                return true;
            })
            .sort((a, b) => b[1].vote_pct - a[1].vote_pct);
        
        if (bucketLps.length === 0) return;
        
        let bucketColor = bucket === 'stable' ? 'blue' : bucket === 'project' ? 'purple' : bucket === 'bluechip' ? 'yellow' : 'green';
        
        html += `<div class="bg-${bucketColor}-900/20 border-l-2 border-${bucketColor}-500 p-2 rounded">
            <div class="text-[10px] font-bold text-${bucketColor}-400 uppercase mb-2">${bucket} (${bucketLps.length})</div>
            <div class="space-y-1">`;
        
        bucketLps.forEach(([key, lp]) => {
            let activeClass = lp.active ? 'text-white' : 'text-gray-500';
            let dexColor = lp.dex === 'Astroport' ? 'text-cyan-400' : 'text-blue-400';
            let dexLabel = lp.dex === 'Astroport' ? 'Astro' : 'SS';
            // Show single indicator for single-sided pools
            let singleBadge = lp.single ? '<span class="text-[8px] bg-green-900/50 text-green-400 px-1 rounded ml-1">single</span>' : '';
            
            html += `<div class="flex items-center justify-between py-1 px-2 bg-[#0D0D0D] rounded text-[10px]">
                <span class="${activeClass} font-mono">${lp.lp}${singleBadge}</span>
                <div class="flex items-center gap-3">
                    <span class="${dexColor}">${lp.vote_pct.toFixed(1)}% ${dexLabel}</span>
                </div>
            </div>`;
        });
        
        html += `</div></div>`;
    });
    
    setHtml('lp-registry-list', html || '<div class="text-gray-600 text-[10px] italic text-center py-8">No LPs loaded. Paste Vote tab data above.</div>');
}

function updateLpSummary() {
    let total = Object.keys(store.lpRegistry).length;
    let active = Object.values(store.lpRegistry).filter(lp => lp.active).length;
    let astro = Object.values(store.lpRegistry).filter(lp => lp.dex === 'Astroport').length;
    let ww = Object.values(store.lpRegistry).filter(lp => lp.dex === 'Skeleton Swap').length;
    let singles = Object.values(store.lpRegistry).filter(lp => lp.single).length;
    
    setTxt('lp-total', total);
    setTxt('lp-active', active);
    setTxt('lp-astro', astro);
    setTxt('lp-ww', ww);
    if ($('lp-singles')) setTxt('lp-singles', singles);
}

function exportLpRegistry() {
    let json = JSON.stringify({ lpRegistry: store.lpRegistry }, null, 2);
    let blob = new Blob([json], { type: 'application/json' });
    let url = URL.createObjectURL(blob);
    let a = document.createElement('a');
    a.href = url;
    a.download = 'tla_lp_registry.json';
    a.click();
    URL.revokeObjectURL(url);
}

function loadLpRegistryPaste() {
    let txt = prompt('Paste LP Registry JSON:');
    if (!txt) return;
    try {
        let data = JSON.parse(txt);
        if (data.lpRegistry) {
            store.lpRegistry = data.lpRegistry;
        }
        renderLpRegistry();
        updateLpSummary();
        updateAstroLpDropdown();
        setTxt('fetch-lp', '‚úì');
    } catch (e) {
        alert('Invalid JSON');
    }
}

function parseVotion() {
    let txt = $('votionPaste').value;
    if (!txt.trim()) return;
    
    let lines = txt.split('\n').map(l => l.trim()).filter(l => l);
    
    // Get ratios from store (already fetched from chain)
    let ratioArb = store.votion.ratioArb || 0;
    let ratioAmp = store.votion.ratioAmp || 0;
    
    // Parse lockup info
    let lockup = {
        type: '',
        duration: '',
        amount: 0,
        luna: 0,
        vp: 0,
        usd: 0,
        lockApy: 0,      // APY shown on the lock (e.g. 80.06%)
        lstApy: 0,       // Base LST APY from Prices tab
        votionApy: 0,    // Additional yield from Votion = lockApy - lstApy
        period: 0,
        expectedRewards: 0,
        buckets: []
    };
    
    // Find lock type and duration: "arbLUNA - Max" or "ampLUNA - 3 Month"
    for (let i = 0; i < lines.length; i++) {
        let line = lines[i];
        if ((line.includes('arbLUNA -') || line.includes('ampLUNA -')) && !line.includes('%')) {
            lockup.type = line.includes('arbLUNA') ? 'arbLUNA' : 'ampLUNA';
            if (line.toLowerCase().includes('3 month')) lockup.duration = '3mo';
            else if (line.toLowerCase().includes('1 week') || line.toLowerCase().includes('week')) lockup.duration = '1wk';
            else if (line.toLowerCase().includes('max')) lockup.duration = 'Max';
            
            // Look ahead for amount, USD, APY
            for (let k = 1; k <= 12 && i + k < lines.length; k++) {
                let next = lines[i + k];
                if (next.includes(lockup.type) && !next.includes('-') && !next.includes('%') && lockup.amount === 0) {
                    lockup.amount = clean(next);
                }
                if (next.startsWith('$') && lockup.usd === 0) {
                    lockup.usd = clean(next);
                }
                // Capture the Lock APY (the big % shown on the lockup)
                if (next.includes('%') && !next.includes('‚Üí') && !next.includes('APY') && !next.includes('Period') && lockup.lockApy === 0) {
                    lockup.lockApy = parseFloat(next.replace(/[^0-9\.]/g, '')) || 0;
                }
                if (next === 'stable' || next === 'project' || next === 'bluechip' || next === 'single') break;
            }
            break;
        }
    }
    
    // Get the LST APY from the Prices tab store
    if (lockup.type === 'ampLUNA') {
        lockup.lstApy = store.lstRatios.ampLUNA?.apy || 0;
    } else if (lockup.type === 'arbLUNA') {
        lockup.lstApy = store.lstRatios.arbLUNA?.apy || 0;
    }
    
    // Calculate Votion APY = Lock APY - LST APY
    if (lockup.lockApy > 0 && lockup.lstApy > 0) {
        lockup.votionApy = lockup.lockApy - lockup.lstApy;
    }
    
    // Parse period
    for (let i = 0; i < lines.length; i++) {
        if (lines[i] === 'Period' && lines[i+1]) {
            lockup.period = parseInt(lines[i+1]) || 0;
        }
        if (lines[i].includes('Total Expected Rewards') && lines[i+1]) {
            lockup.expectedRewards = clean(lines[i+1]);
        }
    }
    
    // Calculate LUNA and VP
    if (lockup.amount > 0 && lockup.type) {
        let ratio = lockup.type === 'arbLUNA' ? ratioArb : ratioAmp;
        lockup.luna = lockup.amount * ratio;
        let vpMult = lockup.duration === 'Max' ? 10 : (lockup.duration === '3mo' ? 2 : 1);
        lockup.vp = lockup.luna * vpMult;
    }
    
    // Parse buckets and vote allocations
    const BUCKET_NAMES = ['stable', 'project', 'bluechip', 'single'];
    
    for (let i = 0; i < lines.length; i++) {
        let line = lines[i].toLowerCase();
        
        if (BUCKET_NAMES.includes(line)) {
            let bucketName = lines[i];
            let expectedRewards = 0;
            let pools = [];
            
            for (let k = 1; k <= 50 && i + k < lines.length; k++) {
                let next = lines[i + k];
                let nextLower = next.toLowerCase();
                
                if (BUCKET_NAMES.includes(nextLower) && k > 2) break;
                
                if (lines[i + k - 1] === 'Expected Rewards' && next.includes('$')) {
                    expectedRewards = clean(next);
                }
                
                // Pool detection - includes single assets like ampCAPA
                if ((next.includes(' LP') || next.match(/^[a-zA-Z]+-[a-zA-Z]+$/) || next === 'ampCAPA' || next === 'xASTRO') && !next.includes('$') && !next.includes('%')) {
                    let poolName = next.replace(' LP', '');
                    let currentPct = null;  // Use null to distinguish "not set" from "0%"
                    let optimizedPct = null;
                    
                    for (let m = 1; m <= 4 && i + k + m < lines.length; m++) {
                        let pctLine = lines[i + k + m];
                        if (pctLine.includes('%') && !pctLine.includes('‚Üí')) {
                            let pct = parseFloat(pctLine.replace(/[^0-9\.]/g, '')) || 0;
                            if (currentPct === null) currentPct = pct;
                            else if (optimizedPct === null) optimizedPct = pct;
                        }
                        if (pctLine === '‚Üí' && lines[i + k + m + 1]) {
                            optimizedPct = parseFloat(lines[i + k + m + 1].replace(/[^0-9\.]/g, '')) || 0;
                        }
                    }
                    
                    // Convert null to 0 for final values
                    currentPct = currentPct ?? 0;
                    optimizedPct = optimizedPct ?? 0;
                    
                    if (currentPct > 0 || optimizedPct > 0) {
                        pools.push({
                            name: poolName,
                            current: currentPct,
                            optimized: optimizedPct,
                            change: optimizedPct - currentPct
                        });
                    }
                }
            }
            
            if (pools.length > 0) {
                lockup.buckets.push({
                    name: bucketName,
                    expectedRewards: expectedRewards,
                    pools: pools
                });
            }
        }
    }
    
    // Only add if we got valid data
    if (lockup.type && lockup.amount > 0) {
        // Check for duplicate (same type + duration) and update
        let existingIdx = store.votion.lockups.findIndex(l => l.type === lockup.type && l.duration === lockup.duration);
        if (existingIdx >= 0) {
            store.votion.lockups[existingIdx] = lockup;
        } else {
            store.votion.lockups.push(lockup);
        }
        
        $('votionPaste').value = '';
        renderVotion();
        updateWorkflowStatus();
        pasteStatus.votion = true;
        updatePasteStatus('ps-votion', true);
    } else {
        alert('Could not parse lockup data. Make sure you copied the entire page.');
    }
}

function clearVotionLocks() {
    if (confirm('Clear all loaded Votion lockups?')) {
        store.votion.lockups = [];
        renderVotion();
        updateWorkflowStatus();
        pasteStatus.votion = false;
        updatePasteStatus('ps-votion', false);
    }
}

// ============================================
// VOTION API FETCH FUNCTIONS
// ============================================
const VOTION_API_BASE = 'https://backend.erisprotocol.com/votion/liquidity-alliance';

// CORS proxies to try if direct fetch fails
const CORS_PROXIES = [
    '', // Try direct first
    'https://api.allorigins.win/raw?url=',
    'https://corsproxy.io/?'
];

const VOTION_LOCKUPS = [
    { id: 'arbluna-max', type: 'arbLUNA', duration: 'Max', multiplier: 10 },
    { id: 'ampluna-max', type: 'ampLUNA', duration: 'Max', multiplier: 10 },
    { id: 'arbluna-12', type: 'arbLUNA', duration: '3mo', multiplier: 2 },
    { id: 'ampluna-12', type: 'ampLUNA', duration: '3mo', multiplier: 2 },
    { id: 'arbluna-1', type: 'arbLUNA', duration: '1wk', multiplier: 1 },
    { id: 'ampluna-1', type: 'ampLUNA', duration: '1wk', multiplier: 1 },
];

// Track which proxy works
let workingProxy = null;

async function fetchWithCorsRetry(url) {
    // If we already found a working proxy, use it
    if (workingProxy !== null) {
        const proxyUrl = workingProxy + (workingProxy ? encodeURIComponent(url) : url);
        const response = await fetch(proxyUrl, {
            method: 'GET',
            headers: { 'Accept': 'application/json' }
        });
        if (response.ok) return response;
        // If it fails, reset and try all proxies again
        workingProxy = null;
    }
    
    // Try each proxy
    for (const proxy of CORS_PROXIES) {
        try {
            const proxyUrl = proxy + (proxy ? encodeURIComponent(url) : url);
            console.log(`  Trying: ${proxy || 'direct'}...`);
            const response = await fetch(proxyUrl, {
                method: 'GET',
                headers: { 'Accept': 'application/json' }
            });
            if (response.ok) {
                workingProxy = proxy;
                console.log(`  ‚úì Success via ${proxy || 'direct'}`);
                return response;
            }
        } catch (e) {
            console.log(`  ‚úó ${proxy || 'direct'} failed: ${e.message}`);
        }
    }
    throw new Error('All fetch methods failed');
}

async function fetchVotionFromApi(lockupId) {
    const lockupConfig = VOTION_LOCKUPS.find(l => l.id === lockupId);
    if (!lockupConfig) {
        console.error('Unknown lockup:', lockupId);
        return null;
    }

    const url = `${VOTION_API_BASE}/${lockupId}/optimization`;
    
    try {
        const response = await fetchWithCorsRetry(url);
        const data = await response.json();
        
        // Get ratios from store
        const ratio = lockupConfig.type === 'arbLUNA' 
            ? (store.votion.ratioArb || store.lstRatios.arbLUNA?.ratio || 0)
            : (store.votion.ratioAmp || store.lstRatios.ampLUNA?.ratio || 0);
        
        // Get VP from first optimization (all have same total VP)
        const vp = data.optimizations?.[0]?.votingPower || 0;
        
        // Calculate amount: VP = amount * ratio * multiplier
        const amount = ratio > 0 ? vp / (ratio * lockupConfig.multiplier) : 0;
        const luna = amount * ratio;
        
        // Get LUNA price for USD calculation
        const lunaPrice = store.prices?.luna || 0;
        const usd = luna * lunaPrice;
        
        // Build lockup object matching existing structure
        const lockup = {
            type: lockupConfig.type,
            duration: lockupConfig.duration,
            amount: amount,
            luna: luna,
            vp: vp,
            usd: usd,
            lockApy: 0,      // Will calculate below
            lstApy: lockupConfig.type === 'ampLUNA' 
                ? (store.lstRatios.ampLUNA?.apy || 0)
                : (store.lstRatios.arbLUNA?.apy || 0),
            votionApy: 0,    // Will calculate below
            period: parseInt(data.period) || 0,
            expectedRewards: data.summary?.totalExpectedReward || 0,
            buckets: [],
            fetchedFromApi: true,
            fetchedAt: new Date().toISOString()
        };
        
        // Calculate Votion APY from expected rewards
        // Votion APY = (Weekly Rewards / USD Value) * 52 * 100
        if (lockup.expectedRewards > 0 && usd > 0) {
            lockup.votionApy = (lockup.expectedRewards / usd) * 52 * 100;
            // Lock APY = LST APY + Votion APY
            lockup.lockApy = lockup.lstApy + lockup.votionApy;
        }
        
        // Parse buckets from optimizations
        const BUCKET_NAMES = ['stable', 'project', 'bluechip', 'single'];
        
        for (const opt of data.optimizations || []) {
            if (!BUCKET_NAMES.includes(opt.id)) continue;
            
            const pools = [];
            const meta = opt.meta?.votes || [];
            
            // Build pool list from activeVoted and newVoted
            const allPools = new Set([
                ...Object.keys(opt.activeVoted || {}),
                ...Object.keys(opt.newVoted || {})
            ]);
            
            for (const poolAddr of allPools) {
                const poolMeta = meta.find(m => m.id === poolAddr);
                const poolName = poolMeta?.title?.replace(' LP', '') || poolAddr.slice(0, 8) + '...';
                
                const current = opt.activeVoted?.[poolAddr] || 0;
                const optimized = opt.newVoted?.[poolAddr] || 0;
                
                if (current > 0 || optimized > 0) {
                    pools.push({
                        name: poolName,
                        current: parseFloat(current.toFixed(2)),
                        optimized: parseFloat(optimized.toFixed(2)),
                        change: parseFloat((optimized - current).toFixed(2)),
                        address: poolAddr
                    });
                }
            }
            
            pools.sort((a, b) => b.optimized - a.optimized);
            
            lockup.buckets.push({
                name: opt.id,
                expectedRewards: opt.optimization?.totalExpectedReward || 0,
                isWorthChanging: opt.diff?.isWorthChanging || false,
                potentialGain: opt.diff?.rewardLoss || 0,
                pools: pools
            });
        }
        
        return lockup;
        
    } catch (err) {
        console.error(`Failed to fetch Votion ${lockupId}:`, err);
        return null;
    }
}

async function fetchAllVotion() {
    const statusEl = $('votion-fetch-status');
    if (statusEl) statusEl.innerHTML = '<span class="text-yellow-400"><i class="fas fa-spinner fa-spin mr-1"></i>Fetching all lockups...</span>';
    
    let successCount = 0;
    let skipCount = 0;
    let failCount = 0;
    
    for (const lockupConfig of VOTION_LOCKUPS) {
        try {
            const lockup = await fetchVotionFromApi(lockupConfig.id);
            
            if (lockup && lockup.vp > 0) {
                // Check for duplicate and update
                const existingIdx = store.votion.lockups.findIndex(
                    l => l.type === lockup.type && l.duration === lockup.duration
                );
                
                if (existingIdx >= 0) {
                    store.votion.lockups[existingIdx] = lockup;
                } else {
                    store.votion.lockups.push(lockup);
                }
                successCount++;
                console.log(`‚úì Fetched ${lockupConfig.type} ${lockupConfig.duration}: VP=${lockup.vp.toLocaleString()}`);
            } else if (lockup === null) {
                // API error (not empty position)
                failCount++;
                console.log(`‚úó ${lockupConfig.type} ${lockupConfig.duration}: API error`);
            } else {
                skipCount++;
                console.log(`‚äò ${lockupConfig.type} ${lockupConfig.duration}: No position`);
            }
        } catch (err) {
            failCount++;
            console.error(`‚úó ${lockupConfig.type} ${lockupConfig.duration}:`, err.message);
        }
    }
    
    renderVotion();
    updateWorkflowStatus();
    
    if (statusEl) {
        if (successCount > 0) {
            statusEl.innerHTML = `<span class="text-green-400">‚úì Loaded ${successCount} lockups</span>` +
                (skipCount > 0 ? `<span class="text-gray-500 ml-2">(${skipCount} empty)</span>` : '') +
                (failCount > 0 ? `<span class="text-red-400 ml-2">(${failCount} failed)</span>` : '');
            pasteStatus.votion = true;
            updatePasteStatus('ps-votion', true);
        } else if (skipCount > 0) {
            statusEl.innerHTML = `<span class="text-gray-400">No positions found in ${skipCount} lockups</span>`;
        } else {
            statusEl.innerHTML = `<span class="text-red-400">Failed to fetch (${failCount} errors)</span>`;
        }
    }
    
    return { success: successCount, skipped: skipCount, failed: failCount };
}

// Fetch single lockup by ID (for selective refresh)
async function fetchSingleVotion(lockupId) {
    const statusEl = $('votion-fetch-status');
    if (statusEl) statusEl.innerHTML = `<span class="text-yellow-400">Fetching ${lockupId}...</span>`;
    
    const lockup = await fetchVotionFromApi(lockupId);
    
    if (lockup && lockup.vp > 0) {
        const existingIdx = store.votion.lockups.findIndex(
            l => l.type === lockup.type && l.duration === lockup.duration
        );
        
        if (existingIdx >= 0) {
            store.votion.lockups[existingIdx] = lockup;
        } else {
            store.votion.lockups.push(lockup);
        }
        
        renderVotion();
        updateWorkflowStatus();
        
        if (statusEl) statusEl.innerHTML = `<span class="text-green-400">‚úì Loaded ${lockup.type} ${lockup.duration}</span>`;
        pasteStatus.votion = true;
        updatePasteStatus('ps-votion', true);
    } else {
        if (statusEl) statusEl.innerHTML = `<span class="text-gray-400">No position in ${lockupId}</span>`;
    }
}
// ============================================

function recalcVotion() {
    let ratioArb = store.votion.ratioArb || 0;
    let ratioAmp = store.votion.ratioAmp || 0;
    
    store.votion.lockups.forEach(lockup => {
        let ratio = lockup.type === 'arbLUNA' ? ratioArb : ratioAmp;
        lockup.luna = lockup.amount * ratio;
        let vpMult = lockup.duration === 'Max' ? 10 : (lockup.duration === '3mo' ? 2 : 1);
        lockup.vp = lockup.luna * vpMult;
        
        // Recalculate APY breakdown with latest LST APY
        if (lockup.type === 'ampLUNA') {
            lockup.lstApy = store.lstRatios.ampLUNA?.apy || 0;
        } else if (lockup.type === 'arbLUNA') {
            lockup.lstApy = store.lstRatios.arbLUNA?.apy || 0;
        }
        
        // Votion APY = Lock APY - LST APY
        if (lockup.lockApy > 0) {
            lockup.votionApy = lockup.lockApy - (lockup.lstApy || 0);
        }
    });
    
    renderVotion();
    updateWorkflowStatus();
}

function removeLockup(idx) {
    store.votion.lockups.splice(idx, 1);
    renderVotion();
    updateWorkflowStatus();
    if (store.votion.lockups.length === 0) {
        pasteStatus.votion = false;
        updatePasteStatus('ps-votion', false);
    }
}

function renderVotion() {
    let totalVp = 0;
    let totalUsd = 0;
    let totalRew = 0;
    
    // Sort lockups: arbLUNA first, then by duration
    let sortedLockups = [...store.votion.lockups].sort((a, b) => {
        if (a.type !== b.type) return a.type === 'arbLUNA' ? -1 : 1;
        const durOrder = { 'Max': 0, '3mo': 1, '1wk': 2 };
        return durOrder[a.duration] - durOrder[b.duration];
    });
    
    let cardsHtml = '';
    
    sortedLockups.forEach((lockup, idx) => {
        totalVp += lockup.vp;
        totalUsd += lockup.usd;
        totalRew += lockup.expectedRewards;
        
        let typeColor = lockup.type === 'arbLUNA' ? 'orange' : 'cyan';
        let typeBorder = lockup.type === 'arbLUNA' ? 'border-orange-500' : 'border-cyan-500';
        let typeBg = lockup.type === 'arbLUNA' ? 'bg-orange-900/10' : 'bg-cyan-900/10';
        
        cardsHtml += `<div class="preview-card ${typeBg} border-l-4 ${typeBorder}">
            <!-- Header -->
            <div class="flex justify-between items-center mb-2 pb-2 border-b border-gray-800">
                <div class="flex items-center gap-3">
                    <span class="text-${typeColor}-400 font-bold text-sm">${lockup.type}</span>
                    <span class="text-gray-400 text-xs bg-gray-800 px-2 py-0.5 rounded">${lockup.duration}</span>
                    <span class="text-gray-500 text-[10px]">Period ${lockup.period}</span>
                </div>
                <button onclick="removeLockup(${idx})" class="text-red-400 hover:text-red-300 text-[10px]">‚úï Remove</button>
            </div>
            
            <!-- Stats Row -->
            <div class="grid grid-cols-5 gap-2 mb-3 text-[10px]">
                <div class="bg-gray-900/50 rounded p-2 text-center">
                    <div class="text-gray-500">Amount</div>
                    <div class="text-white font-mono">${lockup.amount.toLocaleString()}</div>
                </div>
                <div class="bg-gray-900/50 rounded p-2 text-center">
                    <div class="text-gray-500">LUNA Eq.</div>
                    <div class="text-gray-300 font-mono">${lockup.luna.toLocaleString(undefined,{maximumFractionDigits:0})}</div>
                </div>
                <div class="bg-gray-900/50 rounded p-2 text-center">
                    <div class="text-gray-500">Voting Power</div>
                    <div class="text-teal-400 font-mono font-bold">${lockup.vp.toLocaleString(undefined,{maximumFractionDigits:0})}</div>
                </div>
                <div class="bg-gray-900/50 rounded p-2 text-center">
                    <div class="text-gray-500">USD Value</div>
                    <div class="text-green-400 font-mono">${fmt$(lockup.usd)}</div>
                </div>
                <div class="bg-gray-900/50 rounded p-2 text-center">
                    <div class="text-gray-500">Est. Rewards</div>
                    <div class="text-green-400 font-mono">${fmt$(lockup.expectedRewards)}</div>
                </div>
            </div>
            
            <!-- APY Breakdown -->
            <div class="grid grid-cols-4 gap-2 mb-3 text-[10px] bg-yellow-900/20 rounded p-2 border border-yellow-900/50">
                <div class="text-center">
                    <div class="text-yellow-500 font-bold">Lock APY</div>
                    <div class="text-yellow-400 font-mono text-lg font-bold">${lockup.lockApy > 0 ? lockup.lockApy.toFixed(2) + '%' : '--'}</div>
                </div>
                <div class="text-center flex flex-col justify-center">
                    <div class="text-gray-500">=</div>
                </div>
                <div class="text-center">
                    <div class="text-${typeColor}-400">${lockup.type} APY</div>
                    <div class="text-${typeColor}-300 font-mono">${lockup.lstApy > 0 ? lockup.lstApy.toFixed(2) + '%' : '<span class="text-red-400">NOT SET</span>'}</div>
                </div>
                <div class="text-center">
                    <div class="text-green-400">+ Votion APY</div>
                    <div class="text-green-300 font-mono">${lockup.votionApy > 0 ? '+' + lockup.votionApy.toFixed(2) + '%' : '--'}</div>
                </div>
            </div>
            
            <!-- Vote Allocations -->
            <div class="text-[9px]">`;
        
        lockup.buckets.forEach(bucket => {
            let bucketColor = bucket.name === 'stable' ? 'blue' : 
                              bucket.name === 'project' ? 'purple' :
                              bucket.name === 'bluechip' ? 'yellow' : 'green';
            
            cardsHtml += `<div class="mb-2">
                <div class="flex justify-between items-center bg-${bucketColor}-900/30 px-2 py-1 rounded-t border-l-2 border-${bucketColor}-500">
                    <span class="font-bold text-${bucketColor}-400 uppercase">${bucket.name}</span>
                    <span class="text-green-400 font-mono">${fmt$(bucket.expectedRewards)}</span>
                </div>
                <div class="bg-gray-900/30 rounded-b">`;
            
            bucket.pools.forEach(pool => {
                let changeColor = pool.change > 0 ? 'text-green-400' : (pool.change < 0 ? 'text-red-400' : 'text-gray-500');
                let changeStr = pool.change > 0 ? '+' + pool.change.toFixed(2) + '%' : pool.change.toFixed(2) + '%';
                let poolVotes = lockup.vp * (pool.optimized / 100);
                
                cardsHtml += `<div class="grid grid-cols-12 gap-1 px-2 py-0.5 border-b border-gray-800/30 hover:bg-white/5">
                    <div class="col-span-4 text-white truncate">${pool.name}</div>
                    <div class="col-span-2 text-right text-gray-500">${pool.current.toFixed(2)}%</div>
                    <div class="col-span-1 text-center text-gray-600">‚Üí</div>
                    <div class="col-span-2 text-right text-white">${pool.optimized.toFixed(2)}%</div>
                    <div class="col-span-2 text-right text-teal-400 font-mono">${poolVotes.toLocaleString(undefined,{maximumFractionDigits:0})}</div>
                    <div class="col-span-1 text-right ${changeColor}">${changeStr}</div>
                </div>`;
            });
            
            cardsHtml += `</div></div>`;
        });
        
        cardsHtml += `</div></div>`;
    });
    
    if (cardsHtml === '') {
        cardsHtml = '<div class="text-gray-600 text-[10px] italic text-center py-8 col-span-full border border-dashed border-gray-800 rounded">No lockups loaded. Paste each Votion lockup page and click "Add Lockup".</div>';
    }
    
    setHtml('votion-lockups', cardsHtml);
    setTxt('votion-lock-count', store.votion.lockups.length);
    setTxt('votion-total-vp', totalVp.toLocaleString(undefined,{maximumFractionDigits:0}));
    setTxt('votion-total-usd', fmt$(totalUsd));
    setTxt('votion-total-rew', fmt$(totalRew));
}

// ============ PD BRIBES FUNCTIONS ============

async function fetchPdBribesFromGithub() {
    setTxt('pd-fetch-status', '‚è≥');
    try {
        let resp = await fetch(PD_BRIBES_GITHUB_URL);
        if (!resp.ok) throw new Error('Failed to fetch');
        let data = await resp.json();
        store.pdBribesHistory = data;
        setTxt('pd-fetch-status', '‚úì');
        renderPdBribesHistory();
        updatePdCoverage();
    } catch (e) {
        setTxt('pd-fetch-status', '‚úó');
        console.error('Failed to fetch PD bribes:', e);
        // Don't show alert - just log to console
    }
}

function loadPdBribesJson() {
    let txt = $('pdJsonPaste').value.trim();
    if (!txt) return;
    try {
        let data = JSON.parse(txt);
        if (Array.isArray(data)) {
            store.pdBribesHistory = data;
            $('pdJsonPaste').value = '';
            renderPdBribesHistory();
            updatePdCoverage();
            pasteStatus.pd = true;
            updatePasteStatus('ps-pd', true);
        } else {
            alert('Invalid JSON format. Expected an array of props.');
        }
    } catch (e) {
        alert('Failed to parse JSON: ' + e.message);
    }
}

function parsePdBribes() {
    let txt = $('pdPaste').value;
    let lines = txt.split('\n').map(l => l.trim()).filter(l => l);
    
    let newProp = {
        epoch_range: '',
        start_epoch: 0,
        end_epoch: 0,
        bribes: []
    };
    
    // Parse epoch range: "Bribes for [160-163]:"
    for (let line of lines) {
        let epochMatch = line.match(/\[(\d+)[-‚Äì‚Äî](\d+)\]/);
        if (epochMatch) {
            newProp.start_epoch = parseInt(epochMatch[1]);
            newProp.end_epoch = parseInt(epochMatch[2]);
            newProp.epoch_range = `[${newProp.start_epoch}-${newProp.end_epoch}]`;
            break;
        }
    }
    
    // Parse gauges and pools
    let currentGauge = null;
    
    for (let i = 0; i < lines.length; i++) {
        let line = lines[i];
        
        // Gauge header
        let gaugeMatch = line.match(/^Gauge:\s*(\w+)/i) || line.match(/^(project|bluechip|single|stable):/i);
        if (gaugeMatch) {
            currentGauge = gaugeMatch[1].toLowerCase();
            continue;
        }
        
        // Pool line
        let hasPoolPattern = line.match(/^[\*\‚Ä¢\-]?\s*([A-Za-z0-9\.\-]+)\s*\([\d\.]+%\)/);
        
        if (currentGauge && hasPoolPattern) {
            let poolNameMatch = line.match(/^[\*\‚Ä¢\-]?\s*([A-Za-z0-9\.\-]+)\s*\(/);
            let scoreMatch = line.match(/\((\d+\.?\d*)%\)/);
            let usdMatch = line.match(/:\s*\$?\s*(\d+)\s*=/);
            let lunaMatch = line.match(/=\s*([\d,\.]+)\s*LUNA/i);
            
            if (poolNameMatch && scoreMatch && usdMatch) {
                newProp.bribes.push({
                    gauge: currentGauge,
                    pool: poolNameMatch[1].toUpperCase(),
                    percent: parseFloat(scoreMatch[1]),
                    usd_per_epoch: parseFloat(usdMatch[1]),
                    luna_per_epoch: lunaMatch ? parseFloat(lunaMatch[1].replace(/,/g, '')) : 0
                });
            }
        }
    }
    
    // Store as new prop and update preview
    if (newProp.start_epoch && newProp.bribes.length > 0) {
        store.pdNewProp = newProp;
        updateNewPropPreview();
        
        // Check if this prop already exists
        let existingIdx = store.pdBribesHistory.findIndex(p => 
            p.start_epoch === newProp.start_epoch && p.end_epoch === newProp.end_epoch
        );
        
        if (existingIdx >= 0) {
            if (confirm(`Prop ${newProp.epoch_range} already exists. Replace it?`)) {
                store.pdBribesHistory[existingIdx] = newProp;
            }
        } else {
            store.pdBribesHistory.push(newProp);
            // Sort by start_epoch
            store.pdBribesHistory.sort((a, b) => a.start_epoch - b.start_epoch);
        }
        
        $('pdPaste').value = '';
        renderPdBribesHistory();
        updatePdCoverage();
        pasteStatus.pd = true;
        updatePasteStatus('ps-pd', true);
    } else {
        alert('Could not parse prop data. Check format.');
    }
}

function updateNewPropPreview() {
    let prop = store.pdNewProp;
    if (!prop) {
        setTxt('pd-new-range', '-');
        setTxt('pd-new-count', '0');
        setTxt('pd-new-per-epoch', '$0');
        setTxt('pd-new-total', '$0');
        setTxt('pd-new-pools', '0');
        return;
    }
    
    let epochCount = prop.end_epoch - prop.start_epoch + 1;
    let perEpoch = prop.bribes.reduce((sum, b) => sum + b.usd_per_epoch, 0);
    
    setTxt('pd-new-range', prop.epoch_range);
    setTxt('pd-new-count', epochCount);
    setTxt('pd-new-per-epoch', fmt$(perEpoch));
    setTxt('pd-new-total', fmt$(perEpoch * epochCount));
    setTxt('pd-new-pools', prop.bribes.length);
}

function updatePdCoverage() {
    // Get current epoch from meta (or use a reasonable default)
    let currentEpoch = store.meta.ep || 161;
    setTxt('pd-current-epoch', currentEpoch);
    
    // Find all covered epochs
    let coveredEpochs = new Set();
    let coveringRange = null;
    store.pdBribesHistory.forEach(prop => {
        for (let e = prop.start_epoch; e <= prop.end_epoch; e++) {
            coveredEpochs.add(e);
            if (e === currentEpoch) {
                coveringRange = prop;
            }
        }
    });
    
    // Find range
    let minEpoch = Math.min(...coveredEpochs) || 0;
    let maxEpoch = Math.max(...coveredEpochs) || 0;
    
    if (coveredEpochs.size > 0) {
        setTxt('pd-covered-range', `${minEpoch} - ${maxEpoch}`);
    } else {
        setTxt('pd-covered-range', '-');
    }
    
    // Check if current epoch is covered
    let isCovered = coveredEpochs.has(currentEpoch);
    let light = $('pd-coverage-light');
    let alertBox = $('pd-alert-box');
    let successBox = $('pd-success-box');
    let bribesSection = $('pd-current-bribes-section');
    
    if (isCovered && coveringRange) {
        light.className = 'w-4 h-4 rounded-full bg-green-500 border-2 border-green-400 shadow-lg shadow-green-500/50';
        setTxt('pd-missing-epochs', 'None');
        
        // Show success box
        if (alertBox) alertBox.classList.add('hidden');
        if (successBox) {
            successBox.classList.remove('hidden');
            setTxt('pd-success-epoch', currentEpoch);
            setTxt('pd-success-range', coveringRange.epoch_range);
            let totalBribes = coveringRange.bribes.reduce((s, b) => s + (b.usd_per_epoch || 0), 0);
            setTxt('pd-success-bribes', '$' + totalBribes.toLocaleString());
        }
        
        // Show current epoch bribes preview
        if (bribesSection) {
            bribesSection.classList.remove('hidden');
            renderCurrentEpochBribes(coveringRange, currentEpoch);
        }
    } else {
        light.className = 'w-4 h-4 rounded-full bg-red-500 border-2 border-red-400 shadow-lg shadow-red-500/50 animate-pulse';
        
        // Find missing epochs between min and current
        let missing = [];
        for (let e = minEpoch; e <= currentEpoch; e++) {
            if (!coveredEpochs.has(e)) missing.push(e);
        }
        setTxt('pd-missing-epochs', missing.length > 5 ? `${missing.slice(0,5).join(', ')}... (+${missing.length - 5})` : missing.join(', ') || currentEpoch.toString());
        
        // Show alert box
        if (successBox) successBox.classList.add('hidden');
        if (bribesSection) bribesSection.classList.add('hidden');
        if (alertBox) {
            alertBox.classList.remove('hidden');
            setTxt('pd-alert-epoch', currentEpoch);
            setTxt('pd-alert-epoch2', currentEpoch);
            // Suggest a range like [160-163]
            let suggestedStart = Math.floor(currentEpoch / 4) * 4;
            let suggestedEnd = suggestedStart + 3;
            setTxt('pd-alert-range', `${suggestedStart}-${suggestedEnd}`);
        }
    }
    
    // Update summary stats
    setTxt('pd-props-count', store.pdBribesHistory.length);
    setTxt('pd-total-epochs', coveredEpochs.size);
    
    let totalBribes = 0;
    store.pdBribesHistory.forEach(prop => {
        let epochCount = prop.end_epoch - prop.start_epoch + 1;
        let perEpoch = prop.bribes.reduce((sum, b) => sum + b.usd_per_epoch, 0);
        totalBribes += perEpoch * epochCount;
    });
    setTxt('pd-total-bribes', fmt$(totalBribes));
    
    // Update workflow status
    updateWorkflowStatus();
}

function renderCurrentEpochBribes(range, epoch) {
    const container = $('pd-current-bribes-grid');
    if (!container) return;
    
    // Get current LUNA price from Prices tab
    const lunaPrice = store.tokenPrices.LUNA?.price || 0;
    setTxt('pd-preview-epoch', `Epoch ${epoch}`);
    setTxt('pd-preview-luna-price', lunaPrice > 0 ? '$' + lunaPrice.toFixed(4) : '$-- (fetch prices first)');
    
    // Group bribes by gauge
    const gauges = {};
    range.bribes.forEach(bribe => {
        const gauge = bribe.gauge || 'unknown';
        if (!gauges[gauge]) gauges[gauge] = [];
        gauges[gauge].push(bribe);
    });
    
    let html = '';
    const gaugeColors = {
        'project': 'text-purple-400 border-purple-900/50 bg-purple-900/10',
        'bluechip': 'text-blue-400 border-blue-900/50 bg-blue-900/10',
        'single': 'text-green-400 border-green-900/50 bg-green-900/10',
        'stable': 'text-yellow-400 border-yellow-900/50 bg-yellow-900/10'
    };
    
    Object.entries(gauges).forEach(([gauge, bribes]) => {
        const colorClass = gaugeColors[gauge] || 'text-gray-400 border-gray-800 bg-gray-900/10';
        
        // Calculate gauge total
        const gaugeTotal = bribes.reduce((s, b) => s + (b.usd_per_epoch || 0), 0);
        const gaugeLuna = bribes.reduce((s, b) => s + (b.luna_per_epoch || 0), 0);
        
        html += `
            <div class="rounded border ${colorClass} p-3">
                <div class="flex justify-between items-center mb-2 border-b border-gray-800 pb-2">
                    <span class="font-bold text-[11px] uppercase">${gauge}</span>
                    <span class="text-[10px]">$${gaugeTotal}/ep | ${gaugeLuna.toFixed(0)} LUNA</span>
                </div>
                <div class="space-y-1">
        `;
        
        bribes.forEach(bribe => {
            const originalUsd = bribe.usd_per_epoch || 0;
            const lunaAmount = bribe.luna_per_epoch || 0;
            
            // Calculate original LUNA price when bribe was posted
            const originalLunaPrice = lunaAmount > 0 ? originalUsd / lunaAmount : 0;
            
            // Calculate current value
            const currentValue = lunaPrice > 0 && lunaAmount > 0 ? lunaAmount * lunaPrice : 0;
            
            // Calculate change
            let changeHtml = '';
            if (currentValue > 0 && originalUsd > 0) {
                const pctChange = ((currentValue - originalUsd) / originalUsd) * 100;
                const changeColor = pctChange >= 0 ? 'text-green-400' : 'text-red-400';
                const arrow = pctChange >= 0 ? '‚Üë' : '‚Üì';
                changeHtml = `<span class="${changeColor} text-[9px]">${arrow} ${Math.abs(pctChange).toFixed(1)}%</span>`;
            }
            
            html += `
                <div class="flex items-center justify-between text-[10px] py-1 border-b border-gray-800/50 last:border-0">
                    <div class="flex items-center gap-2">
                        <span class="text-white font-mono">${bribe.pool}</span>
                        <span class="text-gray-500">(${bribe.percent}%)</span>
                    </div>
                    <div class="flex items-center gap-3 text-right">
                        <div class="text-gray-400">
                            <span class="text-yellow-400">$${originalUsd}</span>
                            <span class="text-gray-600 mx-1">=</span>
                            <span class="text-cyan-400">${lunaAmount.toFixed(0)} LUNA</span>
                        </div>
                        ${currentValue > 0 ? `
                            <div class="text-gray-600">‚Üí</div>
                            <div>
                                <span class="text-green-400 font-bold">$${currentValue.toFixed(0)}</span>
                                ${changeHtml}
                            </div>
                        ` : ''}
                    </div>
                </div>
            `;
        });
        
        html += `
                </div>
            </div>
        `;
    });
    
    container.innerHTML = html;
}

function confirmPdBribesComplete() {
    store.pdBribesVerified = true;
    updateWorkflowStatus();
}

function renderPdBribesHistory() {
    let html = '';
    
    if (store.pdBribesHistory.length === 0) {
        html = '<div class="text-gray-600 text-[10px] italic text-center py-8">No props loaded. Fetch from GitHub or paste JSON.</div>';
        setHtml('pd-history', html);
        return;
    }
    
    // Render each prop as a collapsible card
    store.pdBribesHistory.forEach((prop, idx) => {
        let epochCount = prop.end_epoch - prop.start_epoch + 1;
        let perEpoch = prop.bribes.reduce((sum, b) => sum + b.usd_per_epoch, 0);
        let total = perEpoch * epochCount;
        
        // Group bribes by gauge
        let byGauge = {};
        prop.bribes.forEach(b => {
            if (!byGauge[b.gauge]) byGauge[b.gauge] = [];
            byGauge[b.gauge].push(b);
        });
        
        html += `<div class="bg-[#161616] border border-gray-800 rounded overflow-hidden">
            <div class="flex justify-between items-center px-3 py-2 bg-gray-900/50 cursor-pointer hover:bg-gray-800/50" onclick="togglePropDetails(${idx})">
                <div class="flex items-center gap-3">
                    <span class="text-orange-400 font-bold text-[11px]">${prop.epoch_range}</span>
                    <span class="text-gray-500 text-[9px]">${epochCount} epochs</span>
                    <span class="text-gray-500 text-[9px]">${prop.bribes.length} pools</span>
                </div>
                <div class="flex items-center gap-3">
                    <span class="text-green-400 font-mono text-[10px]">${fmt$(perEpoch)}/ep</span>
                    <span class="text-green-400 font-mono text-[10px] font-bold">${fmt$(total)} total</span>
                    <button onclick="event.stopPropagation(); removeProp(${idx})" class="text-red-400 hover:text-red-300 text-[10px] ml-2">‚úï</button>
                </div>
            </div>
            <div id="prop-details-${idx}" class="hidden px-3 py-2 space-y-1 text-[9px]">`;
        
        // Render gauges
        Object.entries(byGauge).forEach(([gauge, bribes]) => {
            let gaugeColor = gauge === 'stable' ? 'blue' : gauge === 'project' ? 'purple' : gauge === 'bluechip' ? 'yellow' : 'green';
            let gaugeTotal = bribes.reduce((sum, b) => sum + b.usd_per_epoch, 0);
            
            html += `<div class="bg-${gaugeColor}-900/20 border-l-2 border-${gaugeColor}-500 px-2 py-1">
                <div class="flex justify-between text-${gaugeColor}-400 font-bold uppercase">${gauge} <span class="font-mono">${fmt$(gaugeTotal)}/ep</span></div>`;
            
            bribes.forEach(b => {
                html += `<div class="flex justify-between text-gray-400 pl-2">
                    <span class="text-white">${b.pool}</span>
                    <span>${b.percent.toFixed(1)}% | ${fmt$(b.usd_per_epoch)} | ${b.luna_per_epoch.toLocaleString(undefined,{maximumFractionDigits:0})} LUNA</span>
                </div>`;
            });
            
            html += `</div>`;
        });
        
        html += `</div></div>`;
    });
    
    setHtml('pd-history', html);
    updatePdCoverage();
}

function togglePropDetails(idx) {
    let el = $(`prop-details-${idx}`);
    if (el) el.classList.toggle('hidden');
}

function removeProp(idx) {
    if (confirm(`Remove prop ${store.pdBribesHistory[idx].epoch_range}?`)) {
        store.pdBribesHistory.splice(idx, 1);
        renderPdBribesHistory();
    }
}

function clearAllPdBribes() {
    if (confirm('Clear all loaded props?')) {
        store.pdBribesHistory = [];
        store.pdNewProp = null;
        renderPdBribesHistory();
        updatePdCoverage();
        updateNewPropPreview();
        pasteStatus.pd = false;
        updatePasteStatus('ps-pd', false);
    }
}

function exportPdBribesJson() {
    if (store.pdBribesHistory.length === 0) {
        alert('No props to export');
        return;
    }
    
    let json = JSON.stringify(store.pdBribesHistory, null, 2);
    let blob = new Blob([json], { type: 'application/json' });
    let url = URL.createObjectURL(blob);
    let a = document.createElement('a');
    a.href = url;
    a.download = 'tla_pd_bribes.json';
    a.click();
    URL.revokeObjectURL(url);
}

function copyPdBribesJson() {
    if (store.pdBribesHistory.length === 0) {
        alert('No props to copy');
        return;
    }
    
    let json = JSON.stringify(store.pdBribesHistory, null, 2);
    navigator.clipboard.writeText(json).then(() => {
        alert('Copied tla_pd_bribes.json to clipboard!\n\n' + store.pdBribesHistory.length + ' bribe ranges ready to paste into GitHub.');
    }).catch(e => {
        console.error('Copy failed:', e);
        alert('Copy failed. Try using Download instead.');
    });
}

// ============ ASTROPORT FUNCTIONS ============

// Convert timestamp to epoch number
function timestampToEpoch(ts) {
    // ts is in seconds, anchor is Nov 17, 2025 = Epoch 160
    let anchorTs = EPOCH_ANCHOR_DATE.getTime() / 1000;
    let diffWeeks = Math.floor((ts - anchorTs) / SECONDS_PER_WEEK);
    return EPOCH_ANCHOR_NUM + diffWeeks;
}

// Get epoch start/end timestamps
function getEpochRange(epochNum) {
    let anchorTs = EPOCH_ANCHOR_DATE.getTime() / 1000;
    let weeksDiff = epochNum - EPOCH_ANCHOR_NUM;
    let startTs = anchorTs + (weeksDiff * SECONDS_PER_WEEK);
    let endTs = startTs + SECONDS_PER_WEEK;
    return { start: startTs, end: endTs };
}

// Format timestamp to date string
function formatDate(ts) {
    let d = new Date(ts * 1000);
    return d.toISOString().split('T')[0];
}

// Update Astroport tab based on mode
function updateAstroTab() {
    if (store.mode === 'staging') {
        $('astro-staging-mode').classList.remove('hidden');
        $('astro-normal-mode').classList.add('hidden');
        updateStagingDisplay();
    } else {
        $('astro-staging-mode').classList.add('hidden');
        $('astro-normal-mode').classList.remove('hidden');
        updateNormalDisplay();
    }
    updateAstroLpDropdown();
}

function updateAstroStatus() {
    updateAstroTab();
}

// ============ LP DROPDOWN ============

function updateAstroLpDropdown() {
    // Filter for Astroport LPs only
    let astroLps = Object.entries(store.lpRegistry)
        .filter(([key, lp]) => lp.dex === 'Astroport');
    
    // Sort by bucket order, then A-Z within bucket
    const BUCKET_ORDER = ['stable', 'project', 'bluechip', 'single'];
    astroLps.sort((a, b) => {
        let bucketA = BUCKET_ORDER.indexOf(a[1].bucket);
        let bucketB = BUCKET_ORDER.indexOf(b[1].bucket);
        if (bucketA === -1) bucketA = 99;
        if (bucketB === -1) bucketB = 99;
        if (bucketA !== bucketB) return bucketA - bucketB;
        // A-Z within bucket
        return a[1].lp.localeCompare(b[1].lp);
    });
    
    let html = '<option value="">-- Select LP --</option>';
    
    // Group by bucket
    let currentBucket = null;
    astroLps.forEach(([key, lp]) => {
        // Start new optgroup for each bucket
        if (lp.bucket !== currentBucket) {
            if (currentBucket !== null) html += '</optgroup>';
            let bucketLabel = lp.bucket.charAt(0).toUpperCase() + lp.bucket.slice(1);
            html += `<optgroup label="${bucketLabel}">`;
            currentBucket = lp.bucket;
        }
        
        let status = getStagingLpStatus(key);
        let icon = status.notAvailable ? '‚õî' :
                   status.isComplete ? 'üü¢' : 
                   status.daysCaptured.length > 0 ? 'üü°' : 
                   lp.active ? '‚ö™' : '‚¨ú';
        let rangeLabel = status.range !== 180 ? ` [${status.range}d]` : '';
        let naLabel = status.notAvailable ? ' (N/A)' : '';
        html += `<option value="${key}">${icon} ${lp.lp} (${lp.vote_pct.toFixed(1)}%)${rangeLabel}${naLabel}</option>`;
    });
    
    if (currentBucket !== null) html += '</optgroup>';
    
    // Update both dropdowns
    if ($('astro-lp-select')) setHtml('astro-lp-select', html);
    if ($('astro-lp-select-normal')) setHtml('astro-lp-select-normal', html);
}

function getStagingLpStatus(lpKey) {
    // Check ALL staging days for this LP
    let daysCaptured = [];
    let range = 180; // default
    let hasLiq = false;
    let hasVol = false;
    let notAvailable = false;
    
    ['day1', 'day2', 'day3', 'day4'].forEach((day, idx) => {
        let dayData = store.staging[day];
        if (dayData && dayData.lps && dayData.lps[lpKey]) {
            let lp = dayData.lps[lpKey];
            if (lp.range) range = lp.range;
            if (lp.notAvailable) notAvailable = true;
            if (lp.liquidity?.length > 0 || lp.volume?.length > 0) {
                daysCaptured.push(idx + 1);
            }
            if (lp.liquidity?.length > 0) hasLiq = true;
            if (lp.volume?.length > 0) hasVol = true;
        }
    });
    
    // Days needed based on range
    let daysNeeded = range === 180 ? 4 : range === 90 ? 2 : 1;
    let isComplete = (daysCaptured.length >= daysNeeded && hasLiq && hasVol) || notAvailable;
    
    return {
        liq: hasLiq,
        vol: hasVol,
        range: range,
        daysCaptured: daysCaptured,
        daysNeeded: daysNeeded,
        isComplete: isComplete,
        notAvailable: notAvailable
    };
}

function updateSelectedLp() {
    let lpKey = $('astro-lp-select').value;
    if (!lpKey) {
        setTxt('astro-lp-liq-status', '-');
        setTxt('astro-lp-vol-status', '-');
        setTxt('astro-lp-days-status', '-');
        return;
    }
    
    let status = getStagingLpStatus(lpKey);
    
    // Update range dropdown to match stored range
    if ($('astro-data-range')) {
        $('astro-data-range').value = status.range.toString();
    }
    
    // Check if marked as not available
    if (status.notAvailable) {
        setTxt('astro-lp-liq-status', '‚õî N/A');
        $('astro-lp-liq-status').className = 'text-yellow-400';
        setTxt('astro-lp-vol-status', '‚õî N/A');
        $('astro-lp-vol-status').className = 'text-yellow-400';
        setTxt('astro-lp-days-status', 'Marked unavailable');
        $('astro-lp-days-status').className = 'text-yellow-400';
        return;
    }
    
    // Current day status
    let currentDay = $('staging-current-day')?.value || 'day1';
    let dayData = store.staging[currentDay];
    let currentDayLiq = dayData?.lps?.[lpKey]?.liquidity?.length || 0;
    let currentDayVol = dayData?.lps?.[lpKey]?.volume?.length || 0;
    
    if (currentDayLiq > 0) {
        setTxt('astro-lp-liq-status', `‚úì ${currentDayLiq} pts`);
        $('astro-lp-liq-status').className = 'text-green-400';
    } else {
        setTxt('astro-lp-liq-status', 'Not captured');
        $('astro-lp-liq-status').className = 'text-gray-600';
    }
    
    if (currentDayVol > 0) {
        setTxt('astro-lp-vol-status', `‚úì ${currentDayVol} pts`);
        $('astro-lp-vol-status').className = 'text-green-400';
    } else {
        setTxt('astro-lp-vol-status', 'Not captured');
        $('astro-lp-vol-status').className = 'text-gray-600';
    }
    
    // Days status
    let daysStr = status.daysCaptured.length > 0 ? status.daysCaptured.join(',') : 'none';
    let daysClass = status.isComplete ? 'text-green-400' : 
                    status.daysCaptured.length > 0 ? 'text-yellow-400' : 'text-gray-600';
    setTxt('astro-lp-days-status', `${daysStr} / ${status.daysNeeded} needed`);
    $('astro-lp-days-status').className = daysClass;
}

// ============ STAGING MODE ============

function updateStagingDay() {
    updateSelectedLp();
    renderStagingLpGrid();
}

function updateStagingDisplay() {
    // Use new staging system
    updateStagingProgress();
    renderStagingLpGrid();
    initStagingLpDropdown();
}

function detectDataRange(series) {
    // Check interval between first few points to determine range
    if (!series || series.length < 3) return 180; // default
    
    // Calculate average interval from first 5 points
    let intervals = [];
    for (let i = 1; i < Math.min(5, series.length); i++) {
        let diff = series[i].time - series[i-1].time;
        intervals.push(diff);
    }
    
    let avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
    let avgDays = avgInterval / 86400; // convert to days
    
    // Determine range based on interval
    // 180d = ~4 day intervals (345600 sec)
    // 90d = ~2 day intervals (172800 sec)
    // 30d = ~1 day intervals (86400 sec)
    
    if (avgDays >= 3) return 180;      // 3-4+ day intervals = 180d
    if (avgDays >= 1.5) return 90;     // 1.5-3 day intervals = 90d
    return 30;                          // <1.5 day intervals = 30d
}

// ============ 4-DAY STAGING SYSTEM ============

// Epoch calculation helpers
const STAGING_E165_END = new Date('2025-12-28T12:00:00Z').getTime() / 1000;
const STAGING_EPOCH_DURATION = 7 * 24 * 60 * 60;

function stagingGetEpoch(ts) {
    let diff = STAGING_E165_END - ts;
    let epochsBack = Math.floor(diff / STAGING_EPOCH_DURATION);
    return 165 - epochsBack;
}

function stagingGetEpochRange(epoch) {
    let endTs = STAGING_E165_END + (epoch - 165) * STAGING_EPOCH_DURATION;
    let startTs = endTs - STAGING_EPOCH_DURATION;
    return {
        start: new Date(startTs * 1000).toISOString().split('T')[0],
        end: new Date(endTs * 1000).toISOString().split('T')[0],
        startTs: startTs,
        endTs: endTs
    };
}

// Fetch all staging days from GitHub
async function fetchAllStagingDays() {
    setTxt('staging-fetch-status', 'Fetching...');
    let loaded = 0;
    
    for (let day of ['day1', 'day2', 'day3', 'day4']) {
        try {
            let resp = await fetch(STAGING_URLS[day] + '?t=' + Date.now());
            if (resp.ok) {
                let data = await resp.json();
                if (data && data.lps) {
                    store.staging[day] = data;
                    loaded++;
                }
            }
        } catch(e) {
            console.log(`No ${day} staging file yet`);
        }
    }
    
    setTxt('staging-fetch-status', `Loaded ${loaded}/4 days`);
    updateStagingDayCards();
    updateStagingDisplay();
}

// Update the 4 day cards at top
function updateStagingDayCards() {
    ['day1', 'day2', 'day3', 'day4'].forEach(day => {
        let dayData = store.staging[day];
        let card = $(`staging-${day}-card`);
        let statusEl = $(`staging-${day}-status`);
        let lpsEl = $(`staging-${day}-lps`);
        let dateEl = $(`staging-${day}-date`);
        
        if (dayData && dayData.lps && Object.keys(dayData.lps).length > 0) {
            let lpCount = Object.keys(dayData.lps).length;
            statusEl.textContent = '‚úì Loaded';
            statusEl.className = 'text-[9px] text-green-400';
            lpsEl.textContent = `${lpCount} LPs`;
            lpsEl.className = 'text-lg font-bold text-green-400';
            dateEl.textContent = dayData.captureDate || '-';
            card.className = 'bg-green-900/20 rounded p-3 border-2 border-green-700 cursor-pointer hover:border-green-500';
        } else {
            statusEl.textContent = 'Not loaded';
            statusEl.className = 'text-[9px] text-gray-600';
            lpsEl.textContent = '0 LPs';
            lpsEl.className = 'text-lg font-bold text-gray-600';
            dateEl.textContent = '-';
            card.className = 'bg-[#0D0D0D] rounded p-3 border-2 border-gray-800 cursor-pointer hover:border-gray-600';
        }
    });
    
    // Highlight current day
    let currentDay = store.staging.currentDay || 'day1';
    let currentCard = $(`staging-${currentDay}-card`);
    if (currentCard) {
        currentCard.classList.add('ring-2', 'ring-yellow-400');
    }
}

// Select a staging day
function selectStagingDay(day) {
    store.staging.currentDay = day;
    $('staging-current-day').value = day;
    onStagingDayChange();
}

// Handle day change
function onStagingDayChange() {
    store.staging.currentDay = $('staging-current-day').value;
    setTxt('staging-day-label', store.staging.currentDay.replace('day', 'Day '));
    
    // Update all displays
    updateStagingDayCards();
    renderStagingLpGrid();
    initStagingLpDropdown();
    
    // Reset LP selection
    $('staging-lp-select').value = '';
    onStagingLpSelect();
}

// Get comprehensive LP status across all days
function getStagingLpStatusAllDays(lpKey) {
    let daysCaptured = [];
    let totalLiqPoints = 0;
    let totalVolPoints = 0;
    let liqUnavailable = false;
    let volUnavailable = false;
    
    ['day1', 'day2', 'day3', 'day4'].forEach((day, idx) => {
        let dayData = store.staging[day];
        if (dayData?.lps?.[lpKey]) {
            let lpData = dayData.lps[lpKey];
            
            // Check for new separate flags first, fall back to old notAvailable
            let dayLiqUnavail = lpData.liqUnavailable ?? lpData.notAvailable ?? false;
            let dayVolUnavail = lpData.volUnavailable ?? lpData.notAvailable ?? false;
            
            if (dayLiqUnavail) liqUnavailable = true;
            if (dayVolUnavail) volUnavailable = true;
            
            // Count as captured if has data OR is marked unavailable
            let hasData = lpData.liquidity?.length > 0 || lpData.volume?.length > 0;
            let isUnavailable = dayLiqUnavail && dayVolUnavail;
            
            if (hasData || isUnavailable) {
                daysCaptured.push(idx + 1);
            }
            
            totalLiqPoints += lpData.liquidity?.length || 0;
            totalVolPoints += lpData.volume?.length || 0;
        }
    });
    
    // Complete if all 4 days captured OR if both liq and vol are marked unavailable
    let bothUnavailable = liqUnavailable && volUnavailable;
    
    return {
        daysCaptured,
        daysNeeded: 4,
        isComplete: daysCaptured.length >= 4 || bothUnavailable,
        totalLiqPoints,
        totalVolPoints,
        liqUnavailable,
        volUnavailable,
        notAvailable: bothUnavailable  // Keep for backward compatibility
    };
}

// Get status for current day only
function getStagingLpStatusNew(lpKey) {
    let currentDay = store.staging.currentDay || 'day1';
    let dayData = store.staging[currentDay];
    let lpData = dayData?.lps?.[lpKey];
    
    let allDaysStatus = getStagingLpStatusAllDays(lpKey);
    
    // Check for new separate flags first, fall back to old notAvailable
    let liqUnavail = lpData?.liqUnavailable ?? lpData?.notAvailable ?? false;
    let volUnavail = lpData?.volUnavailable ?? lpData?.notAvailable ?? false;
    
    return {
        captured: lpData && (lpData.liquidity?.length > 0 || lpData.volume?.length > 0 || liqUnavail || volUnavail),
        verified: allDaysStatus.isComplete,
        hasLiq: lpData?.liquidity?.length > 0,
        hasVol: lpData?.volume?.length > 0,
        liqUnavail: liqUnavail,
        volUnavail: volUnavail,
        liqPoints: lpData?.liquidity?.length || 0,
        volPoints: lpData?.volume?.length || 0,
        ...allDaysStatus
    };
}

// Initialize staging LP dropdown
function initStagingLpDropdown() {
    let select = $('staging-lp-select');
    if (!select) return;
    
    let currentValue = select.value;
    let currentDay = store.staging.currentDay || 'day1';
    
    // Get Astroport LPs from registry
    let astroLps = Object.entries(store.lpRegistry)
        .filter(([k, v]) => v.dex === 'Astroport');
    
    // Group by bucket, then sort by vote_pct within bucket
    const BUCKET_ORDER = ['stable', 'project', 'bluechip', 'single'];
    const BUCKET_LABELS = {
        'stable': 'üîµ STABLE',
        'project': 'üü£ PROJECT', 
        'bluechip': 'üü° BLUECHIP',
        'single': 'üü¢ SINGLE'
    };
    
    // Sort by bucket order first, then by not-captured, then by vote_pct
    astroLps.sort((a, b) => {
        let bucketA = BUCKET_ORDER.indexOf(a[1].bucket || 'single');
        let bucketB = BUCKET_ORDER.indexOf(b[1].bucket || 'single');
        if (bucketA === -1) bucketA = 999;
        if (bucketB === -1) bucketB = 999;
        
        if (bucketA !== bucketB) return bucketA - bucketB;
        
        // Within same bucket: not captured first
        let statusA = getStagingLpStatusNew(a[0]);
        let statusB = getStagingLpStatusNew(b[0]);
        let priorityA = statusA.captured ? 1 : 0;
        let priorityB = statusB.captured ? 1 : 0;
        
        if (priorityA !== priorityB) return priorityA - priorityB;
        
        // Then by vote_pct descending
        return b[1].vote_pct - a[1].vote_pct;
    });
    
    // Count stats for current day
    let pendingToday = 0;
    let capturedToday = 0;
    
    astroLps.forEach(([key, lp]) => {
        let status = getStagingLpStatusNew(key);
        if (status.captured) capturedToday++;
        else pendingToday++;
    });
    
    select.innerHTML = `<option value="">-- ${currentDay.replace('day', 'Day ')}: ${pendingToday} pending, ${capturedToday} done --</option>`;
    
    // Add optgroups by bucket
    let currentBucket = null;
    
    astroLps.forEach(([key, lp]) => {
        let bucket = lp.bucket || 'single';
        let status = getStagingLpStatusNew(key);
        
        if (bucket !== currentBucket) {
            if (currentBucket !== null) select.innerHTML += '</optgroup>';
            
            // Count pending in this bucket
            let bucketLps = astroLps.filter(([k, v]) => (v.bucket || 'single') === bucket);
            let bucketPending = bucketLps.filter(([k]) => !getStagingLpStatusNew(k).captured).length;
            let bucketTotal = bucketLps.length;
            
            let groupLabel = `${BUCKET_LABELS[bucket] || bucket.toUpperCase()} (${bucketPending}/${bucketTotal} pending)`;
            select.innerHTML += `<optgroup label="${groupLabel}">`;
            currentBucket = bucket;
        }
        
        // Status indicators
        let todayIcon = status.captured ? '‚úÖ' : '‚è≥';
        let allDaysStatus = status.isComplete ? 'üü¢' : `${status.daysCaptured.length}/4`;
        
        // Show unavailable indicator
        let unavailIcon = '';
        if (status.liqUnavail && status.volUnavail) unavailIcon = ' ‚õî';
        else if (status.volUnavail) unavailIcon = ' üìä‚õî';
        else if (status.liqUnavail) unavailIcon = ' üíß‚õî';
        
        select.innerHTML += `<option value="${key}">${todayIcon} ${lp.lp} [${allDaysStatus}]${unavailIcon}</option>`;
    });
    
    if (currentBucket !== null) select.innerHTML += '</optgroup>';
    
    if (currentValue) select.value = currentValue;
    
    // Update counters
    setTxt('staging-day-complete', capturedToday);
    setTxt('staging-day-total', astroLps.length);
}

// Handle LP selection
function onStagingLpSelect() {
    let lpKey = $('staging-lp-select').value;
    
    // Clear paste areas
    $('stagingLiqPaste').value = '';
    $('stagingVolPaste').value = '';
    $('stagingLiqPaste').disabled = false;
    $('stagingVolPaste').disabled = false;
    if ($('staging-liq-unavailable')) $('staging-liq-unavailable').checked = false;
    if ($('staging-vol-unavailable')) $('staging-vol-unavailable').checked = false;
    
    // Reset status
    setTxt('staging-liq-paste-status', 'Empty');
    setTxt('staging-vol-paste-status', 'Empty');
    setTxt('staging-liq-preview', '-');
    setTxt('staging-vol-preview', '-');
    $('staging-liq-paste-status').className = 'text-[8px] text-gray-600';
    $('staging-vol-paste-status').className = 'text-[8px] text-gray-600';
    
    // Hide verification panel
    $('staging-verification-panel').classList.add('hidden');
    
    if (!lpKey) {
        setTxt('staging-lp-days', '0/4');
        setTxt('staging-lp-liq-points', '0');
        setTxt('staging-lp-vol-points', '0');
        setTxt('staging-lp-thisday', 'Select an LP');
        updateStagingCaptureButton();
        return;
    }
    
    // Show LP status
    let status = getStagingLpStatusNew(lpKey);
    
    setTxt('staging-lp-days', `${status.daysCaptured.length}/4`);
    $('staging-lp-days').className = status.isComplete ? 'text-green-400' : 
                                     status.daysCaptured.length > 0 ? 'text-yellow-400' : 'text-gray-600';
    
    setTxt('staging-lp-liq-points', status.totalLiqPoints);
    setTxt('staging-lp-vol-points', status.totalVolPoints);
    
    let currentDay = store.staging.currentDay || 'day1';
    let dayNum = parseInt(currentDay.replace('day', ''));
    if (status.daysCaptured.includes(dayNum)) {
        setTxt('staging-lp-thisday', `‚úì ${status.liqPoints}L/${status.volPoints}V pts`);
        $('staging-lp-thisday').className = 'text-green-400';
    } else {
        setTxt('staging-lp-thisday', 'Not captured');
        $('staging-lp-thisday').className = 'text-gray-600';
    }
    
    updateStagingCaptureButton();
}

// Handle unavailable checkbox
function onStagingUnavailableChange(type) {
    let checkbox = $(type === 'liq' ? 'staging-liq-unavailable' : 'staging-vol-unavailable');
    let textarea = $(type === 'liq' ? 'stagingLiqPaste' : 'stagingVolPaste');
    let statusEl = type === 'liq' ? 'staging-liq-paste-status' : 'staging-vol-paste-status';
    
    if (checkbox.checked) {
        textarea.disabled = true;
        textarea.value = '';
        setTxt(statusEl, '‚ö† Unavailable');
        $(statusEl).className = 'text-[8px] text-red-400';
    } else {
        textarea.disabled = false;
        setTxt(statusEl, 'Empty');
        $(statusEl).className = 'text-[8px] text-gray-600';
    }
    
    updateStagingCaptureButton();
}

// Validate liquidity paste
function validateStagingLiqPaste() {
    let txt = $('stagingLiqPaste').value.trim();
    if (!txt) {
        setTxt('staging-liq-paste-status', 'Empty');
        setTxt('staging-liq-preview', '-');
        $('staging-liq-paste-status').className = 'text-[8px] text-gray-600';
        updateStagingCaptureButton();
        return null;
    }
    
    try {
        let json = JSON.parse(txt);
        let series = json?.result?.data?.json?.[0]?.series;
        if (series && Array.isArray(series) && series.length > 0) {
            let firstDate = new Date(series[0].time * 1000).toISOString().split('T')[0];
            let lastDate = new Date(series[series.length-1].time * 1000).toISOString().split('T')[0];
            setTxt('staging-liq-paste-status', '‚úì Valid');
            setTxt('staging-liq-preview', `${series.length} pts: ${firstDate} ‚Üí ${lastDate}`);
            $('staging-liq-paste-status').className = 'text-[8px] text-green-400';
            updateStagingCaptureButton();
            return series;
        } else {
            throw new Error('No series data');
        }
    } catch(e) {
        setTxt('staging-liq-paste-status', '‚úó Invalid');
        setTxt('staging-liq-preview', e.message);
        $('staging-liq-paste-status').className = 'text-[8px] text-red-400';
        updateStagingCaptureButton();
        return null;
    }
}

// Validate volume paste
function validateStagingVolPaste() {
    let txt = $('stagingVolPaste').value.trim();
    if (!txt) {
        setTxt('staging-vol-paste-status', 'Empty');
        setTxt('staging-vol-preview', '-');
        $('staging-vol-paste-status').className = 'text-[8px] text-gray-600';
        updateStagingCaptureButton();
        return null;
    }
    
    try {
        let json = JSON.parse(txt);
        let series = json?.result?.data?.json?.[0]?.series;
        if (series && Array.isArray(series) && series.length > 0) {
            let firstDate = new Date(series[0].time * 1000).toISOString().split('T')[0];
            let lastDate = new Date(series[series.length-1].time * 1000).toISOString().split('T')[0];
            setTxt('staging-vol-paste-status', '‚úì Valid');
            setTxt('staging-vol-preview', `${series.length} pts: ${firstDate} ‚Üí ${lastDate}`);
            $('staging-vol-paste-status').className = 'text-[8px] text-green-400';
            updateStagingCaptureButton();
            return series;
        } else {
            throw new Error('No series data');
        }
    } catch(e) {
        setTxt('staging-vol-paste-status', '‚úó Invalid');
        setTxt('staging-vol-preview', e.message);
        $('staging-vol-paste-status').className = 'text-[8px] text-red-400';
        updateStagingCaptureButton();
        return null;
    }
}

// Update capture button state
function updateStagingCaptureButton() {
    let lpKey = $('staging-lp-select').value;
    let liqValid = $('staging-liq-paste-status').textContent.includes('‚úì');
    let volValid = $('staging-vol-paste-status').textContent.includes('‚úì');
    let liqUnavail = $('staging-liq-unavailable')?.checked || false;
    let volUnavail = $('staging-vol-unavailable')?.checked || false;
    
    let btn = $('staging-capture-btn');
    btn.disabled = !lpKey || !((liqValid || liqUnavail) && (volValid || volUnavail));
}

// Capture data for current day
function captureStagingData() {
    let lpKey = $('staging-lp-select').value;
    let currentDay = store.staging.currentDay || 'day1';
    
    if (!lpKey) {
        alert('Please select an LP');
        return;
    }
    
    let liqUnavail = $('staging-liq-unavailable')?.checked || false;
    let volUnavail = $('staging-vol-unavailable')?.checked || false;
    
    // Initialize day if needed
    if (!store.staging[currentDay]) {
        store.staging[currentDay] = {
            captureDate: new Date().toISOString().split('T')[0],
            lps: {}
        };
    }
    
    // Parse data
    let liqPoints = [];
    let volPoints = [];
    
    if (!liqUnavail) {
        let liqTxt = $('stagingLiqPaste').value.trim();
        if (liqTxt) {
            try {
                let json = JSON.parse(liqTxt);
                let series = json?.result?.data?.json?.[0]?.series;
                if (series) {
                    liqPoints = series.map(p => ({
                        ts: p.time,
                        v: p.value,
                        date: new Date(p.time * 1000).toISOString().split('T')[0]
                    }));
                }
            } catch(e) {
                alert('Failed to parse liquidity: ' + e.message);
                return;
            }
        }
    }
    
    if (!volUnavail) {
        let volTxt = $('stagingVolPaste').value.trim();
        if (volTxt) {
            try {
                let json = JSON.parse(volTxt);
                let series = json?.result?.data?.json?.[0]?.series;
                if (series) {
                    volPoints = series.map(p => ({
                        ts: p.time,
                        v: p.value,
                        date: new Date(p.time * 1000).toISOString().split('T')[0]
                    }));
                }
            } catch(e) {
                alert('Failed to parse volume: ' + e.message);
                return;
            }
        }
    }
    
    // Save to staging
    store.staging[currentDay].lps[lpKey] = {
        liquidity: liqPoints,
        volume: volPoints,
        liqUnavailable: liqUnavail,
        volUnavailable: volUnavail,
        notAvailable: liqUnavail && volUnavail,  // Keep for backward compatibility
        capturedAt: new Date().toISOString()
    };
    
    // Clear paste areas
    $('stagingLiqPaste').value = '';
    $('stagingVolPaste').value = '';
    
    // Update displays
    updateStagingDayCards();
    renderStagingLpGrid();
    initStagingLpDropdown();
    onStagingLpSelect();
    
    let lpName = store.lpRegistry[lpKey]?.lp || lpKey;
    let status = getStagingLpStatusAllDays(lpKey);
    alert(`‚úÖ ${lpName} captured for ${currentDay.replace('day', 'Day ')}!\n\nLiq: ${liqPoints.length} points\nVol: ${volPoints.length} points\n\nAll days: ${status.daysCaptured.length}/4 complete`);
}

// Render LP grid for current day
function renderStagingLpGrid() {
    let astroLps = Object.entries(store.lpRegistry)
        .filter(([k, v]) => v.dex === 'Astroport')
        .sort((a, b) => b[1].vote_pct - a[1].vote_pct);
    
    let html = '';
    
    astroLps.forEach(([key, lp]) => {
        let status = getStagingLpStatusNew(key);
        let allStatus = getStagingLpStatusAllDays(key);
        
        // Color based on today's status
        let bgClass = status.captured ? 'bg-green-900/30 border-green-800' : 'bg-[#1a1a1a] border-gray-800';
        
        // Days indicator
        let daysIndicator = allStatus.daysCaptured.map(d => d).join('') || '-';
        let daysColor = allStatus.isComplete ? 'text-green-400' : 
                       allStatus.daysCaptured.length > 0 ? 'text-yellow-400' : 'text-gray-600';
        
        html += `<div class="p-1 rounded border ${bgClass} text-[8px] cursor-pointer hover:opacity-80" onclick="selectStagingLpFromGrid('${key}')" title="${lp.lp}">
            <div class="text-white font-mono truncate">${lp.lp.substring(0, 12)}</div>
            <div class="flex justify-between">
                <span class="${status.captured ? 'text-green-400' : 'text-gray-600'}">${status.captured ? '‚úì' : '‚óã'}</span>
                <span class="${daysColor}">[${daysIndicator}]</span>
            </div>
        </div>`;
    });
    
    setHtml('staging-lp-grid', html || '<div class="col-span-6 text-gray-600 text-center py-2">Parse LP Registry first</div>');
}

// Select LP from grid
function selectStagingLpFromGrid(lpKey) {
    $('staging-lp-select').value = lpKey;
    onStagingLpSelect();
}

// Export current day
function exportCurrentDay() {
    let currentDay = store.staging.currentDay || 'day1';
    let dayData = store.staging[currentDay];
    
    if (!dayData || !dayData.lps || Object.keys(dayData.lps).length === 0) {
        alert('No data for current day');
        return;
    }
    
    let json = JSON.stringify(dayData, null, 2);
    downloadJson(json, `tla_ext_staging_${currentDay}.json`);
}

// Load staging file
function loadStagingFile() {
    $('staging-file-input').click();
}

function handleStagingFileLoad(event) {
    let file = event.target.files[0];
    if (!file) return;
    
    // Determine which day from filename
    let dayMatch = file.name.match(/day(\d)/i);
    let targetDay = dayMatch ? `day${dayMatch[1]}` : store.staging.currentDay || 'day1';
    
    let reader = new FileReader();
    reader.onload = function(e) {
        try {
            let data = JSON.parse(e.target.result);
            if (data.lps) {
                store.staging[targetDay] = data;
                updateStagingDayCards();
                renderStagingLpGrid();
                initStagingLpDropdown();
                alert(`‚úÖ Loaded ${Object.keys(data.lps).length} LPs into ${targetDay}`);
            } else {
                alert('Invalid staging file format');
            }
        } catch(err) {
            alert('Failed to parse file: ' + err.message);
        }
    };
    reader.readAsText(file);
    event.target.value = '';
}

// Update staging progress (called by updateStagingDisplay)
function updateStagingProgress() {
    updateStagingDayCards();
}

// Generate final historical file from all 4 days
function generateHistoricalFile() {
    // Merge all days
    let allData = {};  // { lpKey: { liquidity: [], volume: [] } }
    
    ['day1', 'day2', 'day3', 'day4'].forEach(day => {
        let dayData = store.staging[day];
        if (!dayData?.lps) return;
        
        Object.entries(dayData.lps).forEach(([lpKey, lpData]) => {
            if (!allData[lpKey]) {
                allData[lpKey] = { liquidity: [], volume: [], notAvailable: lpData.notAvailable };
            }
            if (lpData.liquidity) allData[lpKey].liquidity.push(...lpData.liquidity);
            if (lpData.volume) allData[lpKey].volume.push(...lpData.volume);
        });
    });
    
    // Check how many LPs have all 4 days
    let completeLps = Object.entries(allData).filter(([k, v]) => {
        let status = getStagingLpStatusAllDays(k);
        return status.isComplete;
    });
    
    if (completeLps.length === 0) {
        alert('No LPs have all 4 days captured yet');
        return;
    }
    
    if (!confirm(`Generate historical from ${completeLps.length} complete LPs?\n\nVolume: avg = sum √∑ 7\nLiquidity: avg = sum √∑ recorded days`)) {
        return;
    }
    
    // Build historical file
    let historical = {
        meta: {
            year: new Date().getFullYear(),
            last_updated: new Date().toISOString().split('T')[0],
            generated_from: 'staging_4day',
            lp_count: completeLps.length,
            notes: 'Volume uses sum√∑7 (missing=zero). Liquidity uses sum√∑recorded days.'
        },
        lps: {}
    };
    
    let allEpochs = new Set();
    
    completeLps.forEach(([lpKey, lpData]) => {
        if (lpData.notAvailable) {
            historical.lps[lpKey] = {
                liquidity: { epochs: {}, unavailable: true },
                volume: { epochs: {}, unavailable: true }
            };
            return;
        }
        
        // Dedupe points by timestamp
        let liqSeen = new Set();
        let volSeen = new Set();
        let liqUnique = lpData.liquidity.filter(p => {
            if (liqSeen.has(p.ts)) return false;
            liqSeen.add(p.ts);
            return true;
        });
        let volUnique = lpData.volume.filter(p => {
            if (volSeen.has(p.ts)) return false;
            volSeen.add(p.ts);
            return true;
        });
        
        // Group by epoch
        let liqByEpoch = {};
        let volByEpoch = {};
        
        liqUnique.forEach(p => {
            let ep = stagingGetEpoch(p.ts);
            if (!liqByEpoch[ep]) liqByEpoch[ep] = { sum: 0, days: new Set() };
            liqByEpoch[ep].sum += p.v;
            liqByEpoch[ep].days.add(p.date);
        });
        
        volUnique.forEach(p => {
            let ep = stagingGetEpoch(p.ts);
            if (!volByEpoch[ep]) volByEpoch[ep] = { sum: 0, days: new Set() };
            volByEpoch[ep].sum += p.v;
            volByEpoch[ep].days.add(p.date);
        });
        
        // Calculate averages
        historical.lps[lpKey] = {
            liquidity: { epochs: {} },
            volume: { epochs: {} }
        };
        
        Object.entries(liqByEpoch).forEach(([ep, data]) => {
            allEpochs.add(parseInt(ep));
            let recordedDays = data.days.size;
            historical.lps[lpKey].liquidity.epochs[ep] = {
                avg: Math.round((data.sum / recordedDays) * 100) / 100,
                days: recordedDays,
                complete: true
            };
        });
        
        Object.entries(volByEpoch).forEach(([ep, data]) => {
            allEpochs.add(parseInt(ep));
            let recordedDays = data.days.size;
            // Volume: always divide by 7 (missing days = $0)
            historical.lps[lpKey].volume.epochs[ep] = {
                avg: Math.round((data.sum / 7) * 100) / 100,
                days: recordedDays,
                zero_days: 7 - recordedDays,
                complete: true
            };
        });
    });
    
    // Update meta
    let epochArr = Array.from(allEpochs).sort((a,b) => a-b);
    if (epochArr.length > 0) {
        historical.meta.epoch_range = [epochArr[0], epochArr[epochArr.length - 1]];
    }
    
    downloadJson(JSON.stringify(historical, null, 2), `tla_ext_historical_${new Date().toISOString().split('T')[0]}.json`);
    alert(`‚úÖ Generated historical with ${completeLps.length} LPs, E${epochArr[0]}-E${epochArr[epochArr.length-1]}`);
}

// Legacy compatibility
function captureStagingBoth() {
    captureStagingData();
}

function finalizeStaging() {
    generateHistoricalFile();
}

// ============ NORMAL MODE ============

function updateNormalDisplay() {
    // Historical stats
    if (store.historical.meta) {
        setTxt('hist-epochs', `${store.historical.meta.epoch_start || '-'} - ${store.historical.meta.epoch_end || '-'}`);
        setTxt('hist-lps', store.historical.lps ? Object.keys(store.historical.lps).length : 0);
        setTxt('hist-updated', store.historical.meta.created?.split('T')[0] || '-');
    }
    
    // Current stats
    if (store.current.meta) {
        setTxt('curr-epochs', `${store.current.meta.epoch_start || '-'} - ${store.current.meta.epoch_end || '-'}`);
        setTxt('curr-lps', store.current.lps ? Object.keys(store.current.lps).length : 0);
        setTxt('curr-updated', store.current.meta.last_updated || '-');
    }
    
    // Update historical status (need/archive)
    updateHistoricalStatus();
    
    renderNormalLpGrid();
}

function updateHistoricalStatus() {
    let currentEpoch = store.meta.ep || 161;
    let histStart = store.historical.meta?.epoch_start || 0;
    let histEnd = store.historical.meta?.epoch_end || 0;
    
    // What epochs are needed? (from histEnd+1 to currentEpoch)
    let needEpochs = [];
    if (histEnd > 0 && histEnd < currentEpoch) {
        for (let e = histEnd + 1; e <= currentEpoch; e++) {
            needEpochs.push(e);
        }
    }
    
    // What epochs should be archived? (older than 180 days = ~26 epochs)
    let archiveEpochs = [];
    let archiveCutoff = currentEpoch - 26; // ~180 days
    if (histStart > 0 && histStart < archiveCutoff) {
        for (let e = histStart; e < archiveCutoff; e++) {
            archiveEpochs.push(e);
        }
    }
    
    // Update UI
    let needEl = $('hist-need-epochs');
    let archiveEl = $('hist-archive-epochs');
    
    if (needEl) {
        if (needEpochs.length > 0) {
            needEl.classList.remove('hidden');
            let needStr = needEpochs.length > 5 
                ? `Ep ${needEpochs[0]}-${needEpochs[needEpochs.length-1]}` 
                : needEpochs.map(e => e).join(', ');
            setTxt('hist-need-list', needStr);
        } else {
            needEl.classList.add('hidden');
        }
    }
    
    if (archiveEl) {
        if (archiveEpochs.length > 0) {
            archiveEl.classList.remove('hidden');
            let archiveStr = `Ep ${archiveEpochs[0]}${archiveEpochs.length > 1 ? '-' + archiveEpochs[archiveEpochs.length-1] : ''}`;
            setTxt('hist-archive-list', archiveStr);
        } else {
            archiveEl.classList.add('hidden');
        }
    }
}

async function fetchHistoricalFromGithub() {
    try {
        let resp = await fetch(HISTORICAL_URL);
        if (resp.ok) {
            store.historical = await resp.json();
            setTxt('fetch-historical', '‚úì');
            updateNormalDisplay();
        } else {
            setTxt('fetch-historical', '-');
        }
    } catch(e) {
        setTxt('fetch-historical', '‚úó');
        console.error('Failed to fetch historical:', e);
    }
}

function exportArchive() {
    // Extract epochs older than 180 days from historical
    let currentEpoch = store.meta.ep || 161;
    let archiveCutoff = currentEpoch - 26;
    
    if (!store.historical.lps || Object.keys(store.historical.lps).length === 0) {
        alert('No historical data loaded. Fetch from GitHub first.');
        return;
    }
    
    let archive = {
        meta: {
            archived_at: new Date().toISOString(),
            cutoff_epoch: archiveCutoff,
            source: 'tla_ext_historical'
        },
        lps: {}
    };
    
    let hasArchiveData = false;
    
    // Extract old epochs from each LP
    Object.entries(store.historical.lps).forEach(([lpKey, lpData]) => {
        let archiveLp = { liquidity: { epochs: {} }, volume: { epochs: {} } };
        
        // Liquidity epochs
        if (lpData.liquidity?.epochs) {
            Object.entries(lpData.liquidity.epochs).forEach(([ep, data]) => {
                if (parseInt(ep) < archiveCutoff) {
                    archiveLp.liquidity.epochs[ep] = data;
                    hasArchiveData = true;
                }
            });
        }
        
        // Volume epochs
        if (lpData.volume?.epochs) {
            Object.entries(lpData.volume.epochs).forEach(([ep, data]) => {
                if (parseInt(ep) < archiveCutoff) {
                    archiveLp.volume.epochs[ep] = data;
                    hasArchiveData = true;
                }
            });
        }
        
        // Only add LP if it has archive data
        if (Object.keys(archiveLp.liquidity.epochs).length > 0 || Object.keys(archiveLp.volume.epochs).length > 0) {
            archive.lps[lpKey] = archiveLp;
        }
    });
    
    if (!hasArchiveData) {
        alert('No epochs older than ' + archiveCutoff + ' to archive.');
        return;
    }
    
    // Find epoch range in archive
    let allEpochs = new Set();
    Object.values(archive.lps).forEach(lp => {
        Object.keys(lp.liquidity.epochs).forEach(ep => allEpochs.add(parseInt(ep)));
        Object.keys(lp.volume.epochs).forEach(ep => allEpochs.add(parseInt(ep)));
    });
    archive.meta.epoch_start = Math.min(...allEpochs);
    archive.meta.epoch_end = Math.max(...allEpochs);
    
    downloadJson(JSON.stringify(archive, null, 2), 'tla_ext_archive.json');
}

function updateSelectedLpNormal() {
    let lpKey = $('astro-lp-select-normal').value;
    
    // Clear paste areas and status when LP changes
    $('normalLiqPaste').value = '';
    $('normalVolPaste').value = '';
    $('normalLiqPaste').disabled = false;
    $('normalVolPaste').disabled = false;
    $('normalLiqPaste').placeholder = 'Paste Astroport liquidity JSON...';
    $('normalVolPaste').placeholder = 'Paste Astroport volume JSON...';
    if ($('normal-liq-unavailable')) $('normal-liq-unavailable').checked = false;
    if ($('normal-vol-unavailable')) $('normal-vol-unavailable').checked = false;
    setTxt('normal-liq-status', 'Empty');
    setTxt('normal-vol-status', 'Empty');
    setTxt('normal-liq-preview', '-');
    setTxt('normal-vol-preview', '-');
    $('normal-liq-status').className = 'text-[8px] text-gray-600';
    $('normal-vol-status').className = 'text-[8px] text-gray-600';
    
    if (!lpKey) {
        setTxt('normal-lp-liq-epochs', '-');
        setTxt('normal-lp-vol-epochs', '-');
        setTxt('normal-lp-partial', '-');
        setTxt('normal-lp-unavailable', '-');
        updateMergeButtonState();
        return;
    }
    
    // Get current status from historical file
    let lp = store.historical?.lps?.[lpKey];
    if (lp) {
        // Liquidity epochs
        let liqEpochs = Object.keys(lp.liquidity?.epochs || {}).map(Number).sort((a,b) => a-b);
        let liqComplete = liqEpochs.filter(e => lp.liquidity.epochs[e]?.complete !== false && !lp.liquidity.epochs[e]?.unavailable);
        let liqPartial = liqEpochs.filter(e => lp.liquidity.epochs[e]?.complete === false);
        let liqUnavail = liqEpochs.filter(e => lp.liquidity.epochs[e]?.unavailable === true);
        
        // Volume epochs  
        let volEpochs = Object.keys(lp.volume?.epochs || {}).map(Number).sort((a,b) => a-b);
        let volComplete = volEpochs.filter(e => lp.volume.epochs[e]?.complete !== false && !lp.volume.epochs[e]?.unavailable);
        let volPartial = volEpochs.filter(e => lp.volume.epochs[e]?.complete === false);
        let volUnavail = volEpochs.filter(e => lp.volume.epochs[e]?.unavailable === true);
        
        // Display
        let liqRange = liqComplete.length > 0 ? `${Math.min(...liqComplete)}-${Math.max(...liqComplete)}` : '-';
        let volRange = volComplete.length > 0 ? `${Math.min(...volComplete)}-${Math.max(...volComplete)}` : '-';
        
        setTxt('normal-lp-liq-epochs', `${liqRange} (${liqComplete.length})`);
        setTxt('normal-lp-vol-epochs', `${volRange} (${volComplete.length})`);
        
        // Partial data info
        let partialInfo = [];
        liqPartial.forEach(ep => {
            let raw = lp.liquidity.epochs[ep]?.raw || [];
            partialInfo.push(`Liq E${ep}: ${raw.length}d`);
        });
        volPartial.forEach(ep => {
            let raw = lp.volume.epochs[ep]?.raw || [];
            partialInfo.push(`Vol E${ep}: ${raw.length}d`);
        });
        setTxt('normal-lp-partial', partialInfo.length > 0 ? partialInfo.join(', ') : 'None');
        
        // Unavailable data info
        let unavailInfo = [];
        if (liqUnavail.length > 0) unavailInfo.push(`Liq: E${liqUnavail.join(',')}`);
        if (volUnavail.length > 0) unavailInfo.push(`Vol: E${volUnavail.join(',')}`);
        setTxt('normal-lp-unavailable', unavailInfo.length > 0 ? unavailInfo.join(' | ') : 'None');
    } else {
        setTxt('normal-lp-liq-epochs', 'New LP');
        setTxt('normal-lp-vol-epochs', 'New LP');
        setTxt('normal-lp-partial', '-');
    }
    
    updateMergeButtonState();
}

// Validate liquidity paste
function validateNormalLiqPaste() {
    let txt = $('normalLiqPaste').value.trim();
    if (!txt) {
        setTxt('normal-liq-status', 'Empty');
        setTxt('normal-liq-preview', '-');
        $('normal-liq-status').className = 'text-[8px] text-gray-600';
        updateMergeButtonState();
        return;
    }
    
    try {
        let json = JSON.parse(txt);
        let series = json?.result?.data?.json?.[0]?.series;
        if (series && Array.isArray(series) && series.length > 0) {
            let firstDate = new Date(series[0].time * 1000).toISOString().split('T')[0];
            let lastDate = new Date(series[series.length-1].time * 1000).toISOString().split('T')[0];
            setTxt('normal-liq-status', '‚úì Valid');
            setTxt('normal-liq-preview', `${series.length} points: ${firstDate} ‚Üí ${lastDate}`);
            $('normal-liq-status').className = 'text-[8px] text-green-400';
        } else {
            throw new Error('No series data');
        }
    } catch(e) {
        setTxt('normal-liq-status', '‚úó Invalid');
        setTxt('normal-liq-preview', e.message);
        $('normal-liq-status').className = 'text-[8px] text-red-400';
    }
    updateMergeButtonState();
}

// Validate volume paste
function validateNormalVolPaste() {
    let txt = $('normalVolPaste').value.trim();
    if (!txt) {
        setTxt('normal-vol-status', 'Empty');
        setTxt('normal-vol-preview', '-');
        $('normal-vol-status').className = 'text-[8px] text-gray-600';
        updateMergeButtonState();
        return;
    }
    
    try {
        let json = JSON.parse(txt);
        let series = json?.result?.data?.json?.[0]?.series;
        if (series && Array.isArray(series) && series.length > 0) {
            let firstDate = new Date(series[0].time * 1000).toISOString().split('T')[0];
            let lastDate = new Date(series[series.length-1].time * 1000).toISOString().split('T')[0];
            setTxt('normal-vol-status', '‚úì Valid');
            setTxt('normal-vol-preview', `${series.length} points: ${firstDate} ‚Üí ${lastDate}`);
            $('normal-vol-status').className = 'text-[8px] text-green-400';
        } else {
            throw new Error('No series data');
        }
    } catch(e) {
        setTxt('normal-vol-status', '‚úó Invalid');
        setTxt('normal-vol-preview', e.message);
        $('normal-vol-status').className = 'text-[8px] text-red-400';
    }
    updateMergeButtonState();
}

// Update merge button state
function updateMergeButtonState() {
    let lpKey = $('astro-lp-select-normal').value;
    let liqValid = $('normal-liq-status').textContent.includes('‚úì');
    let volValid = $('normal-vol-status').textContent.includes('‚úì');
    let liqUnavailable = $('normal-liq-unavailable')?.checked || false;
    let volUnavailable = $('normal-vol-unavailable')?.checked || false;
    
    let btn = $('normal-merge-btn');
    let status = $('normal-merge-status');
    
    if (!lpKey) {
        btn.disabled = true;
        status.textContent = 'Select an LP first';
        status.className = 'text-[8px] text-gray-500 text-center';
    } else if (!liqValid && !volValid && !liqUnavailable && !volUnavailable) {
        btn.disabled = true;
        status.textContent = 'Paste data or mark as unavailable';
        status.className = 'text-[8px] text-gray-500 text-center';
    } else {
        btn.disabled = false;
        let parts = [];
        if (liqValid) parts.push('Liq');
        if (volValid) parts.push('Vol');
        if (liqUnavailable) parts.push('Liq ‚ö†');
        if (volUnavailable) parts.push('Vol ‚ö†');
        status.textContent = `Ready to merge: ${parts.join(', ')}`;
        status.className = 'text-[8px] text-green-400 text-center';
    }
}

// Handle Liq unavailable checkbox change
function onLiqUnavailableChange() {
    let checked = $('normal-liq-unavailable').checked;
    let textarea = $('normalLiqPaste');
    
    if (checked) {
        textarea.disabled = true;
        textarea.value = '';
        textarea.placeholder = 'Data marked as unavailable';
        setTxt('normal-liq-status', '‚ö† Unavailable');
        setTxt('normal-liq-preview', 'Will be flagged in data');
        $('normal-liq-status').className = 'text-[8px] text-red-400';
    } else {
        textarea.disabled = false;
        textarea.placeholder = 'Paste Astroport liquidity JSON...';
        setTxt('normal-liq-status', 'Empty');
        setTxt('normal-liq-preview', '-');
        $('normal-liq-status').className = 'text-[8px] text-gray-600';
    }
    updateMergeButtonState();
}

// Handle Vol unavailable checkbox change
function onVolUnavailableChange() {
    let checked = $('normal-vol-unavailable').checked;
    let textarea = $('normalVolPaste');
    
    if (checked) {
        textarea.disabled = true;
        textarea.value = '';
        textarea.placeholder = 'Data marked as unavailable';
        setTxt('normal-vol-status', '‚ö† Unavailable');
        setTxt('normal-vol-preview', 'Will be flagged in data');
        $('normal-vol-status').className = 'text-[8px] text-red-400';
    } else {
        textarea.disabled = false;
        textarea.placeholder = 'Paste Astroport volume JSON...';
        setTxt('normal-vol-status', 'Empty');
        setTxt('normal-vol-preview', '-');
        $('normal-vol-status').className = 'text-[8px] text-gray-600';
    }
    updateMergeButtonState();
}

// Main merge function - merges both liq and vol at once
function mergeNormalLpData() {
    let lpKey = $('astro-lp-select-normal').value;
    if (!lpKey) {
        alert('Please select an LP');
        return;
    }
    
    if (!store.historical) {
        alert('Please load a historical file first');
        return;
    }
    
    let liqTxt = $('normalLiqPaste').value.trim();
    let volTxt = $('normalVolPaste').value.trim();
    let liqUnavailable = $('normal-liq-unavailable')?.checked || false;
    let volUnavailable = $('normal-vol-unavailable')?.checked || false;
    
    if (!liqTxt && !volTxt && !liqUnavailable && !volUnavailable) {
        alert('Please paste data or mark as unavailable');
        return;
    }
    
    // Initialize LP if needed
    if (!store.historical.lps) store.historical.lps = {};
    if (!store.historical.lps[lpKey]) {
        store.historical.lps[lpKey] = {
            liquidity: { epochs: {} },
            volume: { epochs: {} }
        };
    }
    
    let results = { liq: null, vol: null, liqUnavail: false, volUnavail: false };
    
    // Merge liquidity
    if (liqTxt) {
        try {
            results.liq = mergeDataIntoHistorical(lpKey, 'liquidity', liqTxt);
        } catch(e) {
            alert('Liquidity merge failed: ' + e.message);
            return;
        }
    } else if (liqUnavailable) {
        // Mark liquidity as unavailable for current epochs
        results.liqUnavail = markDataUnavailable(lpKey, 'liquidity');
    }
    
    // Merge volume
    if (volTxt) {
        try {
            results.vol = mergeDataIntoHistorical(lpKey, 'volume', volTxt);
        } catch(e) {
            alert('Volume merge failed: ' + e.message);
            return;
        }
    } else if (volUnavailable) {
        // Mark volume as unavailable for current epochs
        results.volUnavail = markDataUnavailable(lpKey, 'volume');
    }
    
    // Update meta
    store.historical.meta.last_updated = new Date().toISOString().split('T')[0];
    
    // Track session progress
    if (!store.sessionProgress) store.sessionProgress = { lpsUpdated: new Set(), epochsAdded: new Set() };
    store.sessionProgress.lpsUpdated.add(lpKey);
    if (results.liq?.newEpochs) results.liq.newEpochs.forEach(e => store.sessionProgress.epochsAdded.add(e));
    if (results.vol?.newEpochs) results.vol.newEpochs.forEach(e => store.sessionProgress.epochsAdded.add(e));
    
    // Update UI
    updateSessionProgress();
    renderNormalLpGrid();
    updateSelectedLpNormal();  // Refresh LP status
    
    // Clear paste areas and reset checkboxes
    $('normalLiqPaste').value = '';
    $('normalVolPaste').value = '';
    $('normalLiqPaste').disabled = false;
    $('normalVolPaste').disabled = false;
    $('normalLiqPaste').placeholder = 'Paste Astroport liquidity JSON...';
    $('normalVolPaste').placeholder = 'Paste Astroport volume JSON...';
    if ($('normal-liq-unavailable')) $('normal-liq-unavailable').checked = false;
    if ($('normal-vol-unavailable')) $('normal-vol-unavailable').checked = false;
    validateNormalLiqPaste();
    validateNormalVolPaste();
    
    // Show results
    let msg = [`‚úÖ Merged data for ${lpKey.split('|')[0]}`];
    if (results.liq) {
        msg.push(`Liq: ${results.liq.pointsAdded} pts, ${results.liq.epochsCompleted} epochs completed, ${results.liq.partialDays} partial days`);
    }
    if (results.liqUnavail) {
        msg.push(`Liq: ‚ö† Marked as UNAVAILABLE for E${results.liqUnavail.epochs.join(', E')}`);
    }
    if (results.vol) {
        msg.push(`Vol: ${results.vol.pointsAdded} pts, ${results.vol.epochsCompleted} epochs completed, ${results.vol.partialDays} partial days`);
    }
    if (results.volUnavail) {
        msg.push(`Vol: ‚ö† Marked as UNAVAILABLE for E${results.volUnavail.epochs.join(', E')}`);
    }
    alert(msg.join('\n'));
}

// Merge data into historical file
function mergeDataIntoHistorical(lpKey, type, jsonText) {
    let json = JSON.parse(jsonText);
    let series = json?.result?.data?.json?.[0]?.series;
    
    if (!series || !Array.isArray(series)) {
        throw new Error('Invalid data format');
    }
    
    let lp = store.historical.lps[lpKey];
    if (!lp[type]) lp[type] = { epochs: {} };
    
    // Epoch boundaries (approximate - 7 days per epoch)
    // E165 ends ~Dec 28, 2025
    const E165_END = new Date('2025-12-28T12:00:00Z').getTime() / 1000;
    const EPOCH_DURATION = 7 * 24 * 60 * 60;
    
    function getEpochForTimestamp(ts) {
        let diff = E165_END - ts;
        let epochsBack = Math.floor(diff / EPOCH_DURATION);
        return 165 - epochsBack;
    }
    
    function getEpochDateRange(epoch) {
        let endTs = E165_END - (165 - epoch) * EPOCH_DURATION;
        let startTs = endTs - EPOCH_DURATION;
        return {
            start: new Date(startTs * 1000).toISOString().split('T')[0],
            end: new Date(endTs * 1000).toISOString().split('T')[0]
        };
    }
    
    // Group points by epoch
    let epochPoints = {};
    series.forEach(p => {
        let epoch = getEpochForTimestamp(p.time);
        let date = new Date(p.time * 1000).toISOString().split('T')[0];
        if (!epochPoints[epoch]) epochPoints[epoch] = {};
        epochPoints[epoch][date] = p.value;  // Use date as key to avoid duplicates
    });
    
    let pointsAdded = 0;
    let epochsCompleted = 0;
    let partialDays = 0;
    let newEpochs = [];
    
    // Merge into historical
    Object.entries(epochPoints).forEach(([epochStr, dateValues]) => {
        let epoch = parseInt(epochStr);
        let existing = lp[type].epochs[epoch];
        
        // If epoch already complete, skip
        if (existing?.complete === true) {
            return;
        }
        
        // Merge raw data
        let rawMap = {};
        if (existing?.raw) {
            existing.raw.forEach(r => rawMap[r.date] = r.value);
        }
        Object.entries(dateValues).forEach(([date, value]) => {
            if (!rawMap[date]) {
                rawMap[date] = value;
                pointsAdded++;
            }
        });
        
        let rawArray = Object.entries(rawMap)
            .map(([date, value]) => ({ date, value }))
            .sort((a, b) => a.date.localeCompare(b.date));
        
        // Check if epoch is complete (7 days or epoch is old enough)
        let epochRange = getEpochDateRange(epoch);
        let now = new Date().toISOString().split('T')[0];
        let epochEnded = now > epochRange.end;
        
        if (rawArray.length >= 7 || (epochEnded && rawArray.length >= 4)) {
            // Calculate average and mark complete
            let avg = rawArray.reduce((s, r) => s + r.value, 0) / rawArray.length;
            lp[type].epochs[epoch] = {
                avg: Math.round(avg * 100) / 100,
                days: rawArray.length,
                complete: true
            };
            epochsCompleted++;
            if (!existing) newEpochs.push(epoch);
        } else {
            // Keep as partial
            lp[type].epochs[epoch] = {
                avg: null,
                days: rawArray.length,
                complete: false,
                raw: rawArray
            };
            partialDays += rawArray.length;
        }
    });
    
    return { pointsAdded, epochsCompleted, partialDays, newEpochs };
}

// Mark data as unavailable for current epoch range
function markDataUnavailable(lpKey, type) {
    let lp = store.historical.lps[lpKey];
    if (!lp[type]) lp[type] = { epochs: {} };
    
    // Determine epochs to mark (E161-E166 based on current date)
    // E165 ends ~Dec 28, 2025
    const E165_END = new Date('2025-12-28T12:00:00Z').getTime() / 1000;
    const EPOCH_DURATION = 7 * 24 * 60 * 60;
    const now = Date.now() / 1000;
    
    // Current epoch
    let currentEpoch = 165 - Math.floor((E165_END - now) / EPOCH_DURATION);
    if (now > E165_END) {
        currentEpoch = 165 + Math.ceil((now - E165_END) / EPOCH_DURATION);
    }
    
    // Find highest complete epoch for this LP/type
    let existingEpochs = Object.keys(lp[type].epochs || {}).map(Number);
    let lastComplete = existingEpochs.filter(e => {
        let d = lp[type].epochs[e];
        return d.complete !== false && d.avg !== null && !d.unavailable;
    });
    let startEpoch = lastComplete.length > 0 ? Math.max(...lastComplete) + 1 : 161;
    
    // Mark epochs from startEpoch to currentEpoch as unavailable
    let markedEpochs = [];
    for (let ep = startEpoch; ep <= currentEpoch; ep++) {
        // Don't overwrite existing good data
        let existing = lp[type].epochs[ep];
        if (existing && existing.complete === true && !existing.unavailable) {
            continue;
        }
        
        // Get date range for this epoch
        let epochEndTs = E165_END + (ep - 165) * EPOCH_DURATION;
        let epochStartTs = epochEndTs - EPOCH_DURATION;
        let startDate = new Date(epochStartTs * 1000).toISOString().split('T')[0];
        let endDate = new Date(epochEndTs * 1000).toISOString().split('T')[0];
        
        lp[type].epochs[ep] = {
            avg: null,
            days: 0,
            complete: true,  // Mark as "complete" so it's not waiting for data
            unavailable: true,  // Flag that data was unavailable
            unavailable_date: new Date().toISOString().split('T')[0],
            date_range: { start: startDate, end: endDate },
            reason: 'Data unavailable from source'
        };
        markedEpochs.push(ep);
    }
    
    return markedEpochs.length > 0 ? { epochs: markedEpochs } : null;
}

// Update session progress display
function updateSessionProgress() {
    if (!store.sessionProgress) {
        setTxt('session-lps-updated', '0');
        setTxt('session-epochs-added', '-');
        setTxt('session-pending', 'No');
        return;
    }
    
    setTxt('session-lps-updated', store.sessionProgress.lpsUpdated.size);
    let epochs = Array.from(store.sessionProgress.epochsAdded).sort((a,b) => a-b);
    setTxt('session-epochs-added', epochs.length > 0 ? epochs.join(', ') : '-');
    setTxt('session-pending', store.sessionProgress.lpsUpdated.size > 0 ? 'Yes' : 'No');
    $('session-pending').className = store.sessionProgress.lpsUpdated.size > 0 ? 'text-yellow-400 font-mono' : 'text-gray-400 font-mono';
}

// Load historical file from disk
function loadHistoricalFile() {
    $('hist-file-input').click();
}

function handleHistoricalFileLoad(event) {
    let file = event.target.files[0];
    if (!file) return;
    
    let reader = new FileReader();
    reader.onload = function(e) {
        try {
            store.historical = JSON.parse(e.target.result);
            updateHistoricalDisplay();
            updateAstroLpDropdownNormal();
            renderNormalLpGrid();
            alert('‚úÖ Loaded historical file: ' + file.name);
        } catch(err) {
            alert('Failed to parse file: ' + err.message);
        }
    };
    reader.readAsText(file);
}

// Update historical display
function updateHistoricalDisplay() {
    if (!store.historical?.meta) {
        setTxt('hist-epochs', '-');
        setTxt('hist-lps', '0');
        setTxt('hist-updated', '-');
        return;
    }
    
    let meta = store.historical.meta;
    let epochRange = meta.epoch_range || [meta.epoch_start, meta.epoch_end];
    setTxt('hist-epochs', epochRange ? `${epochRange[0]} - ${epochRange[1]}` : '-');
    setTxt('hist-lps', store.historical.lps ? Object.keys(store.historical.lps).length : 0);
    setTxt('hist-updated', meta.last_updated || '-');
}

// Update LP dropdown for normal mode (from historical file)
function updateAstroLpDropdownNormal() {
    let select = $('astro-lp-select-normal');
    if (!select) return;
    
    // Get LPs from historical file
    let lps = [];
    if (store.historical?.lps) {
        lps = Object.keys(store.historical.lps)
            .filter(k => k.includes('Astroport'))
            .sort();
    }
    
    // Also add any from LP registry that aren't in historical
    if (store.lpRegistry) {
        Object.entries(store.lpRegistry)
            .filter(([k, v]) => v.dex === 'Astroport')
            .forEach(([k, v]) => {
                if (!lps.includes(k)) lps.push(k);
            });
    }
    
    let currentValue = select.value;
    select.innerHTML = '<option value="">-- Select LP --</option>';
    
    lps.forEach(lpKey => {
        let lpName = lpKey.split('|')[0];
        let inHistorical = store.historical?.lps?.[lpKey];
        let label = inHistorical ? lpName : `${lpName} (new)`;
        select.innerHTML += `<option value="${lpKey}">${label}</option>`;
    });
    
    // Restore selection if still valid
    if (currentValue && lps.includes(currentValue)) {
        select.value = currentValue;
    }
}

function renderNormalLpGrid() {
    // Get LPs from historical file
    let lps = [];
    if (store.historical?.lps) {
        lps = Object.entries(store.historical.lps)
            .filter(([k, v]) => k.includes('Astroport'))
            .sort((a, b) => a[0].localeCompare(b[0]));
    }
    
    let html = '';
    
    lps.forEach(([key, lp]) => {
        let lpName = key.split('|')[0];
        
        // Get epoch info
        let liqEpochs = Object.keys(lp.liquidity?.epochs || {}).map(Number);
        let volEpochs = Object.keys(lp.volume?.epochs || {}).map(Number);
        let liqComplete = liqEpochs.filter(e => lp.liquidity.epochs[e]?.complete !== false && !lp.liquidity.epochs[e]?.unavailable);
        let volComplete = volEpochs.filter(e => lp.volume.epochs[e]?.complete !== false && !lp.volume.epochs[e]?.unavailable);
        let liqPartial = liqEpochs.filter(e => lp.liquidity.epochs[e]?.complete === false);
        let volPartial = volEpochs.filter(e => lp.volume.epochs[e]?.complete === false);
        let liqUnavail = liqEpochs.filter(e => lp.liquidity.epochs[e]?.unavailable === true);
        let volUnavail = volEpochs.filter(e => lp.volume.epochs[e]?.unavailable === true);
        
        let maxLiqEp = liqComplete.length > 0 ? Math.max(...liqComplete) : 0;
        let maxVolEp = volComplete.length > 0 ? Math.max(...volComplete) : 0;
        
        // Status color
        let updated = store.sessionProgress?.lpsUpdated?.has(key);
        let hasPartial = liqPartial.length > 0 || volPartial.length > 0;
        let hasUnavail = liqUnavail.length > 0 || volUnavail.length > 0;
        
        let bgClass = updated ? 'bg-green-900/30 border-green-700' : 
                      hasUnavail ? 'bg-red-900/30 border-red-700' :
                      hasPartial ? 'bg-yellow-900/30 border-yellow-700' :
                      'bg-[#0D0D0D] border-gray-800';
        
        // Partial info
        let partialInfo = '';
        if (liqPartial.length > 0) {
            let days = lp.liquidity.epochs[liqPartial[0]]?.raw?.length || 0;
            partialInfo += `L:${days}d `;
        }
        if (volPartial.length > 0) {
            let days = lp.volume.epochs[volPartial[0]]?.raw?.length || 0;
            partialInfo += `V:${days}d`;
        }
        
        // Unavailable info
        let unavailInfo = '';
        if (liqUnavail.length > 0) unavailInfo += `L:‚ö† `;
        if (volUnavail.length > 0) unavailInfo += `V:‚ö†`;
        
        html += `<div class="p-2 rounded border ${bgClass} text-[9px]">
            <div class="text-white font-mono truncate" title="${lpName}">${lpName}</div>
            <div class="flex justify-between mt-1">
                <span class="${liqUnavail.length > 0 ? 'text-red-400' : 'text-cyan-400'}">L: E${maxLiqEp || '-'}${liqUnavail.length > 0 ? '‚ö†' : ''}</span>
                <span class="${volUnavail.length > 0 ? 'text-red-400' : 'text-purple-400'}">V: E${maxVolEp || '-'}${volUnavail.length > 0 ? '‚ö†' : ''}</span>
            </div>
            ${partialInfo ? `<div class="text-yellow-400 text-[8px] mt-1">${partialInfo}</div>` : ''}
            ${unavailInfo ? `<div class="text-red-400 text-[8px] mt-1">${unavailInfo}</div>` : ''}
        </div>`;
    });
    
    setHtml('astro-normal-lp-grid', html || '<div class="col-span-4 text-gray-600 italic text-center py-4">Load historical file first.</div>');
}

// Export updated historical
function exportUpdatedHistorical() {
    if (!store.historical) {
        alert('No historical data to export');
        return;
    }
    
    // Update meta
    store.historical.meta.last_updated = new Date().toISOString().split('T')[0];
    
    // Recalculate epoch range
    let allEpochs = new Set();
    Object.values(store.historical.lps || {}).forEach(lp => {
        Object.keys(lp.liquidity?.epochs || {}).forEach(e => allEpochs.add(parseInt(e)));
        Object.keys(lp.volume?.epochs || {}).forEach(e => allEpochs.add(parseInt(e)));
    });
    let epochArr = Array.from(allEpochs).sort((a,b) => a-b);
    if (epochArr.length > 0) {
        store.historical.meta.epoch_range = [epochArr[0], epochArr[epochArr.length - 1]];
    }
    
    // Update complete/partial lists - check both 'complete' flag AND presence of 'avg'
    let complete = new Set();
    let partial = new Set();
    Object.values(store.historical.lps || {}).forEach(lp => {
        Object.entries(lp.liquidity?.epochs || {}).forEach(([e, d]) => {
            let epNum = parseInt(e);
            // Epoch is complete if: complete flag is true (or missing) AND has avg value AND no raw data
            let isComplete = (d.complete !== false) && (d.avg !== null && d.avg !== undefined) && !d.raw;
            if (isComplete) complete.add(epNum);
            else partial.add(epNum);
        });
        Object.entries(lp.volume?.epochs || {}).forEach(([e, d]) => {
            let epNum = parseInt(e);
            let isComplete = (d.complete !== false) && (d.avg !== null && d.avg !== undefined) && !d.raw;
            if (isComplete) complete.add(epNum);
            else partial.add(epNum);
        });
    });
    // An epoch is only fully complete if ALL LPs have it complete (not in partial)
    store.historical.meta.complete_epochs = Array.from(complete).filter(e => !partial.has(e)).sort((a,b) => a-b);
    store.historical.meta.partial_epochs = Array.from(partial).sort((a,b) => a-b);
    store.historical.meta.lp_count = Object.keys(store.historical.lps || {}).length;
    
    let json = JSON.stringify(store.historical, null, 2);
    downloadJson(json, 'tla_ext_historical.json');
}

function parseNormalLiquidity() {
    // Legacy - redirect to validation
    validateNormalLiqPaste();
}

function parseNormalVolume() {
    // Legacy - redirect to validation
    validateNormalVolPaste();
}

// ============ EXPORT FUNCTIONS ============

function exportHistorical() {
    // Use the updated export which recalculates meta
    exportUpdatedHistorical();
}

function exportCurrent() {
    let json = JSON.stringify(store.current, null, 2);
    downloadJson(json, 'tla_ext_current.json');
}

function exportCombined() {
    // Merge historical and current
    let combined = {
        meta: {
            generated: new Date().toISOString(),
            source: 'tla-admin-ext'
        },
        lps: {}
    };
    
    // Add historical
    if (store.historical.lps) {
        Object.entries(store.historical.lps).forEach(([name, lp]) => {
            combined.lps[name] = JSON.parse(JSON.stringify(lp));
        });
    }
    
    // Merge current (overwrite epoch data, append raw)
    if (store.current.lps) {
        Object.entries(store.current.lps).forEach(([name, lp]) => {
            if (!combined.lps[name]) {
                combined.lps[name] = JSON.parse(JSON.stringify(lp));
            } else {
                ['liquidity', 'volume'].forEach(type => {
                    // Merge epochs
                    Object.assign(combined.lps[name][type].epochs, lp[type].epochs);
                    // Dedupe and merge raw
                    let existing = new Set(combined.lps[name][type].raw.map(p => p.ts));
                    let newRaw = lp[type].raw.filter(p => !existing.has(p.ts));
                    combined.lps[name][type].raw.push(...newRaw);
                });
            }
        });
    }
    
    // Calculate epoch coverage
    let allEpochs = new Set();
    Object.values(combined.lps).forEach(lp => {
        Object.keys(lp.liquidity?.epochs || {}).forEach(ep => allEpochs.add(parseInt(ep)));
        Object.keys(lp.volume?.epochs || {}).forEach(ep => allEpochs.add(parseInt(ep)));
    });
    
    if (allEpochs.size > 0) {
        combined.meta.epoch_start = Math.min(...allEpochs);
        combined.meta.epoch_end = Math.max(...allEpochs);
    }
    
    let json = JSON.stringify(combined, null, 2);
    downloadJson(json, 'tla_ext_combined.json');
}

function downloadJson(json, filename) {
    let blob = new Blob([json], { type: 'application/json' });
    let url = URL.createObjectURL(blob);
    let a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();
    URL.revokeObjectURL(url);
}

function parseWW() {
    let txt = $('wwPaste').value;
    let lines = txt.split('\n').map(l => l.trim()).filter(l => l);
    
    store.ww = [];
    let i = 0;
    
    while (i < lines.length) {
        let line = lines[i];
        
        if ((line.includes('-') || line.includes('/')) && line.match(/[A-Z]{2,}/)) {
            let pool = line.replace(' LP', '').trim();
            let volume = 0;
            let fees = 0;
            let apr = '-';
            
            for (let k = 1; k <= 8 && i + k < lines.length; k++) {
                let next = lines[i + k];
                
                if (next.includes('$') && volume === 0) {
                    volume = clean(next);
                } else if (next.includes('$') && fees === 0) {
                    fees = clean(next);
                }
                if (next.includes('%')) {
                    apr = next;
                }
                if (k > 2 && (next.includes('-') || next.includes('/')) && next.match(/[A-Z]{2,}/) && !next.includes('$')) break;
            }
            
            if (pool && (volume > 0 || fees > 0)) {
                store.ww.push({ pool, volume, fees, apr });
            }
        }
        i++;
    }
    
    let html = '';
    store.ww.forEach(b => {
        html += `<div class="grid grid-cols-12 gap-1 border-b border-gray-800/50 py-1 text-gray-300 hover:bg-white/5 px-2">
            <div class="col-span-5 truncate text-white text-[10px]" title="${b.pool}">${b.pool}</div>
            <div class="col-span-2 text-right font-mono text-[9px] text-blue-300">${b.volume > 0 ? fmt$(b.volume) : '-'}</div>
            <div class="col-span-2 text-right font-mono text-[9px] text-green-300">${b.fees > 0 ? fmt$(b.fees) : '-'}</div>
            <div class="col-span-3 text-right text-[9px] text-yellow-400">${b.apr}</div>
        </div>`;
    });
    setHtml('ww-list', html || '<div class="text-center text-gray-600 italic py-4">No data parsed.</div>');
    setTxt('ww-count', store.ww.length);
    
    pasteStatus.ww = store.ww.length > 0;
    updatePasteStatus('ps-ww', pasteStatus.ww);
}

function getExportData() {
    // Aggregate votion pools from all lockups
    // Key insight: Each bucket uses 100% of lockup VP independently
    // So we sum VP amounts (not percentages) across all lockups for each pool
    
    let votionPools = {};
    let totalVp = 0;
    
    // First calculate total VP across all lockups
    store.votion.lockups.forEach(lockup => {
        totalVp += lockup.vp || 0;
    });
    
    console.log('Votion Export: Total VP from', store.votion.lockups.length, 'lockups:', totalVp.toLocaleString());
    
    // Now aggregate per-pool VP from all lockups
    // Helper to normalize pool name to match Vote page format
    // Vote page is source of truth - preserve its naming conventions
    function normalizePoolName(name) {
        // Remove LP suffix
        name = name.replace(' LP', '').trim();
        
        // Handle bridge suffix variations:
        // Votion sometimes uses "WBTCaxl" (no dot) vs "wBTC.axl" (with dot)
        // We normalize to include the dot: token.suffix
        
        // First, handle cases where suffix is attached without dot (WBTCaxl, WBTCosmo)
        // Only match if NOT preceded by a dot
        name = name.replace(/([^.])(atom|axl|osmo|wh)$/gi, (match, p1, p2) => p1 + '.' + p2.toLowerCase());
        
        // Now handle cases where suffix already has dot but wrong case (.ATOM -> .atom)
        name = name.replace(/\.(ATOM|AXL|OSMO|WH)/g, (match) => match.toLowerCase());
        
        // Handle token order - LUNA should be first for most pairs
        if (name.includes('-')) {
            let parts = name.split('-');
            
            // Only swap if LUNA itself is second (to put LUNA first)
            // Don't swap for ampLUNA, bLUNA - they stay as LUNA-ampLUNA, LUNA-bLUNA
            let secondBase = parts[1].replace(/\.(atom|axl|osmo|wh)$/i, '');
            if (secondBase === 'LUNA') {
                name = `LUNA-${parts[0]}`;
            }
        }
        
        return name;
    }
    
    store.votion.lockups.forEach(lockup => {
        let lockupVp = lockup.vp || 0;
        if (lockupVp === 0) return;
        
        console.log(`Processing ${lockup.type} ${lockup.duration}: ${lockupVp.toLocaleString()} VP`);
        
        lockup.buckets?.forEach(bucket => {
            let bucketName = (bucket.name || '').toLowerCase();
            
            bucket.pools?.forEach(pool => {
                // Normalize pool name to match Core tool format
                let poolName = normalizePoolName(pool.name);
                
                // Map to standard LP key format
                // All TLA pools are on Astroport
                let lpKey = `${poolName}|Astroport`;
                
                if (!votionPools[lpKey]) {
                    votionPools[lpKey] = {
                        current_vp: 0,
                        optimized_vp: 0,
                        current_pct: 0,
                        optimized_pct: 0,
                        bucket: bucketName,
                        lockup_contributions: []
                    };
                }
                
                // Calculate VP from this lockup's allocation
                let currentVp = lockupVp * (pool.current / 100);
                let optimizedVp = lockupVp * (pool.optimized / 100);
                
                votionPools[lpKey].current_vp += currentVp;
                votionPools[lpKey].optimized_vp += optimizedVp;
                
                // Track which lockups contribute (for debugging)
                votionPools[lpKey].lockup_contributions.push({
                    type: lockup.type,
                    duration: lockup.duration,
                    lockup_vp: lockupVp,
                    current_pct: pool.current,
                    optimized_pct: pool.optimized,
                    current_vp: currentVp,
                    optimized_vp: optimizedVp
                });
            });
        });
    });
    
    // Calculate percentages - since each bucket uses 100% of total VP,
    // the % within bucket equals % of total Votion VP
    Object.keys(votionPools).forEach(key => {
        if (totalVp > 0) {
            // This gives us the weighted average % within the bucket
            votionPools[key].current_pct = (votionPools[key].current_vp / totalVp) * 100;
            votionPools[key].optimized_pct = (votionPools[key].optimized_vp / totalVp) * 100;
        }
        // Round VP for cleaner output
        votionPools[key].current_vp = Math.round(votionPools[key].current_vp);
        votionPools[key].optimized_vp = Math.round(votionPools[key].optimized_vp);
    });
    
    console.log('Votion Export: Aggregated', Object.keys(votionPools).length, 'pools');
    
    // Aggregate PD bribes for current epoch - PER POOL
    let pdBribesForEpoch = {};
    let currentEpoch = store.meta.ep;
    
    store.pdBribesHistory.forEach(prop => {
        if (currentEpoch >= prop.start_epoch && currentEpoch <= prop.end_epoch) {
            prop.bribes?.forEach(bribe => {
                // Use pool name, not gauge (bucket)
                let lpKey = `${bribe.pool}|Astroport`;
                if (!pdBribesForEpoch[lpKey]) {
                    pdBribesForEpoch[lpKey] = { usd: 0, pct: 0, bucket: bribe.gauge };
                }
                pdBribesForEpoch[lpKey].usd += bribe.usd_per_epoch || 0;
                pdBribesForEpoch[lpKey].pct += bribe.percent || 0;
            });
        }
    });
    
    return {
        meta: {
            generated_at: new Date().toISOString(),
            epoch: store.meta.ep,
            phase: store.meta.ph,
            source: 'tla-admin-ext'
        },
        votion: {
            ratios: { arbLUNA: store.votion.ratioArb, ampLUNA: store.votion.ratioAmp },
            total_vp: Math.round(totalVp),
            pools: votionPools,
            lockups: store.votion.lockups // Keep raw lockups for reference
        },
        // Comprehensive LST ratios for dashboard snapshot
        lst_ratios: {
            snapshot_date: new Date().toISOString(),
            chain_staking_apr: store.lstRatios.chainStakingApr,
            chain_staking_apr_date: store.lstRatios.chainStakingAprDate,
            tokens: {
                ampLUNA: { ratio: store.lstRatios.ampLUNA?.ratio, base: 'LUNA', apy: store.lstRatios.ampLUNA?.apy, source: store.lstRatios.ampLUNA?.source },
                arbLUNA: { ratio: store.lstRatios.arbLUNA?.ratio, base: 'LUNA', apy: store.lstRatios.arbLUNA?.apy, source: store.lstRatios.arbLUNA?.source },
                bLUNA: { ratio: store.lstRatios.bLUNA?.ratio, base: 'LUNA', apy: store.lstRatios.bLUNA?.apy, source: store.lstRatios.bLUNA?.source },
                ampCAPA: { ratio: store.lstRatios.ampCAPA?.ratio, base: 'CAPA', apy: store.lstRatios.ampCAPA?.apy, source: store.lstRatios.ampCAPA?.source },
                ampROAR: { ratio: store.lstRatios.ampROAR?.ratio, base: 'ROAR', apy: store.lstRatios.ampROAR?.apy, source: store.lstRatios.ampROAR?.source },
                xASTRO: { ratio: store.lstRatios.xASTRO?.ratio, base: 'ASTRO', apy: store.lstRatios.xASTRO?.apy, source: store.lstRatios.xASTRO?.source }
            }
        },
        // Token prices from CoinGecko + calculated
        token_prices: Object.fromEntries(
            Object.entries(store.tokenPrices).map(([token, data]) => [
                token, 
                { price: data.price, source: data.source, geckoId: data.geckoId }
            ])
        ),
        // LP Registry data
        lp_registry: store.lpRegistry,
        pd_bribes: pdBribesForEpoch, // Simplified bribes for this epoch
        pd_bribes_master: store.pdBribesHistory, // Full bribe history
        astroport_data: store.astro,
        skeleton_swap_data: store.ww
    };
}

function clearAll() {
    if(confirm("Reset all Extension data?")) location.reload();
}

// ============================================
// PRICE MANAGER
// ============================================

const defaultBannerTokens = [
    { symbol: 'LUNA', geckoId: 'terra-luna-2', priority: 1 },
    { symbol: 'ampLUNA', geckoId: 'eris-amplified-luna', priority: 2 },
    { symbol: 'arbLUNA', geckoId: 'eris-arbitrage-luna', priority: 3 },
    { symbol: 'bLUNA', geckoId: 'backbone-labs-staked-luna', priority: 4 },
    { symbol: 'ROAR', geckoId: 'lion-dao', priority: 5 },
    { symbol: 'CAPA', geckoId: 'capapult', priority: 6 },
    { symbol: 'SOLID', geckoId: 'solid-2', priority: 7 },
    { symbol: 'xASTRO', geckoId: 'astroport-fi', priority: 8 },
    { symbol: 'wBTC', geckoId: 'eureka-bridged-wbtc-terra', priority: 9 },
    { symbol: 'ATOM', geckoId: 'cosmos', priority: 10 },
    { symbol: 'ETH', geckoId: 'ethereum', priority: 11 },
    { symbol: 'USDC', geckoId: 'usd-coin', priority: 12 }
];

let priceStore = {
    bannerTokens: [...defaultBannerTokens],
    prices: {},
    lstRatios: {},
    manualPrices: {},
    lastFetch: null,
    selectedTokens: {}
};
defaultBannerTokens.forEach(t => priceStore.selectedTokens[t.symbol] = true);

async function fetchAllPrices() {
    const statusEl = $('prices-fetch-status');
    if (!statusEl) return;
    statusEl.className = 'px-3 py-1 rounded text-[10px] font-bold bg-yellow-900/30 text-yellow-400';
    statusEl.innerHTML = '<i class="fas fa-spinner fa-spin mr-1"></i> Fetching...';
    
    try {
        await fetchCoinGeckoPrices();
        await fetchLstRatiosFromChainForPrices();
        calculateDerivedPrices();
        renderBannerTokens();
        updateLstRatiosSummary();
        updatePriceSnapshotPreview();
        
        priceStore.lastFetch = new Date().toISOString();
        setTxt('price-status-time', new Date().toLocaleTimeString());
        
        statusEl.className = 'px-3 py-1 rounded text-[10px] font-bold bg-green-900/30 text-green-400';
        statusEl.innerHTML = '<i class="fas fa-check mr-1"></i> Fetched';
    } catch (error) {
        console.error('Price fetch error:', error);
        statusEl.className = 'px-3 py-1 rounded text-[10px] font-bold bg-red-900/30 text-red-400';
        statusEl.innerHTML = 'Error';
    }
}

async function fetchCoinGeckoPrices() {
    const geckoIds = priceStore.bannerTokens.map(t => t.geckoId).filter(Boolean).join(',');
    const url = `https://api.coingecko.com/api/v3/simple/price?ids=${geckoIds}&vs_currencies=usd`;
    setTxt('price-status-coingecko', '‚è≥');
    
    try {
        const response = await fetch(url);
        if (!response.ok) throw new Error('CoinGecko API failed');
        const data = await response.json();
        
        priceStore.bannerTokens.forEach(token => {
            if (token.geckoId && data[token.geckoId]?.usd) {
                priceStore.prices[token.symbol] = data[token.geckoId].usd;
            }
        });
        setTxt('price-status-coingecko', '‚úÖ');
    } catch (error) {
        setTxt('price-status-coingecko', '‚ùå');
        console.error('CoinGecko error:', error);
    }
}

async function fetchLstRatiosFromChainForPrices() {
    setTxt('price-status-lst', '‚è≥');
    try {
        const ampLunaQuery = btoa(JSON.stringify({ exchange_rates: {} }));
        const ampLunaUrl = `https://terra.publicnode.com/cosmwasm/wasm/v1/contract/terra10788fkzah89xrdm27zkj5yvhj9x3494lxawzm5qq3vvxcqz2yzaqyd3enk/smart/${ampLunaQuery}`;
        
        const ampLunaRes = await fetch(ampLunaUrl);
        if (ampLunaRes.ok) {
            const ampLunaData = await ampLunaRes.json();
            const rate = parseFloat(ampLunaData?.data?.exchange_rates?.[0]?.[1] || 0);
            if (rate > 0) {
                priceStore.lstRatios.ampLUNA = rate;
                setTxt('lst-sum-ampLUNA', rate.toFixed(4));
                const lstInput = $('lst-ratio-ampLUNA');
                if (lstInput) lstInput.value = rate.toFixed(4);
            }
        }
        
        priceStore.lstRatios.arbLUNA = store.lstRatios?.arbLUNA?.ratio || 2.6873;
        priceStore.lstRatios.bLUNA = store.lstRatios?.bLUNA?.ratio || 1.6048;
        priceStore.lstRatios.ampCAPA = store.lstRatios?.ampCAPA?.ratio || 1.1055;
        priceStore.lstRatios.ampROAR = store.lstRatios?.ampROAR?.ratio || 1.1087;
        priceStore.lstRatios.xASTRO = store.lstRatios?.xASTRO?.ratio || 1.22;
        
        setTxt('price-status-lst', '‚úÖ');
    } catch (error) {
        setTxt('price-status-lst', '‚ö†Ô∏è');
    }
}

function calculateDerivedPrices() {
    if (priceStore.prices.CAPA && priceStore.lstRatios.ampCAPA) {
        priceStore.manualPrices.ampCAPA = priceStore.prices.CAPA * priceStore.lstRatios.ampCAPA;
        const el = $('manual-price-ampCAPA');
        if (el) el.value = priceStore.manualPrices.ampCAPA.toFixed(6);
        setTxt('manual-status-ampCAPA', '‚úÖ Calculated');
    }
    if (priceStore.prices.ROAR && priceStore.lstRatios.ampROAR) {
        priceStore.manualPrices.ampROAR = priceStore.prices.ROAR * priceStore.lstRatios.ampROAR;
        const el = $('manual-price-ampROAR');
        if (el) el.value = priceStore.manualPrices.ampROAR.toFixed(6);
        setTxt('manual-status-ampROAR', '‚úÖ Calculated');
    }
}

function calcDerivedPrice(ampToken, baseToken) {
    const basePrice = priceStore.prices[baseToken];
    const ratio = priceStore.lstRatios[ampToken];
    if (!basePrice || !ratio) { alert(`Need ${baseToken} price and ${ampToken} ratio. Fetch prices first.`); return; }
    priceStore.manualPrices[ampToken] = basePrice * ratio;
    $(`manual-price-${ampToken}`).value = priceStore.manualPrices[ampToken].toFixed(6);
    setTxt(`manual-status-${ampToken}`, '‚úÖ Calculated');
    updatePriceSnapshotPreview();
}

function renderBannerTokens() {
    const container = $('banner-tokens-list');
    if (!container) return;
    let html = '';
    priceStore.bannerTokens.forEach(token => {
        const price = priceStore.prices[token.symbol];
        const checked = priceStore.selectedTokens[token.symbol] ? 'checked' : '';
        const priceDisplay = price ? `$${price < 0.01 ? price.toFixed(6) : price.toFixed(4)}` : '--';
        const statusClass = price ? 'text-green-400' : 'text-gray-600';
        html += `<div class="grid grid-cols-12 gap-2 items-center bg-[#0D0D0D] rounded p-2 text-[10px]">
            <input type="checkbox" ${checked} class="col-span-1" onchange="toggleTokenSelection('${token.symbol}', this.checked)">
            <span class="col-span-3 text-white font-medium">${token.symbol}</span>
            <span class="col-span-4 text-gray-500 truncate text-[9px]">${token.geckoId || '-'}</span>
            <span class="col-span-3 text-right font-mono ${statusClass}">${priceDisplay}</span>
            <span class="col-span-1 text-center">${price ? 'üü¢' : '‚ö™'}</span>
        </div>`;
    });
    container.innerHTML = html || '<div class="text-gray-600 text-[10px] italic">No tokens</div>';
}

function toggleTokenSelection(symbol, selected) { priceStore.selectedTokens[symbol] = selected; updatePriceSnapshotPreview(); }

function updateLstRatiosSummary() {
    Object.keys(priceStore.lstRatios).forEach(symbol => {
        const el = $(`lst-sum-${symbol}`);
        if (el && priceStore.lstRatios[symbol]) el.innerText = priceStore.lstRatios[symbol].toFixed(4);
    });
}

function updatePriceSnapshotPreview() {
    const snapshot = { prices: {}, lst_ratios: priceStore.lstRatios, timestamp: new Date().toISOString() };
    priceStore.bannerTokens.forEach(token => {
        if (priceStore.selectedTokens[token.symbol] && priceStore.prices[token.symbol]) {
            snapshot.prices[token.symbol] = priceStore.prices[token.symbol];
        }
    });
    Object.keys(priceStore.manualPrices).forEach(symbol => {
        if (priceStore.manualPrices[symbol]) snapshot.prices[symbol] = priceStore.manualPrices[symbol];
    });
    setTxt('price-snapshot-count', Object.keys(snapshot.prices).length + ' tokens');
    setTxt('price-snapshot-preview', JSON.stringify(snapshot, null, 2));
}

function copyPriceSnapshot() {
    navigator.clipboard.writeText($('price-snapshot-preview').innerText);
    alert('Copied!');
}

function addManualToken() {
    const symbol = prompt('Enter token symbol:');
    if (!symbol) return;
    const container = $('additional-manual-tokens');
    container.insertAdjacentHTML('beforeend', `<div class="grid grid-cols-12 gap-2 items-center bg-[#0D0D0D] rounded p-2" id="manual-row-${symbol}">
        <input type="text" class="col-span-3 input-dark text-[10px]" value="${symbol}" readonly>
        <div class="col-span-3 text-[9px] text-gray-500">Manual</div>
        <input type="number" id="manual-price-${symbol}" step="0.0001" class="col-span-3 input-dark text-[10px] text-right" placeholder="USD" onchange="updateManualPrice('${symbol}', this.value)">
        <span id="manual-status-${symbol}" class="col-span-2 text-[9px] text-gray-600">‚ùå</span>
        <button onclick="$('manual-row-${symbol}').remove();delete priceStore.manualPrices['${symbol}'];updatePriceSnapshotPreview()" class="col-span-1 text-red-400"><i class="fas fa-trash"></i></button>
    </div>`);
}

function updateManualPrice(symbol, value) {
    const price = parseFloat(value);
    if (price > 0) { priceStore.manualPrices[symbol] = price; setTxt(`manual-status-${symbol}`, '‚úÖ'); }
    else { delete priceStore.manualPrices[symbol]; setTxt(`manual-status-${symbol}`, '‚ùå'); }
    updatePriceSnapshotPreview();
}

// ============ IFRAME PREVIEW MODAL ============

function openPreviewModal(url, title = 'Preview') {
    // Create modal if it doesn't exist
    let modal = $('preview-modal');
    if (!modal) {
        modal = document.createElement('div');
        modal.id = 'preview-modal';
        modal.className = 'fixed inset-0 bg-black/80 z-50 flex items-center justify-center p-4';
        modal.innerHTML = `
            <div class="bg-[#1a1a1a] rounded-lg border border-gray-700 w-full max-w-4xl h-[80vh] flex flex-col">
                <div class="flex justify-between items-center p-3 border-b border-gray-700">
                    <div class="flex items-center gap-3">
                        <span class="text-white font-bold text-sm" id="preview-modal-title">Preview</span>
                        <a id="preview-modal-link" href="#" target="_blank" class="text-[9px] text-cyan-400 hover:text-cyan-300">
                            <i class="fas fa-external-link-alt mr-1"></i> Open in new tab
                        </a>
                    </div>
                    <button onclick="closePreviewModal()" class="text-gray-400 hover:text-white text-xl px-2">&times;</button>
                </div>
                <div class="flex-1 overflow-hidden">
                    <iframe id="preview-modal-iframe" class="w-full h-full border-0" src="about:blank"></iframe>
                </div>
            </div>
        `;
        modal.onclick = (e) => { if (e.target === modal) closePreviewModal(); };
        document.body.appendChild(modal);
    }
    
    // Set content and show
    $('preview-modal-title').textContent = title;
    $('preview-modal-link').href = url;
    $('preview-modal-iframe').src = url;
    modal.classList.remove('hidden');
    modal.style.display = 'flex';
}

function closePreviewModal() {
    const modal = $('preview-modal');
    if (modal) {
        $('preview-modal-iframe').src = 'about:blank'; // Stop loading
        modal.style.display = 'none';
    }
}

function openTokenLookup(token) {
    const url = TOKEN_LOOKUP_URLS[token];
    if (url) {
        openPreviewModal(url, `${token} Price Lookup`);
    } else {
        alert(`No lookup URL configured for ${token}`);
    }
}
</script>
</body>
</html>
